
/*
 * 
 * (c) Copyright RIFT.io, 2013-2016, All Rights Reserved
 *
 */


/**
 * @file yangpbc_test.cpp
 *
 * Unit tests for yangpbc utility
 */

#include <limits.h>
#include <stdlib.h>
#include <iostream>

#include "rwut.h"
#include "rwlib.h"
#include "yangmodel.h"
#include "yangpbc.hpp"

#include "bumpy-conversion.pb-c.h"
#include "company.pb-c.h"
#include "document.pb-c.h"
#include "flat-conversion.pb-c.h"
#include "other-data_rwvcs.pb-c.h"
#include "test-leafref.pb-c.h"
#include "test-tag-generation-base.pb-c.h"
#include "test-tag-generation.pb-c.h"
#include "test-ydom-top.pb-c.h"
#include "testy2p-search-node1.pb-c.h"
#include "testy2p-search-node2.pb-c.h"
#include "testy2p-top1.pb-c.h"
#include "testy2p-top2.pb-c.h"
#include "test-field-merge.pb-c.h"
#include "test-ydom-aug.pb-c.h"
#include "test-augment-a1.pb-c.h"
#include "rw-base-f.pb-c.h"
#include "ifmgr.pb-c.h"
#include "trafdata.pb-c.h"

#include <boost/filesystem.hpp>

namespace FS = boost::filesystem;
using namespace rw_yang;


TEST(YangToPb, CreateDestroy)
{
  TEST_DESCRIPTION("This test creates and destroys PbModels");

  YangModelNcx* ymodel = YangModelNcx::create_model();
  ASSERT_TRUE(ymodel);
  YangModel::ptr_t ym(ymodel);

  PbModel* pbmodel = new PbModel(ymodel);
  ASSERT_TRUE(pbmodel);
  PbModel::ptr_t pbm(pbmodel);

  pbm.release();
}

TEST(YangToPb, TagNumbers)
{
  TEST_DESCRIPTION("Tests the tag numbers generated by yangpbc");

  RWPB_M_MSG_DECL_INIT(TestTagGeneration_TtgAbcGrpCont1, abcgrpcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGeneration_TtgAbcTopCont1, abctopcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGeneration_TtgbGrpCont1, grpcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGeneration_TtgbTopCont1, topcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGeneration_TtgbTopCont1, new_topcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGenerationBase_TtgbGrpCont1, base_grpcont1);
  RWPB_M_MSG_DECL_INIT(TestTagGenerationBase_TtgbGrpCont1, base_grpcont2);

  EXPECT_TRUE(grpcont1.base.descriptor);
  EXPECT_TRUE(base_grpcont1.base.descriptor);

  EXPECT_STREQ(base_grpcont1.base.descriptor->fields[0].name, grpcont1.base.descriptor->fields[0].name);
  EXPECT_EQ(base_grpcont1.base.descriptor->fields[0].id, grpcont1.base.descriptor->fields[0].id);

  EXPECT_STREQ(base_grpcont1.base.descriptor->fields[1].name, grpcont1.base.descriptor->fields[1].name);
  EXPECT_EQ(base_grpcont1.base.descriptor->fields[1].id, grpcont1.base.descriptor->fields[1].id);

  EXPECT_STREQ(base_grpcont1.base.descriptor->fields[2].name, grpcont1.base.descriptor->fields[2].name);
  EXPECT_EQ(base_grpcont1.base.descriptor->fields[2].id, grpcont1.base.descriptor->fields[2].id);


  EXPECT_STREQ(base_grpcont1.base.descriptor->fields[3].name, grpcont1.base.descriptor->fields[3].name);
  EXPECT_EQ(base_grpcont1.base.descriptor->fields[3].id, grpcont1.base.descriptor->fields[3].id);
  EXPECT_EQ(base_grpcont1.base.descriptor->fields[4].id, grpcont1.base.descriptor->fields[4].id);

  abcgrpcont1.has_abc_str1 = TRUE;
  abcgrpcont1.abc_num1 = 100;
  abcgrpcont1.has_abc_num1 = 100;
  strcpy(abcgrpcont1.abc_str1, "test-abc-str1");

  grpcont1.has_str1 = TRUE;
  strcpy(grpcont1.str1, "grpcont1-str1");
  grpcont1.has_num1 = TRUE;
  grpcont1.n_ll1 = 3;
  grpcont1.ll1[0] = 11;
  grpcont1.ll1[1] = 12;
  grpcont1.ll1[2] = 13;


  base_grpcont1.has_str1 = TRUE;
  strcpy(base_grpcont1.str1, "test-str1");
  base_grpcont1.has_num1 = TRUE;
  base_grpcont1.num1 = 20;
  base_grpcont1.n_ll1 = 3;
  base_grpcont1.ll1[0] = 1;
  base_grpcont1.ll1[1] = 2;
  base_grpcont1.ll1[2] = 3;
  char test_str[] = "test_str";
  topcont1.top_str1 = test_str;
  topcont1.cont1 = &grpcont1;
  topcont1.has_top_num1 = TRUE;
  topcont1.top_num1 = 25;
  char test_str3[] = "test_str3";
  topcont1.str3 = test_str3;
  topcont1.num3 = 50;

  XMLManager::uptr_t mgr(xml_manager_create_xerces());
  ASSERT_TRUE(mgr.get());

  YangModel* model = mgr->get_yang_model();
  ASSERT_TRUE(model);

  YangModule* ydom = model->load_module("test-tag-generation");
  ASSERT_TRUE(ydom);
  ydom = model->load_module("test-tag-generation-base");
  ASSERT_TRUE(ydom);

  char xml_str[2048] = {0};

  rw_status_t status = rw_xml_manager_pb_to_xml(mgr.get(), &topcont1, xml_str, sizeof(xml_str));
  ASSERT_EQ(status, RW_STATUS_SUCCESS);

  std::cout << xml_str << std::endl;

  status = rw_xml_manager_xml_to_pb(mgr.get(), xml_str, &new_topcont1.base, nullptr);
  ASSERT_EQ(status, RW_STATUS_SUCCESS);

  char new_xml_str[2048] = {0};
  status = rw_xml_manager_pb_to_xml(mgr.get(), &new_topcont1, new_xml_str, sizeof(new_xml_str));
  ASSERT_EQ(status, RW_STATUS_SUCCESS);

  std::cout <<  "new_xml_str = " << new_xml_str << std::endl;
  std::cout <<  "xml_str = " << xml_str << std::endl;
  EXPECT_STREQ(xml_str, new_xml_str);

  ASSERT_TRUE(topcont1.base.descriptor->ypbc_mdesc);

  EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->num_fields, 6);

  uint32_t expected_field_idx[] = {5, 6, 2, 3, 4,1 };
  const char yang_nodes[][20] = {"top-str1", "top-num1", "cont1", "str3", "num3", "new-top-str"};
  const rw_yang_stmt_type_t stmt_type[] = {RW_YANG_STMT_TYPE_LEAF, RW_YANG_STMT_TYPE_LEAF, RW_YANG_STMT_TYPE_CONTAINER,
    RW_YANG_STMT_TYPE_LEAF, RW_YANG_STMT_TYPE_LEAF, RW_YANG_STMT_TYPE_LEAF};
  const rw_yang_leaf_type_t leaf_type[] = {RW_YANG_LEAF_TYPE_STRING, RW_YANG_LEAF_TYPE_INT64,
    RW_YANG_LEAF_TYPE_NULL, RW_YANG_LEAF_TYPE_STRING, RW_YANG_LEAF_TYPE_INT8, RW_YANG_LEAF_TYPE_STRING};

  int i;

  ASSERT_TRUE(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs);
  for (i = 0; i < 6; i++) {
    unsigned pbc_index = expected_field_idx[i];
    EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].pbc_order, expected_field_idx[i]);
    EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].yang_order, i+1);
    EXPECT_STREQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].yang_node_name, yang_nodes[i]);
    EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].pbc_fdesc,
              &test_tag_generation__yang_data__test_tag_generation_base__top_cont1__field_descriptors[pbc_index - 1]);

    /* Let us check that the correct field descriptor pointer is assigned. */
    std::string mangled = YangModel::mangle_to_c_identifier(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].yang_node_name);
    EXPECT_STREQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].pbc_fdesc->name, mangled.c_str());

    EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].stmt_type, stmt_type[i]);
    EXPECT_EQ(topcont1.base.descriptor->ypbc_mdesc->ypbc_flddescs[i].leaf_type, leaf_type[i]);
  }
}

TEST(YangToPb, YangToPbRwOptions)
{
  TEST_DESCRIPTION("Test protobuf-fieldoptions");

  // check for key:true
  RWPB_M_MSG_DECL_INIT(Testy2pTop2_data_Topl_La,msg);
  EXPECT_TRUE(msg.base.descriptor->rw_flags & RW_PROTOBUF_MOPT_HAS_KEYS);

  EXPECT_TRUE(msg.base.descriptor->fields[0].rw_flags & RW_PROTOBUF_FOPT_KEY);
  EXPECT_TRUE(msg.base.descriptor->fields[1].rw_flags & RW_PROTOBUF_FOPT_KEY);
  EXPECT_TRUE(msg.base.descriptor->fields[2].rw_flags & RW_PROTOBUF_FOPT_KEY);

  RWPB_M_MSG_DECL_INIT(Testy2pTop2_data_Top2c_Cd,msg1);

  EXPECT_FALSE(msg1.base.descriptor->rw_flags & RW_PROTOBUF_MOPT_HAS_KEYS);
  protobuf_c_message_free_unpacked_usebody(NULL, &msg.base);
  protobuf_c_message_free_unpacked_usebody(NULL, &msg1.base);
}


/*****************************************************************************/

static const char* const testy2pt1_ns = "http://riftio.com/ns/core/util/yangtools/tests/testy2p-top1";
static const char* const testy2pt2_ns = "http://riftio.com/ns/core/util/yangtools/tests/testy2p-top2";
static const char* const testy2psn1_ns = "http://riftio.com/ns/core/util/yangtools/tests/testy2p-search-node1";
static const char* const testy2psn2_ns = "http://riftio.com/ns/core/util/yangtools/tests/testy2p-search-node2";



TEST(YangToPb, TypePunsSchemaModule)
{
  TEST_DESCRIPTION("Verify type-punning for auto-generated schema and module descriptors");

  auto s_t2 = RWPB_G_SCHEMA_YPBCSD(Testy2pTop2);
  auto m_t2 = s_t2->testy2p_top2;

  // Test the schema variable
  EXPECT_EQ(s_t2->schema_module, s_t2->testy2p_top2);
  EXPECT_EQ(s_t2->schema_module, m_t2);
  ASSERT_TRUE(s_t2->modules);
  ASSERT_EQ(s_t2->module_count, 5);
  EXPECT_TRUE(s_t2->modules[0]);
  EXPECT_TRUE(s_t2->modules[1]);
  EXPECT_TRUE(s_t2->modules[2]);
  EXPECT_TRUE(s_t2->modules[3]);
  EXPECT_TRUE(s_t2->modules[4]);
  ASSERT_EQ((const void*)s_t2->modules, (const void*)&s_t2->rw_pb_ext);
  EXPECT_EQ(s_t2->modules[0], (const rw_yang_pb_module_t*)s_t2->rw_pb_ext);
  EXPECT_EQ(s_t2->modules[4], (const rw_yang_pb_module_t*)s_t2->testy2p_top2);

  // Test a module variable
  EXPECT_EQ(m_t2->schema, s_t2);
  EXPECT_STREQ(m_t2->module_name, "testy2p-top2");
  EXPECT_STREQ(m_t2->revision, ""); // ATTN: revision not supported yet
  EXPECT_STREQ(m_t2->ns, testy2pt2_ns);
  EXPECT_STREQ(m_t2->prefix, "tyt2");
  ASSERT_TRUE(m_t2->data_module);
  EXPECT_FALSE(m_t2->group_root); // ATTN: FIX group_root
  ASSERT_TRUE(m_t2->rpci_module);
  ASSERT_TRUE(m_t2->rpco_module);
  ASSERT_TRUE(m_t2->notif_module);

  // Now test the generics
  const rw_yang_pb_schema_t* s_g = reinterpret_cast<const rw_yang_pb_schema_t*>(s_t2);
  const rw_yang_pb_module_t* m_g = reinterpret_cast<const rw_yang_pb_module_t*>(m_t2);

  EXPECT_EQ((const char*)&s_t2->rw_pb_ext-(const char*)s_t2, sizeof(rw_yang_pb_schema_t));
  EXPECT_EQ(s_g->schema_module, m_g);
  EXPECT_EQ(s_g->schema_module, (const rw_yang_pb_module_t*)s_t2->schema_module);
  EXPECT_EQ(s_g->modules, (const rw_yang_pb_module_t* const*)s_t2->modules);
  EXPECT_EQ(s_g->module_count, s_t2->module_count);
  EXPECT_TRUE(s_g->modules);
  EXPECT_TRUE(s_g->modules[0]);
  EXPECT_TRUE(s_g->modules[1]);
  EXPECT_EQ(s_g->modules[4], m_g);

  EXPECT_EQ(sizeof(*m_t2), sizeof(*m_g));
  ASSERT_EQ(m_g->schema, s_g);
  EXPECT_EQ(m_g->schema, (const rw_yang_pb_schema_t*)m_t2->schema);
  EXPECT_EQ(m_g->module_name, m_t2->module_name);
  EXPECT_EQ(m_g->revision, m_t2->revision);
  EXPECT_EQ(m_g->ns, m_t2->ns);
  EXPECT_EQ(m_g->prefix, m_t2->prefix);
  EXPECT_EQ(m_g->group_root, (const rw_yang_pb_group_root_t*)m_t2->group_root);
  EXPECT_EQ(m_g->rpci_module, (const rw_yang_pb_msgdesc_t*)m_t2->rpci_module);
  EXPECT_EQ(m_g->rpco_module, (const rw_yang_pb_msgdesc_t*)m_t2->rpco_module);
  EXPECT_EQ(m_g->notif_module, (const rw_yang_pb_msgdesc_t*)m_t2->notif_module);
  ASSERT_EQ(&m_g->data_module, (const rw_yang_pb_msgdesc_t* const*)&m_t2->data_module);
  ASSERT_EQ(&m_g->group_root, (const rw_yang_pb_group_root_t* const*)&m_t2->group_root);
  ASSERT_EQ(&m_g->rpci_module, (const rw_yang_pb_msgdesc_t* const*)&m_t2->rpci_module);
  ASSERT_EQ(&m_g->rpco_module, (const rw_yang_pb_msgdesc_t* const*)&m_t2->rpco_module);
  ASSERT_EQ(&m_g->notif_module, (const rw_yang_pb_msgdesc_t* const*)&m_t2->notif_module);
}

TEST(YangToPb, TypePunsModuleTop)
{
  TEST_DESCRIPTION("Verify type-punning in auto-generated module top-level descriptors");

  auto s_t2 = RWPB_G_SCHEMA_YPBCSD(Testy2pTop2);
  auto m_t2 = s_t2->testy2p_top2;
  const rw_yang_pb_module_t* m_g = reinterpret_cast<const rw_yang_pb_module_t*>(m_t2);

  // Check data, rpc, notif, grouping...
  auto dat_t2 = m_t2->data_module;
  //ATTN:TGS:GROUPS: auto grp_t2 = m_t2->group_root;
  auto rpi_t2 = m_t2->rpci_module;
  auto rpo_t2 = m_t2->rpco_module;
  auto ntf_t2 = m_t2->notif_module;

  ASSERT_TRUE(dat_t2);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_t2);
  ASSERT_TRUE(rpi_t2);
  ASSERT_TRUE(ntf_t2);

  const rw_yang_pb_msgdesc_t* dat_g = m_g->data_module;
  //ATTN:TGS:GROUPS: const rw_yang_pb_group_root_t* grp_g = m_g->group_root;
  const rw_yang_pb_msgdesc_t* rpi_g = m_g->rpci_module;
  const rw_yang_pb_msgdesc_t* rpo_g = m_g->rpco_module;
  const rw_yang_pb_msgdesc_t* ntf_g = m_g->notif_module;

  ASSERT_EQ(dat_g, (const rw_yang_pb_msgdesc_t*)dat_t2);
  //ATTN:TGS:GROUPS: ASSERT_EQ(grp_g, (const rw_yang_pb_group_root_t*)grp_t2);
  ASSERT_EQ(rpi_g, (const rw_yang_pb_msgdesc_t*)rpi_t2);
  ASSERT_EQ(rpo_g, (const rw_yang_pb_msgdesc_t*)rpo_t2);
  ASSERT_EQ(ntf_g, (const rw_yang_pb_msgdesc_t*)ntf_t2);

  EXPECT_EQ(dat_g->module, m_g);
  //ATTN:TGS:GROUPS: EXPECT_EQ(grp_g->module, m_g);
  EXPECT_EQ(rpi_g->module, m_g);
  EXPECT_EQ(rpo_g->module, m_g);
  EXPECT_EQ(ntf_g->module, m_g);

  EXPECT_EQ(dat_t2->ypbc.module, m_t2);
  //ATTN:TGS:GROUPS: EXPECT_EQ(grp_t2->module, m_t2);
  EXPECT_EQ(rpi_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpo_t2->ypbc.module, m_t2);
  EXPECT_EQ(ntf_t2->ypbc.module, m_t2);

  EXPECT_EQ(dat_t2->ypbc.child_msg_count, dat_g->child_msg_count);
  //ATTN:TGS:GROUPS: EXPECT_EQ(grp_t2->msg_count, grp_g->msg_count);
  EXPECT_EQ(rpi_t2->ypbc.child_msg_count, rpi_g->child_msg_count);
  EXPECT_EQ(rpo_t2->ypbc.child_msg_count, rpo_g->child_msg_count);
  EXPECT_EQ(ntf_t2->ypbc.child_msg_count, ntf_g->child_msg_count);

  ASSERT_TRUE(dat_g->child_msgs);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_g->msgs);
  ASSERT_TRUE(rpi_g->child_msgs);
  ASSERT_TRUE(rpo_g->child_msgs);
  ASSERT_TRUE(ntf_g->child_msgs);

  EXPECT_EQ(dat_g->child_msgs, (const rw_yang_pb_msgdesc_t* const*)&dat_t2->top2c);
  //ATTN:TGS:GROUPS: EXPECT_EQ(grp_g->msgs, (const rw_yang_pb_msgdesc_t* const*)&grp_t2->g);
  EXPECT_EQ(rpi_g->child_msgs, (const rw_yang_pb_msgdesc_t* const*)&rpi_t2->rpc_empty);
  EXPECT_EQ(rpo_g->child_msgs, (const rw_yang_pb_msgdesc_t* const*)&rpo_t2->rpc_empty);
  EXPECT_EQ(ntf_g->child_msgs, (const rw_yang_pb_msgdesc_t* const*)&ntf_t2->n1);

  EXPECT_EQ(dat_g->child_msgs[0], (const rw_yang_pb_msgdesc_t*)dat_t2->top2c);
  //ATTN:TGS:GROUPS: EXPECT_EQ(grp_g->msgs[0], (const rw_yang_pb_msgdesc_t*)grp_t2->g);
  EXPECT_EQ(rpi_g->child_msgs[0], (const rw_yang_pb_msgdesc_t*)rpi_t2->rpc_empty);
  EXPECT_EQ(rpo_g->child_msgs[0], (const rw_yang_pb_msgdesc_t*)rpo_t2->rpc_empty);
  EXPECT_EQ(ntf_g->child_msgs[0], (const rw_yang_pb_msgdesc_t*)ntf_t2->n1);

  // Check missing data, rpc, notif, grouping...
  ASSERT_TRUE(s_t2->rw_pb_ext);
  EXPECT_FALSE(s_t2->rw_pb_ext->data_module);
  EXPECT_FALSE(s_t2->rw_pb_ext->group_root);
  EXPECT_FALSE(s_t2->rw_pb_ext->rpci_module);
  EXPECT_FALSE(s_t2->rw_pb_ext->rpco_module);
  EXPECT_FALSE(s_t2->rw_pb_ext->notif_module);
}

TEST(YangToPb, TypePunsRpc)
{
  TEST_DESCRIPTION("Verify type-punning in auto-generated rpc descriptors");

  auto s_t2 = RWPB_G_SCHEMA_YPBCSD(Testy2pTop2);
  auto m_t2 = s_t2->testy2p_top2;
  auto dat_t2 = m_t2->data_module;
  //ATTN:TGS:GROUPS: auto grp_t2 = m_t2->group_root;
  auto rpi_t2 = m_t2->rpci_module;
  auto rpo_t2 = m_t2->rpco_module;
  auto ntf_t2 = m_t2->notif_module;
  ASSERT_TRUE(dat_t2);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_t2);
  ASSERT_TRUE(rpi_t2);
  ASSERT_TRUE(rpo_t2);
  ASSERT_TRUE(ntf_t2);

  const rw_yang_pb_module_t* m_g = reinterpret_cast<const rw_yang_pb_module_t*>(m_t2);
  const rw_yang_pb_msgdesc_t* dat_g = m_g->data_module;
  //ATTN:TGS:GROUPS: const rw_yang_pb_group_root_t* grp_g = m_g->group_root;
  const rw_yang_pb_msgdesc_t* rpi_g = m_g->rpci_module;
  const rw_yang_pb_msgdesc_t* rpo_g = m_g->rpco_module;
  const rw_yang_pb_msgdesc_t* ntf_g = m_g->notif_module;
  ASSERT_TRUE(dat_g);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_g);
  ASSERT_TRUE(rpi_g);
  ASSERT_TRUE(rpo_g);
  ASSERT_TRUE(ntf_g);

  // Check rpc definition internals
  auto rpi_xx_t2 = rpi_t2->rpc_empty;
  auto rpi_ix_t2 = rpi_t2->rpc_in_only;
  auto rpi_xo_t2 = rpi_t2->rpc_out_only;
  auto rpi_io_t2 = rpi_t2->rpc_in_out;

  ASSERT_TRUE(rpi_xx_t2);
  ASSERT_TRUE(rpi_ix_t2);
  ASSERT_TRUE(rpi_xo_t2);
  ASSERT_TRUE(rpi_io_t2);

  auto rpo_xx_t2 = rpo_t2->rpc_empty;
  auto rpo_ix_t2 = rpo_t2->rpc_in_only;
  auto rpo_xo_t2 = rpo_t2->rpc_out_only;
  auto rpo_io_t2 = rpo_t2->rpc_in_out;

  ASSERT_TRUE(rpo_xx_t2);
  ASSERT_TRUE(rpo_ix_t2);
  ASSERT_TRUE(rpo_xo_t2);
  ASSERT_TRUE(rpo_io_t2);

  ASSERT_GE(rpi_g->child_msg_count, 4);
  const rw_yang_pb_msgdesc_t* rpi_xx_g = rpi_g->child_msgs[0];
  const rw_yang_pb_msgdesc_t* rpi_ix_g = rpi_g->child_msgs[1];
  const rw_yang_pb_msgdesc_t* rpi_xo_g = rpi_g->child_msgs[2];
  const rw_yang_pb_msgdesc_t* rpi_io_g = rpi_g->child_msgs[3];

  EXPECT_TRUE(rpi_xx_g);
  EXPECT_TRUE(rpi_ix_g);
  EXPECT_TRUE(rpi_xo_g);
  EXPECT_TRUE(rpi_io_g);

  ASSERT_GE(rpo_g->child_msg_count, 4);
  const rw_yang_pb_msgdesc_t* rpo_xx_g = rpo_g->child_msgs[0];
  const rw_yang_pb_msgdesc_t* rpo_ix_g = rpo_g->child_msgs[1];
  const rw_yang_pb_msgdesc_t* rpo_xo_g = rpo_g->child_msgs[2];
  const rw_yang_pb_msgdesc_t* rpo_io_g = rpo_g->child_msgs[3];

  EXPECT_TRUE(rpo_xx_g);
  EXPECT_TRUE(rpo_ix_g);
  EXPECT_TRUE(rpo_xo_g);
  EXPECT_TRUE(rpo_io_g);


  ASSERT_EQ(rpi_xx_g, (const rw_yang_pb_msgdesc_t*)rpi_xx_t2);
  ASSERT_EQ(rpi_ix_g, (const rw_yang_pb_msgdesc_t*)rpi_ix_t2);
  ASSERT_EQ(rpi_xo_g, (const rw_yang_pb_msgdesc_t*)rpi_xo_t2);
  ASSERT_EQ(rpi_io_g, (const rw_yang_pb_msgdesc_t*)rpi_io_t2);

  EXPECT_EQ(rpi_xx_g->module, m_g);
  EXPECT_EQ(rpi_ix_g->module, m_g);
  EXPECT_EQ(rpi_xo_g->module, m_g);
  EXPECT_EQ(rpi_io_g->module, m_g);

  EXPECT_EQ(rpi_xx_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpi_ix_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpi_xo_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpi_io_t2->ypbc.module, m_t2);

  EXPECT_STREQ(rpi_xx_g->yang_node_name, "rpc-empty");
  EXPECT_EQ(rpi_xx_g->yang_node_name, rpi_xx_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpi_ix_g->yang_node_name, rpi_ix_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpi_xo_g->yang_node_name, rpi_xo_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpi_io_g->yang_node_name, rpi_io_t2->ypbc.yang_node_name);


  ASSERT_EQ(rpo_xx_g, (const rw_yang_pb_msgdesc_t*)rpo_xx_t2);
  ASSERT_EQ(rpo_ix_g, (const rw_yang_pb_msgdesc_t*)rpo_ix_t2);
  ASSERT_EQ(rpo_xo_g, (const rw_yang_pb_msgdesc_t*)rpo_xo_t2);
  ASSERT_EQ(rpo_io_g, (const rw_yang_pb_msgdesc_t*)rpo_io_t2);

  EXPECT_EQ(rpo_xx_g->module, m_g);
  EXPECT_EQ(rpo_ix_g->module, m_g);
  EXPECT_EQ(rpo_xo_g->module, m_g);
  EXPECT_EQ(rpo_io_g->module, m_g);

  EXPECT_EQ(rpo_xx_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpo_ix_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpo_xo_t2->ypbc.module, m_t2);
  EXPECT_EQ(rpo_io_t2->ypbc.module, m_t2);

  EXPECT_STREQ(rpo_xx_g->yang_node_name, "rpc-empty");
  EXPECT_EQ(rpo_xx_g->yang_node_name, rpo_xx_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpo_ix_g->yang_node_name, rpo_ix_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpo_xo_g->yang_node_name, rpo_xo_t2->ypbc.yang_node_name);
  EXPECT_EQ(rpo_io_g->yang_node_name, rpo_io_t2->ypbc.yang_node_name);


  auto rpi_xx_t2_rd = rpi_xx_t2->ypbc.rpcdef;
  auto rpi_ix_t2_rd = rpi_ix_t2->ypbc.rpcdef;
  auto rpi_xo_t2_rd = rpi_xo_t2->ypbc.rpcdef;
  auto rpi_io_t2_rd = rpi_io_t2->ypbc.rpcdef;

  ASSERT_TRUE(rpi_xx_t2_rd);
  ASSERT_TRUE(rpi_ix_t2_rd);
  ASSERT_TRUE(rpi_xo_t2_rd);
  ASSERT_TRUE(rpi_io_t2_rd);

  ASSERT_EQ(rpi_xx_t2_rd, rpo_xx_t2->ypbc.rpcdef);
  ASSERT_EQ(rpi_ix_t2_rd, rpo_ix_t2->ypbc.rpcdef);
  ASSERT_EQ(rpi_xo_t2_rd, rpo_xo_t2->ypbc.rpcdef);
  ASSERT_EQ(rpi_io_t2_rd, rpo_io_t2->ypbc.rpcdef);

  ASSERT_EQ((const rw_yang_pb_rpcdef_t*)rpi_xx_t2_rd, &rpi_xx_g->u->rpcdef);
  ASSERT_EQ((const rw_yang_pb_rpcdef_t*)rpi_ix_t2_rd, &rpi_ix_g->u->rpcdef);
  ASSERT_EQ((const rw_yang_pb_rpcdef_t*)rpi_xo_t2_rd, &rpi_xo_g->u->rpcdef);
  ASSERT_EQ((const rw_yang_pb_rpcdef_t*)rpi_io_t2_rd, &rpi_io_g->u->rpcdef);

  ASSERT_EQ(&rpi_xx_g->u->rpcdef, &rpo_xx_g->u->rpcdef);
  ASSERT_EQ(&rpi_ix_g->u->rpcdef, &rpo_ix_g->u->rpcdef);
  ASSERT_EQ(&rpi_xo_g->u->rpcdef, &rpo_xo_g->u->rpcdef);
  ASSERT_EQ(&rpi_io_g->u->rpcdef, &rpo_io_g->u->rpcdef);
}

TEST(YangToPb, TypePunsMsgDesc)
{
  TEST_DESCRIPTION("Verify type-punning in auto-generated message descriptors");

  auto s_t2 = RWPB_G_SCHEMA_YPBCSD(Testy2pTop2);
  auto m_t2 = s_t2->testy2p_top2;
  auto dat_t2 = m_t2->data_module;
  //ATTN:TGS:GROUPS: auto grp_t2 = m_t2->group_root;
  auto rpi_t2 = m_t2->rpci_module;
  auto rpo_t2 = m_t2->rpco_module;
  auto ntf_t2 = m_t2->notif_module;
  ASSERT_TRUE(dat_t2);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_t2);
  ASSERT_TRUE(rpi_t2);
  ASSERT_TRUE(rpo_t2);
  ASSERT_TRUE(ntf_t2);

  const rw_yang_pb_module_t* m_g = reinterpret_cast<const rw_yang_pb_module_t*>(m_t2);
  const rw_yang_pb_msgdesc_t* dat_g = m_g->data_module;
  //ATTN:TGS:GROUPS: const rw_yang_pb_group_root_t* grp_g = m_g->group_root;
  const rw_yang_pb_msgdesc_t* rpi_g = m_g->rpci_module;
  const rw_yang_pb_msgdesc_t* rpo_g = m_g->rpco_module;
  const rw_yang_pb_msgdesc_t* ntf_g = m_g->notif_module;
  ASSERT_TRUE(dat_g);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_g);
  ASSERT_TRUE(rpi_g);
  ASSERT_TRUE(ntf_g);


  auto dat_ttc_t2  = dat_t2->top2c;
  auto dat_tl_t2   = dat_t2->topl;
  auto dat_bkl_t2  = dat_t2->bkll;
  //ATTN:TGS:GROUPS: auto grp_g_t2    = grp_t2->g;
  //ATTN:TGS:GROUPS: auto grp_gc_t2   = grp_t2->gc;
  auto ntf_n1_t2   = ntf_t2->n1;
  auto ntf_n2_t2   = ntf_t2->n2;
  auto rpi_ix_t2   = rpi_t2->rpc_in_only;
  auto rpo_xo_t2   = rpo_t2->rpc_out_only;
  auto rpi_io_t2   = rpi_t2->rpc_in_out;
  auto rpo_io_t2   = rpo_t2->rpc_in_out;

  ASSERT_TRUE(dat_ttc_t2);
  ASSERT_TRUE(dat_tl_t2);
  ASSERT_TRUE(dat_bkl_t2);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_g_t2);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_gc_t2);
  ASSERT_TRUE(ntf_n1_t2);
  ASSERT_TRUE(ntf_n2_t2);
  ASSERT_TRUE(rpi_ix_t2);
  ASSERT_TRUE(rpo_xo_t2);
  ASSERT_TRUE(rpo_io_t2);
  ASSERT_TRUE(rpo_io_t2);

  auto dat_ttc_gc_t2  = dat_ttc_t2->c;
  auto dat_ttc_cd_t2  = dat_ttc_t2->cd;
  auto dat_tl_a_t2    = dat_tl_t2->la;
  auto dat_bkl_ll_t2  = dat_bkl_t2->ll;
  //ATTN:TGS:GROUPS: auto grp_gc_c_t2    = grp_gc_t2->c;
  auto rpo_xo_c_t2    = rpo_xo_t2->c;
  auto rpo_io_cr_t2   = rpo_io_t2->cr;
  auto ntf_n2_gc_t2   = ntf_n2_t2->c;
  auto ntf_n2_cn_t2   = ntf_n2_t2->cn;


  ASSERT_GT(dat_g->child_msg_count, 0);
  ASSERT_GT(dat_g->child_msg_count, 1);
  //ATTN:TGS:GROUPS: ASSERT_GT(grp_g->msg_count, 0);
  //ATTN:TGS:GROUPS: ASSERT_GT(grp_g->msg_count, 1);
  ASSERT_GT(ntf_g->child_msg_count, 0);
  ASSERT_GT(ntf_g->child_msg_count, 1);
  ASSERT_GT(rpi_g->child_msg_count, 1);
  ASSERT_GT(rpo_g->child_msg_count, 2);
  ASSERT_GT(rpi_g->child_msg_count, 3);
  ASSERT_GT(rpo_g->child_msg_count, 3);

  const rw_yang_pb_msgdesc_t* dat_ttc_g  = dat_g->child_msgs[0];
  const rw_yang_pb_msgdesc_t* dat_tl_g   = dat_g->child_msgs[1];
  const rw_yang_pb_msgdesc_t* dat_bkl_g  = dat_g->child_msgs[2];
  //ATTN:TGS:GROUPS: const rw_yang_pb_msgdesc_t* grp_g_g    = grp_g->msgs[0];
  //ATTN:TGS:GROUPS: const rw_yang_pb_msgdesc_t* grp_gc_g   = grp_g->msgs[1];
  const rw_yang_pb_msgdesc_t* ntf_n1_g   = ntf_g->child_msgs[0];
  const rw_yang_pb_msgdesc_t* ntf_n2_g   = ntf_g->child_msgs[1];
  const rw_yang_pb_msgdesc_t* rpi_ix_g   = rpi_g->child_msgs[1];
  const rw_yang_pb_msgdesc_t* rpo_xo_g   = rpo_g->child_msgs[2];
  const rw_yang_pb_msgdesc_t* rpi_io_g   = rpi_g->child_msgs[3];
  const rw_yang_pb_msgdesc_t* rpo_io_g   = rpo_g->child_msgs[3];

  ASSERT_TRUE(dat_ttc_g->child_msgs);
  ASSERT_TRUE(dat_tl_g->child_msgs);
  ASSERT_TRUE(dat_bkl_g->child_msgs);
  //ATTN:TGS:GROUPS: ASSERT_FALSE(grp_g_g->child_msgs);
  //ATTN:TGS:GROUPS: ASSERT_TRUE(grp_gc_g->child_msgs);
  ASSERT_FALSE(ntf_n1_g->child_msgs);
  ASSERT_TRUE(ntf_n2_g->child_msgs);
  ASSERT_TRUE(rpi_ix_g->child_msgs);
  ASSERT_TRUE(rpo_xo_g->child_msgs);
  ASSERT_TRUE(rpi_io_g->child_msgs);
  ASSERT_TRUE(rpo_io_g->child_msgs);

  ASSERT_GT(dat_ttc_g->child_msg_count, 0);
  ASSERT_GT(dat_ttc_g->child_msg_count, 1);
  ASSERT_GT(dat_tl_g->child_msg_count, 0);
  ASSERT_GT(dat_bkl_g->child_msg_count, 0);
  //ATTN:TGS:GROUPS: ASSERT_GT(grp_gc_g->child_msg_count, 0);
  ASSERT_GT(rpo_xo_g->child_msg_count, 0);
  ASSERT_GT(rpo_io_g->child_msg_count, 0);
  ASSERT_GT(ntf_n2_g->child_msg_count, 0);
  ASSERT_GT(ntf_n2_g->child_msg_count, 1);

  auto dat_ttc_gc_g  = dat_ttc_g->child_msgs[0];
  auto dat_ttc_cd_g  = dat_ttc_g->child_msgs[1];
  auto dat_tl_a_g    = dat_tl_g->child_msgs[0];
  auto dat_bkl_ll_g  = dat_bkl_g->child_msgs[0];
  //ATTN:TGS:GROUPS: auto grp_gc_c_g    = grp_gc_g->child_msgs[0];
  auto rpo_xo_c_g    = rpo_xo_g->child_msgs[0];
  auto rpo_io_cr_g   = rpo_io_g->child_msgs[0];
  auto ntf_n2_gc_g   = ntf_n2_g->child_msgs[0];
  auto ntf_n2_cn_g   = ntf_n2_g->child_msgs[1];


  #define YANG_PB_TEST_TOP( v_, name_, max_fields_, m_, u_mbr_ ) \
    YANG_PB_TEST( v_##_g, v_##_t2, name_, max_fields_, RW_YANGPBC_MSG_TYPE_##m_, u_mbr_ )

  #define YANG_PB_TEST_ALL() \
    YANG_PB_TEST_TOP( dat_ttc,     "top2c",         10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( dat_ttc_gc,  "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( dat_ttc_cd,  "cd",            10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( dat_tl,      "topl",          10, LIST,         u      ) \
    YANG_PB_TEST_TOP( dat_tl_a,    "la",            10, LIST,         u      ) \
    YANG_PB_TEST_TOP( dat_bkl,     "bkll",          10, LIST,         u      ) \
    YANG_PB_TEST_TOP( dat_bkl_ll,  "ll",            0,  LEAF_LIST,    u      ) \
  /*ATTN:TGS:GROUPS*/ \
  /*YANG_PB_TEST_TOP( grp_g,       "g",             10, GROUPING,     u      )*/ \
  /*YANG_PB_TEST_TOP( grp_gc,      "gc",            10, GROUPING,     u      )*/ \
  /*YANG_PB_TEST_TOP( grp_gc_c,    "c",             10, CONTAINER,    u      )*/ \
    YANG_PB_TEST_TOP( rpi_ix,      "rpc-in-only",   10, RPC_INPUT,    rpcdef ) \
    YANG_PB_TEST_TOP( rpo_xo,      "rpc-out-only",  10, RPC_OUTPUT,   rpcdef ) \
    YANG_PB_TEST_TOP( rpo_xo_c,    "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( rpi_io,      "rpc-in-out",    10, RPC_INPUT,    rpcdef ) \
    YANG_PB_TEST_TOP( rpo_io,      "rpc-in-out",    10, RPC_OUTPUT,   rpcdef ) \
    YANG_PB_TEST_TOP( rpo_io_cr,   "cr",            20, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( ntf_n1,      "n1",            10, NOTIFICATION, u      ) \
    YANG_PB_TEST_TOP( ntf_n2,      "n2",            10, NOTIFICATION, u      ) \
    YANG_PB_TEST_TOP( ntf_n2_gc,   "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( ntf_n2_cn,   "cn",            20, CONTAINER,    u      ) \

  #define YANG_PB_TEST_LIST() \
    YANG_PB_TEST_TOP( dat_tl,      "topl",          10, LIST,         u      ) \
    YANG_PB_TEST_TOP( dat_tl_a,    "la",            10, LIST,         u      ) \

  #define YANG_PB_TEST_NONLIST() \
    YANG_PB_TEST_TOP( dat_ttc,     "top2c",         10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( dat_ttc_gc,  "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( dat_ttc_cd,  "cd",            10, CONTAINER,    u      ) \
  /*ATTN:TGS:GROUPS*/ \
  /*YANG_PB_TEST_TOP( grp_g,       "g",             10, GROUPING,     u      )*/ \
  /*YANG_PB_TEST_TOP( grp_gc,      "gc",            10, GROUPING,     u      )*/ \
  /*YANG_PB_TEST_TOP( grp_gc_c,    "c",             10, CONTAINER,    u      )*/ \
    YANG_PB_TEST_TOP( rpi_ix,      "rpc-in-only",   10, RPC_INPUT,    rpcdef ) \
    YANG_PB_TEST_TOP( rpo_xo,      "rpc-out-only",  10, RPC_OUTPUT,   rpcdef ) \
    YANG_PB_TEST_TOP( rpo_xo_c,    "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( rpi_io,      "rpc-in-out",    10, RPC_INPUT,    rpcdef ) \
    YANG_PB_TEST_TOP( rpo_io,      "rpc-in-out",    10, RPC_OUTPUT,   rpcdef ) \
    YANG_PB_TEST_TOP( rpo_io_cr,   "cr",            20, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( ntf_n1,      "n1",            10, NOTIFICATION, u      ) \
    YANG_PB_TEST_TOP( ntf_n2,      "n2",            10, NOTIFICATION, u      ) \
    YANG_PB_TEST_TOP( ntf_n2_gc,   "c",             10, CONTAINER,    u      ) \
    YANG_PB_TEST_TOP( ntf_n2_cn,   "cn",            20, CONTAINER,    u      ) \

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_, (const rw_yang_pb_msgdesc_t*)t_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->module, m_g);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_STREQ(g_->yang_node_name, name_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_LE(g_->num_fields, max_fields_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->num_fields, t_->ypbc.num_fields);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->ypbc_flddescs, t_->ypbc.ypbc_flddescs);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->parent, (const rw_yang_pb_msgdesc_t*)t_->ypbc.parent);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->pbc_mdesc, (const ProtobufCMessageDescriptor*)t_->ypbc.pbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    if (msg_type_ == RW_YANGPBC_MSG_TYPE_LEAF_LIST) \
      ASSERT_FALSE(t_->ypbc.pbc_mdesc); \
    else \
      ASSERT_TRUE(t_->ypbc.pbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    if (msg_type_ != RW_YANGPBC_MSG_TYPE_LEAF_LIST) \
      EXPECT_TRUE(t_->ypbc.pbc_mdesc->ypbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    if (msg_type_ != RW_YANGPBC_MSG_TYPE_LEAF_LIST) \
       EXPECT_EQ(g_, t_->ypbc.pbc_mdesc->ypbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_entry_ypbc_desc, (const rw_yang_pb_msgdesc_t*)t_->ypbc.schema_entry_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_path_ypbc_desc, (const rw_yang_pb_msgdesc_t*)t_->ypbc.schema_path_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_list_only_ypbc_desc, (const rw_yang_pb_msgdesc_t*)t_->ypbc.schema_list_only_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(t_->ypbc.schema_entry_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(t_->ypbc.schema_path_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(t_->ypbc.schema_entry_ypbc_desc->msg_msgdesc, t_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(t_->ypbc.schema_path_ypbc_desc->msg_msgdesc, t_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(t_->ypbc.schema_list_only_ypbc_desc);\
    ASSERT_TRUE(t_->ypbc.schema_list_only_ypbc_desc->msg_msgdesc); \
    EXPECT_EQ(t_->ypbc.schema_list_only_ypbc_desc->msg_msgdesc, t_);
  YANG_PB_TEST_LIST()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_FALSE(t_->ypbc.schema_list_only_ypbc_desc);
  YANG_PB_TEST_NONLIST()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_entry_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_path_ypbc_desc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(&g_->schema_entry_ypbc_desc->u->msg_msgdesc, g_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(&g_->schema_path_ypbc_desc->u->msg_msgdesc, g_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_list_only_ypbc_desc);\
    EXPECT_EQ(&g_->schema_list_only_ypbc_desc->u->msg_msgdesc, g_);
  YANG_PB_TEST_LIST()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_FALSE(g_->schema_list_only_ypbc_desc);
  YANG_PB_TEST_NONLIST()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_entry_ypbc_desc->pbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_path_ypbc_desc->pbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_entry_ypbc_desc->pbc_mdesc->ypbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_path_ypbc_desc->pbc_mdesc->ypbc_mdesc);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(&g_->schema_entry_ypbc_desc->pbc_mdesc->ypbc_mdesc->u->msg_msgdesc, g_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(&g_->schema_path_ypbc_desc->pbc_mdesc->ypbc_mdesc->u->msg_msgdesc, g_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    ASSERT_TRUE(g_->schema_list_only_ypbc_desc->pbc_mdesc); \
    ASSERT_TRUE(g_->schema_list_only_ypbc_desc->pbc_mdesc->ypbc_mdesc); \
    EXPECT_EQ(&g_->schema_list_only_ypbc_desc->pbc_mdesc->ypbc_mdesc->u->msg_msgdesc, g_);
  YANG_PB_TEST_LIST()


  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_STREQ(g_->schema_entry_ypbc_desc->yang_node_name, t_->ypbc.yang_node_name);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_STREQ(g_->schema_path_ypbc_desc->yang_node_name, t_->ypbc.yang_node_name);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_FALSE(g_->schema_entry_ypbc_desc->num_fields);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_FALSE(g_->schema_path_ypbc_desc->num_fields);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_entry_ypbc_desc->msg_type, RW_YANGPBC_MSG_TYPE_SCHEMA_ENTRY);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_path_ypbc_desc->msg_type, RW_YANGPBC_MSG_TYPE_SCHEMA_PATH);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_STREQ(g_->schema_list_only_ypbc_desc->yang_node_name, t_->ypbc.yang_node_name); \
    EXPECT_EQ(g_->schema_list_only_ypbc_desc->num_fields, 0); \
    EXPECT_EQ(g_->schema_list_only_ypbc_desc->msg_type, RW_YANGPBC_MSG_TYPE_SCHEMA_LIST_ONLY);\
    EXPECT_FALSE(g_->schema_list_only_ypbc_desc->schema_path_ypbc_desc); \
    EXPECT_FALSE(g_->schema_list_only_ypbc_desc->schema_entry_ypbc_desc);
  YANG_PB_TEST_LIST()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_entry_value, (const rw_keyspec_entry_t*)t_->ypbc.schema_entry_value);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->schema_path_value, (const rw_keyspec_path_t*)t_->ypbc.schema_path_value);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->child_msgs, t_->ypbc.child_msgs);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->child_msg_count, t_->ypbc.child_msg_count);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->msg_type, t_->ypbc.msg_type);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ(g_->msg_type, msg_type_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #define YANG_PB_TEST(g_,t_,name_,max_fields_,msg_type_,u_mbr_) \
    EXPECT_EQ((const void*)g_->u, (const void *)t_->ypbc.u_mbr_);
  YANG_PB_TEST_ALL()

  #undef YANG_PB_TEST
  #undef YANG_PB_TEST_ALL
}

TEST(YangToPb, ParseAllFiles)
{
  TEST_DESCRIPTION("Parse all the test yang files");

  const char* env_rift_root = getenv("RIFT_ROOT");
  ASSERT_TRUE(env_rift_root);
  FS::path yang_test_files = FS::path(env_rift_root)/"modules/core/util/yangtools/test/yang";

  for (auto di = FS::directory_iterator(yang_test_files);
       di != FS::directory_iterator();
       ++di) {
    const FS::path& f = di->path();
    if (f.extension() != ".yang") {
      continue;
    }

#ifndef CONFD_ENABLED
    if (f.filename() == "tailf-raw.tailf.yang") {
      continue;
    }
#endif

    std::cout << "Test yangpbc parse " << f << std::endl;
    NamespaceManager::get_global().unittest_runtime_clear();

    YangModelNcx* ymodel = YangModelNcx::create_model();
    EXPECT_TRUE(ymodel);
    if (!ymodel) {
      continue;
    }
    YangModel::ptr_t ym(ymodel);

    PbModel* pbmodel = new PbModel(ymodel);
    EXPECT_TRUE(pbmodel);
    if (!pbmodel) {
      continue;
    }
    PbModel::ptr_t pbm(pbmodel);

    PbModule* pbmod = pbmodel->module_load(f.stem().string().c_str());
    EXPECT_TRUE(pbmod) << " file " << f;
    if (!pbmod) {
      continue;
    }

    pbmodel->parse_nodes();

    if (!pbmodel->is_failed()) {
      pbmodel->output_proto(nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());

      pbmodel->output_h_file(nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());

      pbmodel->output_cpp_file(nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());

      pbmodel->output_gi_c_file(nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());

      pbmodel->output_doc_user_file(doc_file_t::TEXT, nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());

      pbmodel->output_doc_api_file(doc_file_t::TEXT, nullptr);
      EXPECT_EQ(0, pbmodel->get_errors());
    }
  }
}

TEST(YangToPb, ElementTypeGen)
{
  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(BumpyConversion_data_Container1_Container11_List112)->element_id.element_type,
             RW_SCHEMA_ELEMENT_TYPE_LISTY_1_SINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(FlatConversion_data_Container1_Container11_List112)->element_id.element_type,
           RW_SCHEMA_ELEMENT_TYPE_LISTY_1_SINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(FlatConversion_data_Container1_TwoKeys)->element_id.element_type,
             RW_SCHEMA_ELEMENT_TYPE_LISTY_2);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(TestYdomTop_data_Top_A_ContInA_Lst)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(TestYdomTop_data_Top_ApisTest_Reallist)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Document_data_TableOfContents_Entry)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Document_data_MainBook_Chapters)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1_UINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Company_data_Company_Employee)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1_SINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Company_data_Company_Product)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1_SINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(OtherDataRwvcs_data_DataTop_Rwvcs_RwcomponentList_RwcomponentInfo)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(TestTagGenerationBase_data_TopCont1_Cont1_Lst1)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LISTY_1_STRING);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(TestTagGenerationBase_data_TopCont2_Cont1_Lst1)->element_id.element_type,
         RW_SCHEMA_ELEMENT_TYPE_LISTY_1_STRING);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Testy2pSearchNode1_data_Tysn1T1_Lvl2l)->element_id.element_type,
         RW_SCHEMA_ELEMENT_TYPE_LISTY_2);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Testy2pTop1_data_Top1c1_Top1g2C1_L1_L1)->element_id.element_type,
        RW_SCHEMA_ELEMENT_TYPE_LISTY_1_UINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Testy2pTop1_data_Top1c1_Top1g2C1_L1)->element_id.element_type,
        RW_SCHEMA_ELEMENT_TYPE_LISTY_1_UINT32);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Testy2pTop1_data_Top1c1_Top1g2L1)->element_id.element_type,
       RW_SCHEMA_ELEMENT_TYPE_LISTY_1);

  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(Testy2pTop1_data_Top1c1_Top1g2L1_L1)->element_id.element_type,
        RW_SCHEMA_ELEMENT_TYPE_LISTY_1_UINT32);

  // Leaf-lists
  EXPECT_EQ(RWPB_G_PATHENTRY_VALUE(TestYdomTop_data_Top_ApisTest_Primlist)->element_id.element_type,
            RW_SCHEMA_ELEMENT_TYPE_LEAF_LIST);
}

TEST(YangToPb, MetaData)
{
  TEST_DESCRIPTION("Test some meta-data");
  EXPECT_EQ(RWPB_C_MSG_FIELD_MAX_ELEMENTS(FlatConversion_FirstLevel_AllTypes,n1),4);
  EXPECT_EQ(RWPB_C_MSG_FIELD_INLINE_MAX(FlatConversion_FirstLevel_Container11,list_1_1_2),10);

  // ATTN: +1 for NUL
  EXPECT_EQ(RWPB_C_MSG_FIELD_STRING_MAX(FlatConversion_FirstLevel_Container11,leaf_1_1_1),31);
}

TEST(YangToPb, FieldDescs)
{
  auto schema = RWPB_G_SCHEMA_YPBCSD(Testy2pTop2);

  auto s_m = schema->schema_module;

  EXPECT_TRUE(s_m->data_module->ypbc.ypbc_flddescs);
  EXPECT_EQ(s_m->data_module->ypbc.num_fields, 3);
  EXPECT_STREQ(s_m->data_module->ypbc.ypbc_flddescs[0].yang_node_name, "top2c");
  EXPECT_STREQ(s_m->data_module->ypbc.ypbc_flddescs[1].yang_node_name, "topl");

  EXPECT_EQ(s_m->data_module->ypbc.child_msg_count, 3);

  auto top2c = s_m->data_module->ypbc.child_msgs[0];
  EXPECT_TRUE(top2c->ypbc_flddescs);
  EXPECT_EQ(top2c->num_fields, 3);
  EXPECT_STREQ(top2c->ypbc_flddescs[0].yang_node_name, "c");
  EXPECT_EQ(top2c->ypbc_flddescs[0].module, top2c->module);
  EXPECT_EQ(top2c->ypbc_flddescs[0].module, (rw_yang_pb_module_t *)s_m);
  EXPECT_STREQ(top2c->ypbc_flddescs[1].yang_node_name, "lf3");
  EXPECT_STREQ(top2c->ypbc_flddescs[2].yang_node_name, "cd");
  EXPECT_FALSE(top2c->schema_path_ypbc_desc->ypbc_flddescs);
  EXPECT_FALSE(top2c->schema_entry_ypbc_desc->ypbc_flddescs);
  EXPECT_EQ(top2c->child_msg_count, 2);

  auto c = top2c->child_msgs[0];
  EXPECT_TRUE(c->ypbc_flddescs);
  EXPECT_EQ(c->num_fields, 3);
  EXPECT_STREQ(c->ypbc_flddescs[0].yang_node_name, "lfc1");
  EXPECT_STREQ(c->ypbc_flddescs[1].yang_node_name, "lf3");
  EXPECT_STREQ(c->ypbc_flddescs[2].yang_node_name, "cc");
  EXPECT_EQ(c->child_msg_count, 1);

  auto cc = c->child_msgs[0];
  EXPECT_TRUE(cc->ypbc_flddescs);
  EXPECT_EQ(cc->num_fields, 17);

  auto cd = top2c->child_msgs[1];
  EXPECT_TRUE(cd->ypbc_flddescs);
  EXPECT_EQ(cd->num_fields, 1);
  EXPECT_STREQ(cd->ypbc_flddescs[0].yang_node_name, "lf3");
  EXPECT_EQ(cd->child_msg_count, 0);

  auto topl = s_m->data_module->ypbc.child_msgs[1];
  EXPECT_TRUE(topl->ypbc_flddescs);
  EXPECT_EQ(topl->num_fields, 2);
  EXPECT_STREQ(topl->ypbc_flddescs[0].yang_node_name, "k0");
  EXPECT_STREQ(topl->ypbc_flddescs[1].yang_node_name, "la");
  EXPECT_FALSE(topl->schema_list_only_ypbc_desc->ypbc_flddescs);
  EXPECT_EQ(topl->child_msg_count, 1);

  auto la = topl->child_msgs[0];
  EXPECT_TRUE(la->ypbc_flddescs);
  EXPECT_EQ(la->num_fields, 4);
  EXPECT_STREQ(la->ypbc_flddescs[0].yang_node_name, "k1");
  EXPECT_STREQ(la->ypbc_flddescs[1].yang_node_name, "k2");
  EXPECT_STREQ(la->ypbc_flddescs[2].yang_node_name, "k3");
  EXPECT_STREQ(la->ypbc_flddescs[3].yang_node_name, "lb");
  EXPECT_EQ(la->child_msg_count, 1);

  auto lb = la->child_msgs[0];
  EXPECT_TRUE(lb->ypbc_flddescs);
  EXPECT_EQ(lb->num_fields, 2);
  EXPECT_STREQ(lb->ypbc_flddescs[0].yang_node_name, "k4");
  EXPECT_STREQ(lb->ypbc_flddescs[1].yang_node_name, "k5");

  auto rpci_m = s_m->rpci_module;
  EXPECT_FALSE(rpci_m->ypbc.ypbc_flddescs);
  EXPECT_EQ(rpci_m->ypbc.num_fields, 0);

  auto rpco_m = s_m->rpco_module;
  EXPECT_FALSE(rpco_m->ypbc.ypbc_flddescs);
  EXPECT_EQ(rpco_m->ypbc.num_fields, 0);

  auto n_m = s_m->notif_module;
  EXPECT_TRUE(n_m->ypbc.ypbc_flddescs);
  EXPECT_EQ(n_m->ypbc.num_fields, 3);
  EXPECT_STREQ(n_m->ypbc.ypbc_flddescs[0].yang_node_name, "n1");
  EXPECT_STREQ(n_m->ypbc.ypbc_flddescs[1].yang_node_name, "n2");
  EXPECT_STREQ(n_m->ypbc.ypbc_flddescs[2].yang_node_name, "n3");
}

TEST(YangToPb, FieldDescsMP)
{
  TEST_DESCRIPTION("Testcase to test the module pointer gen in field descs");

  auto schema = RWPB_G_SCHEMA_YPBCSD(TestYdomAug);
  auto s_m = schema->schema_module;
  auto at_m = schema->modules[2];

  auto top = at_m->data_module->child_msgs[1];
  EXPECT_EQ(top->num_fields, 5);
  EXPECT_STREQ(top->ypbc_flddescs[4].yang_node_name, "apis_test");
  EXPECT_EQ(top->ypbc_flddescs[4].module, at_m);

  auto api = top->child_msgs[4];
  EXPECT_EQ(api->num_fields, 30);

  EXPECT_STREQ(api->ypbc_flddescs[27].yang_node_name, "aint8");
  EXPECT_EQ(api->ypbc_flddescs[27].stmt_type, RW_YANG_STMT_TYPE_LEAF);
  EXPECT_EQ(api->ypbc_flddescs[27].module, (rw_yang_pb_module_t *)s_m);

  EXPECT_STREQ(api->ypbc_flddescs[28].yang_node_name, "astring");
  EXPECT_EQ(api->ypbc_flddescs[28].stmt_type, RW_YANG_STMT_TYPE_LEAF);
  EXPECT_EQ(api->ypbc_flddescs[28].module, (rw_yang_pb_module_t *)s_m);

  EXPECT_STREQ(api->ypbc_flddescs[29].yang_node_name, "aempty");
  EXPECT_EQ(api->ypbc_flddescs[29].stmt_type, RW_YANG_STMT_TYPE_LEAF);
  EXPECT_EQ(api->ypbc_flddescs[29].module, (rw_yang_pb_module_t *)s_m);

  EXPECT_STREQ(api->ypbc_flddescs[0].yang_node_name, "lint8");
  EXPECT_EQ(api->ypbc_flddescs[0].stmt_type, RW_YANG_STMT_TYPE_LEAF);
  EXPECT_EQ(api->ypbc_flddescs[0].module, at_m);

  EXPECT_STREQ(api->ypbc_flddescs[23].yang_node_name, "primlist");
  EXPECT_EQ(api->ypbc_flddescs[23].stmt_type, RW_YANG_STMT_TYPE_LEAF_LIST);
  EXPECT_EQ(api->ypbc_flddescs[23].module, at_m);

  EXPECT_STREQ(api->ypbc_flddescs[24].yang_node_name, "reallist");
  EXPECT_EQ(api->ypbc_flddescs[24].stmt_type, RW_YANG_STMT_TYPE_LIST);
  EXPECT_EQ(api->ypbc_flddescs[24].module, at_m);
}

static void yangtopb_leafref_int32(int32_t*) {}
static void yangtopb_leafref_enum(TestLeafref__YangEnum__Tenum__E*) {}

TEST(YangToPb, Leafref)
{
  TEST_DESCRIPTION("Leafref static compilation test");

  RWPB_M_MSG_DECL_INIT(TestLeafref_data_Reftop_Llr, llr);

  char rname[] = "rname";
  llr.rname = rname;

  /* proves the field is int32 by passing the field's address to a function taking a pointer */
  yangtopb_leafref_int32(&llr.rnum);

  uint8_t bin[] = { 23, 45, 99, 234 };
  llr.rbin.data = bin;
  llr.rbin.len = sizeof(bin);
  llr.has_rbin = true;

  /* ATTN: bits support incomplete; for now this is string */
  llr.rbts = rname;

  /* proves the field is the enum by passing the field's address to a function taking a pointer */
  yangtopb_leafref_enum(&llr.renu);
}

TEST(YangToPb, MergeBehave)
{
  TEST_DESCRIPTION("Field merge behavior test for lists.");

  RWPB_M_MSG_DECL_INIT(TestFieldMerge_ToyShop, tscont1);
  tscont1.n_inventory = 3;

  // ATTN: Should use RWPB macros!
  // TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory
  tscont1.inventory = (TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory**)
            calloc(tscont1.n_inventory, sizeof(void*));

  for (size_t i = 0; i < tscont1.n_inventory; i++) {
    tscont1.inventory[i] = (TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory*)
               calloc(1, sizeof(TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory));
    RWPB_F_MSG_INIT(TestFieldMerge_data_Shop_Inventory, tscont1.inventory[i]);

    tscont1.inventory[i]->item_name = strdup("Batman"); // All same keyed elements, this should not be merged
    tscont1.inventory[i]->item_id = static_cast<uint32_t>(i);
  }


  tscont1.n_inventory_2 = 3;

  tscont1.inventory_2 = (TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory2**)
             calloc(tscont1.n_inventory, sizeof(void*));

  for (size_t i = 0; i < tscont1.n_inventory_2; i++) {
    tscont1.inventory_2[i] = (TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory2*)
              calloc(1, sizeof(TestFieldMerge__YangData__TestFieldMerge__Shop__Inventory2));
    RWPB_F_MSG_INIT(TestFieldMerge_data_Shop_Inventory2, tscont1.inventory_2[i]);

    tscont1.inventory_2[i]->item_name = strdup("IronMan");
    tscont1.inventory_2[i]->item_id = static_cast<uint32_t>(i); // Different keyed elements
  }

  RWPB_M_MSG_DECL_INIT(TestFieldMerge_data, module);
  module.n_all_shops = 3;
  module.all_shops = (char**)calloc(module.n_all_shops, sizeof(char*));

  module.all_shops[0] = strdup("ComicHouse-1");
  module.all_shops[1] = strdup("ComicHouse-2");
  module.all_shops[2] = strdup("ComicHouse-2"); //Duplicate

  // set the shop
  module.shop = &tscont1;

  uint8_t buff[4096] = {0,}; // Should be more than enough for above data

  auto len1 = protobuf_c_message_get_packed_size(NULL, &module.base);
  protobuf_c_message_pack(NULL, &module.base, buff);

  auto out1 = RWPB_F_MSG_UNPACK(TestFieldMerge_data, NULL, len1, buff);

  EXPECT_TRUE(out1);
  EXPECT_EQ(out1->shop->n_inventory, 3); // No reduction in duplicate elements.
  EXPECT_EQ(out1->shop->n_inventory_2, 3); // There were no duplicates, so count is same.

  RWPB_F_MSG_FREE_AND_BODY(TestFieldMerge_data, out1, NULL);
}

TEST(YangToPb, XmlMetaData)
{
  TEST_DESCRIPTION("Field merge behavior test for lists.");
  const char* s = nullptr;

  auto pe_lvl2 = RWPB_G_PATHENTRY_PBCMD(Testy2pSearchNode1_data_Tysn1T1_Lvl2l);
  s = protobuf_c_message_descriptor_xml_prefix(pe_lvl2);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "tysn1" );

  s = protobuf_c_message_descriptor_xml_ns(pe_lvl2);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "http://riftio.com/ns/core/util/yangtools/tests/testy2p-search-node1" );

  s = protobuf_c_message_descriptor_xml_element_name(pe_lvl2);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "lvl2l" );


  auto msg_lvl3b = RWPB_G_PATHENTRY_PBCMD(Testy2pSearchNode2_Tysn2Tysn1T1Lvl2Alvl3b);
  s = protobuf_c_message_descriptor_xml_prefix(msg_lvl3b);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "tysn2" );

  s = protobuf_c_message_descriptor_xml_ns(msg_lvl3b);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "http://riftio.com/ns/core/util/yangtools/tests/testy2p-search-node2" );

  s = protobuf_c_message_descriptor_xml_element_name(msg_lvl3b);
  ASSERT_NE(nullptr, s);
  EXPECT_STREQ(s, "lvl3b1" );
}

TEST(YangToPb, AugmentNamespace)
{
  TEST_DESCRIPTION ("Test augment namespace validity between YangModel and YPBC");

  auto ypbc_schema = (rw_yang_pb_schema_t*)RWPB_G_SCHEMA_YPBCSD(TestAugmentA1);
  YangModelNcx* ymodel = YangModelNcx::create_model();
  ASSERT_TRUE(ymodel);
  YangModel::ptr_t ym(ymodel);

  rw_status_t rs = ymodel->load_schema_ypbc(ypbc_schema);
  ASSERT_EQ(rs, RW_STATUS_SUCCESS);

  rs = ymodel->register_ypbc_schema(ypbc_schema);
  ASSERT_EQ(rs, RW_STATUS_SUCCESS);
}

TEST(YangToPb, MultiLevelAugment)
{
  TEST_DESCRIPTION ("Test augment validity for augment path containing more than one module");

  auto ypbc_schema1 = (rw_yang_pb_schema_t*)RWPB_G_SCHEMA_YPBCSD(Trafdata);
  EXPECT_EQ(ypbc_schema1->module_count, 4);

  YangModelNcx* ymodel = YangModelNcx::create_model();
  ASSERT_TRUE(ymodel);
  YangModel::ptr_t ym(ymodel);

  rw_status_t rs = ymodel->load_schema_ypbc(ypbc_schema1);
  ASSERT_EQ(rs, RW_STATUS_SUCCESS);

  RWPB_M_MSG_DECL_INIT(Trafdata_PortState, port_state);
  port_state.portno = 4242;

  // Check if module pointer is correct
  auto* module = port_state.base.descriptor->ypbc_mdesc->module;
  EXPECT_EQ(module, reinterpret_cast<const rw_yang_pb_module_t *>(&rw_ypbc_Trafdata_Ifmgr_g_module));

  UNUSED(module);
}
