/*
 * 
 *   Copyright 2016 RIFT.IO Inc
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 * Author(s): Anil Gunturu
 * Creation Date: 07/05/2014
 * 
 */

#include "async_cb-c.h"
#include <pthread.h>

static void *
handle_async_request(void *context)
{
  AsyncCbAsyncFunctorInstance *functor = (AsyncCbAsyncFunctorInstance *)context;
  fprintf(stdout, "handle_async_request\n");

  /* Do some work here */
  functor->int_variable = 0xdeadbeef;
  functor->string_variable = "0xbadbeef";
  gchar *array[] = { "0xdeadbeef", "0xbadbeef" };
  async_cb_async_functor_instance_set_string_array(functor, array, 2);

  /* Now dispatch the functor */
  async_cb_functor_dispatch((AsyncCbFunctor *)functor);
  return NULL;
}

static rw_status_t
async_cb__api__async_request(AsyncCbApi* self, 
                             AsyncCbAsyncFunctorInstance* functor)
{
  /* Create a pthread, to simulate the asynchronous response.
   * The dispatch of the event occurrs through thread */
  pthread_t thread;
  if (pthread_create(&thread, NULL, handle_async_request, functor) != 0) {
    fprintf(stderr, "Error creating thread\n");
  }

  return RW_STATUS_SUCCESS;
}

static void
async_cb__functor__dispatch(AsyncCbFunctor *self)
{
}

static void
async_cb__functor__invoke_callback(AsyncCbFunctor *self)
{
}

static void
async_cb_c_extension_init(AsyncCbCExtension *plugin)
{
  // This is called once for each extension created
  printf("async_cb_c_extension_init() %p called\n",plugin);
}

static void
async_cb_c_extension_class_init(AsyncCbCExtensionClass *klass)
{
  printf("async_cb_c_extension_class_init() %p called\n",klass);
}


static void
async_cb_c_extension_class_finalize(AsyncCbCExtensionClass *klass)
{
  printf("async_cb_c_extension_class_finalize() %p called\n", klass);
}

#define VAPI_TO_C_AUTOGEN
#ifdef VAPI_TO_C_AUTOGEN
/* Don't modify the code below, it is autogenerated */

#endif //VAPI_TO_C_AUTOGEN
