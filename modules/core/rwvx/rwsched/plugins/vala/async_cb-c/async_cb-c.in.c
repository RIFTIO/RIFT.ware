/*
 * 
 * (c) Copyright RIFT.io, 2013-2016, All Rights Reserved
 *
 * Author(s): Anil Gunturu
 * Creation Date: 07/05/2014
 * 
 */

#include "async_cb-c.h"
#include <pthread.h>

static void *
handle_async_request(void *context)
{
  AsyncCbAsyncFunctorInstance *functor = (AsyncCbAsyncFunctorInstance *)context;
  fprintf(stdout, "handle_async_request\n");

  /* Do some work here */
  functor->int_variable = 0xdeadbeef;
  functor->string_variable = "0xbadbeef";
  gchar *array[] = { "0xdeadbeef", "0xbadbeef" };
  async_cb_async_functor_instance_set_string_array(functor, array, 2);

  /* Now dispatch the functor */
  async_cb_functor_dispatch((AsyncCbFunctor *)functor);
  return NULL;
}

static rw_status_t
async_cb__api__async_request(AsyncCbApi* self, 
                             AsyncCbAsyncFunctorInstance* functor)
{
  /* Create a pthread, to simulate the asynchronous response.
   * The dispatch of the event occurrs through thread */
  pthread_t thread;
  if (pthread_create(&thread, NULL, handle_async_request, functor) != 0) {
    fprintf(stderr, "Error creating thread\n");
  }

  return RW_STATUS_SUCCESS;
}

static void
async_cb__functor__dispatch(AsyncCbFunctor *self)
{
}

static void
async_cb__functor__invoke_callback(AsyncCbFunctor *self)
{
}

static void
async_cb_c_extension_init(AsyncCbCExtension *plugin)
{
  // This is called once for each extension created
  printf("async_cb_c_extension_init() %p called\n",plugin);
}

static void
async_cb_c_extension_class_init(AsyncCbCExtensionClass *klass)
{
  printf("async_cb_c_extension_class_init() %p called\n",klass);
}


static void
async_cb_c_extension_class_finalize(AsyncCbCExtensionClass *klass)
{
  printf("async_cb_c_extension_class_finalize() %p called\n", klass);
}

#define VAPI_TO_C_AUTOGEN
#ifdef VAPI_TO_C_AUTOGEN
/* Don't modify the code below, it is autogenerated */

#endif //VAPI_TO_C_AUTOGEN
