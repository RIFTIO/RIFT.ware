"""
#
# 
#   Copyright 2016 RIFT.IO Inc
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# @file transforms.py
# @author Joshua Downer (joshua.downer@riftio.com)
# @date 03/25/2015
#

The classes in this file are used by the LegacyManifestCompiler to modify either
a SystemInfo or RaManifest object during compilation. The SystemTransform
classes are applied to a SystemInfo object before it is used to create an
instance of RaManifest. The ManifestTransform classes are applied to the
manifest (potentially using info in the SystemInfo object) following
compilation.

"""

import abc
import collections
import logging
import random
import rift.vcs

from . import exc

import gi


logger = logging.getLogger(__name__)


class SystemTransform(object):
    """
    A SystemTransform object is used by the LegacymanifestCompiler to modify a
    SystemIfno object immediately prior to compilation.
    """

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def __call__(self, sysinfo):
        raise NotImplemented()


class ManifestTransform(object):
    """
    A ManifestTransform object is used by the LegacyManifestCompiler to modify
    the RaManifest object generated by the compilation step before returning it
    to the caller.
    """

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def __call__(self, manifest, sysinfo):
        raise NotImplemented()


class WebServersConfdHost(SystemTransform):
    def __call__(self, sysinfo):
        """Ensure that each webserver has a URL for confd

        Arguments:
            sysinfo - a SystemInfo object

        """
        webservers = sysinfo.list_by_class(rift.vcs.Webserver)
        if webservers:
            confd_proc = sysinfo.find_by_class(rift.vcs.uAgentTasklet)
            confd_vm = sysinfo.parent(confd_proc)
            confd_host = "localhost" if confd_vm.ip is None else confd_vm.ip

            for webserver in webservers:
                webserver.confd_host = confd_host


class AssignFastpathIds(SystemTransform):
    def __call__(self, sysinfo):
        """Assign an ID to each fastpath tasklet

        Each fastpath tasklet is not strictly required to have an ID, but each
        application manager tasklet needs to know the ID of its sibling
        fastpath tasklet. To simplify the implementation of this requirement,
        all fastpath tasklets are assigned an ID.

        Arguments:
            sysinfo - a SystemInfo object

        """
        # Create a set of the known component IDs
        known = set()
        for component in sysinfo:
            if component.uid is not None:
                known.add(component.uid)

        # Iterate through the fastpath tasklets and assign each one a unique
        # ID.
        current = 1
        for tasklet in sysinfo.list_by_class(rift.vcs.Fastpath):
            if tasklet.uid is not None:
                continue

            while current in known:
                current += 1

            tasklet.uid = current
            known.add(current)


class AssignClusterIds(SystemTransform):
    def __call__(self, sysinfo):
        """Assign an ID to each cluster

        All fastpath-related tasklets need to know the ID of the cluster that
        contains them. This information should be obtained from DTS but in the
        short-term is provided via the manifest.

        Arguments:
            sysinfo - a SystemInfo object

        """
        # Create a set of the known component IDs
        known = set()
        for component in sysinfo:
            if component.uid is not None:
                known.add(component.uid)

        # Iterate through the clusters and assign each one a unique ID.
        current = 1
        for component in sysinfo.list_by_class(rift.vcs.Cluster):
            if component.uid is not None:
                continue

            while current in known:
                current += 1

            component.uid = current
            known.add(current)


class AssignVirtualMachineIds(SystemTransform):
    def __call__(self, sysinfo):
        """Assign an ID to each VirtualMachine

        VDU needs to have a reference to a VM instance id in order for
        UI to aggregate stats.  This needs to be done during manifest
        generation time so automation is able to fill in instance id.

        Arguments:
            sysinfo - a SystemInfo object

        """
        # Create a set of the known component IDs
        known = set()
        for component in sysinfo:
            if component.uid is not None:
                known.add(component.uid)

        # Iterate through the virtual machine and assign each one a unique ID.
        current = 1
        for component in sysinfo.list_by_class(rift.vcs.VirtualMachine):
            if component.uid is not None:
                continue

            while current in known:
                current += 1

            component.uid = current
            known.add(current)


class AssignFastpathInducedUniqueNames(SystemTransform):
    def __call__(self, sysinfo):
        """Assign a unique component name to ancestors of fastpath tasklets

        Each component that contains a uniquely identified component is itself
        unique. That is, the uniqueness of a component induces uniqueness of
        the component that contains it. Each distinct component must have a
        unique name.

        Each fastpath and application manager tasklet is unique. This means
        that any component that is an ancestor of a fastpath or application
        manager tasklet is unique and therefore requires a unique component
        name.

        Arguments:
            sysinfo - a SystemInfo object

        """
        # This dictionary will map a child component to its parent.
        parent = {}

        # The traversal function will recursively traverse the tree and
        # construct the parent dict.
        def traversal(root):
            try:
                for component in root.subcomponents:
                    parent[component] = root
                    traversal(component)

            except AttributeError:
                pass

        # Iterate over all of the components in the system and construct the
        # complete mapping of children to parents.
        for component in sysinfo.subcomponents:
            parent[component] = None
            traversal(component)

        # Count how many times each component name is used in the system
        count = collections.Counter(c.name for c in sysinfo)

        # Determine the ancestors of the fastpath tasklets
        marked = set()
        for tasklet in sysinfo.list_by_class(rift.vcs.Fastpath):
            current = tasklet
            while current is not None:
                marked.add(current)
                current = parent[current]

        def unique_name(base):
            while True:
                name = '{}~{:0<5}'.format(base, int(random.getrandbits(16)))
                if name not in count:
                    return name

        # Ensure that each fastpath tasklet and its ancestors has a unique
        # component name.
        for component in marked:
            if count[component.name] > 1:
                msg = 'required name change: {} -> {}'
                name = unique_name(component.name)
                logger.debug(msg.format(component.name, name))

                # Increment the count of the new name
                component.name = name
                count[component.name] += 1


class AssignWebServersUAgentPort(SystemTransform):
    def __call__(self, sysinfo):
        """Sets the uagent port for each webserver

        Arguments:
            sysinfo - a SystemInfo object

        """
        webservers = sysinfo.list_by_class(rift.vcs.Webserver)
        if webservers:
            uagent = sysinfo.find_by_class(rift.vcs.uAgentTasklet)
            if uagent is None:
                raise exc.TransformError('unable to find uagent')

            for webserver in webservers:
                webserver.uagent_port = uagent.port


class GenerateCollectionInstanceIDs(SystemTransform):
    def __call__(self, sysinfo):
        """Ensure that every collection has an ID

        The fastpath tasklet needs to know the ID of the colony and cluster
        that it belongs. To ensure that it can get this information, we assign
        an ID to every collection that does not already have an ID.

        Arguments:
            sysinfo - a SystemInfo object

        """
        # Create a set of all the UIDs that have been assigned to components in
        # the system.
        assigned = set()
        for component in sysinfo:
            if component.uid is not None:
                assigned.add(component.uid)

        # Ensure that each collection in the system has a UID.
        next_id = 1
        for collection in sysinfo.list_by_class(rift.vcs.Collection):
            if collection.uid is None:
                while next_id in assigned:
                    next_id += 1

                collection.uid = next_id
                assigned.add(next_id)


class AssignWebserversConfdHost(SystemTransform):
    def __call__(self, sysinfo):
        """Ensure webservers have Confd host

        If there are any webservers in the system, they must known which
        virtual machine the confd process is running on.

        Arguments:
            sysinfo - a SystemInfo object

        Raises:
            A TransformError is raised if (1) the confd process cannot be
            found, or (2) the confd process is not contained in a VM.

        """
        webservers = sysinfo.list_by_class(rift.vcs.Webserver)
        if webservers:
            components = rift.vcs.core.component_iterator(sysinfo)

            # Iterate over the system info components until an instance of
            # Confd is found.
            for component in components:
                if isinstance(component, rift.vcs.uAgentTasklet):
                    break
            else:
                raise exc.TransformError('missing confd process')

            # Continuing iterating of the components to find the virtual
            # machine that contains the confd component.
            for component in components:
                if isinstance(component, rift.vcs.VirtualMachine):
                    host = component.ip
                    break
            else:
                raise exc.TransformError('confd is not in a VM')

            # Iterate over all of the webservers and assign their confd host.
            for webserver in webservers:
                webserver.confd_host = host


class StartupColony(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Ensure a colony is the first startup

        Arguments:
            manifest - an RaManifest object
            sysinfo  - a SystemInfo object

        """
        # Set the startup colony
        colony = manifest.components[0]
        manifest.init.add_startup(colony)

        # Move 'Start the rwcolony' action to the beginning
        # of the event list. Fpath applications are now using
        # VCS to retrieve colony id, instead of getting it from
        # manifest, and require that rwcolony to be started first.
        startups = manifest.init.startups
        startups.insert(0, startups.pop())


class AssignBrokerVM(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Assigns the VM containing the message broker to the manifest

        This function traverses the components in the manifest until the message
        broker tasklet is found. The components are traversed in a depth-first
        fashion, so after the message broker is found the next virtual machine
        encountered will be the VM that contains the message broker.

        Arguments:
            manifest - an RaManifest object.

        Raises:
            A CompilationError is raised if a message broker tasklet cannot be
            found or if the message broker is not contained within a VM.

        """
        if not sysinfo.multi_broker:
            # Create a generator of components
            components = (component
                        for colony in manifest.components
                        for component in rift.vcs.core.component_iterator(colony))

            # Iterate through the components until the message broker
            for component in components:
                if isinstance(component, rift.vcs.manifest.RaBroker):
                    break
            else:
                raise exc.CompilationError('Unable to find the message broker')

            # Continue iterating through the components from where we left off.
            # Component iteration is a depth-first traversal of the hierarchy,
            # therefore the next virtual machine we enounter will contain the
            # message broker tasklet (this assumes that tasklets are always
            # descendents of VMs and VMs can never be descendents of tasklets).
            for component in components:
                if isinstance(component, rift.vcs.manifest.RaVm):
                    manifest.broker_vm = component
                    break
            else:
                raise exc.CompilationError('The message broker is not contained in a VM')


class AssignDtsRouterVM(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Assigns the VM containing the dtsrouter to the manifest

        This function traverses the components in the manifest until the 
        dtsrouter tasklet is found. The components are traversed in a depth-first
        fashion, so after the dtsrouter is found the next virtual machine
        encountered will be the VM that contains the dtsrouter.

        Arguments:
            manifest - an RaManifest object.

        Raises:
            A CompilationError is raised if a dtsrouter tasklet cannot be
            found or if the dtsrouter is not contained within a VM.

        """
        if not manifest.multi_dtsrouter:
            # Create a generator of components
            components = (component
                        for colony in manifest.components
                        for component in rift.vcs.core.component_iterator(colony))

            # Iterate through the components until the dtsrouter
            for component in components:
                if isinstance(component, rift.vcs.manifest.RaDtsRouter):
                    break
            else:
                raise exc.CompilationError('Unable to find the dtsrouter')

            # Continue iterating through the components from where we left off.
            # Component iteration is a depth-first traversal of the hierarchy,
            # therefore the next virtual machine we enounter will contain the
            # dtsrouter tasklet (this assumes that tasklets are always
            # descendents of VMs and VMs can never be descendents of tasklets).
            for component in components:
                if isinstance(component, rift.vcs.manifest.RaVm):
                    manifest.dtsrouter_vm = component
                    break
            else:
                raise exc.CompilationError('The dtsrouter is not contained in a VM')


class AssignInitVM(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Assigns the initial VM to the manifest

        The initial VM is the VM that is going to start everything. In effect,
        this going to be the VM that contains the CLI tasklet.

        Arguments:
            manifest - an RaManifest object.

        Raises:
            A CompilationError is raised if there are no virtual machines in the
            manifest or we cannot find the CLI tasklet.

        """
        # Create a generator of components
        a_components = (component
                    for colony in manifest.components
                    for component in rift.vcs.core.component_iterator(colony))

        # Iterate through the components until the active uAgent is found
        for a_component in a_components:
            if isinstance(a_component, rift.vcs.manifest.RaUagent) and a_component.mode_active:
                break
        else:
            raise exc.CompilationError('Unable to find the Active uAgent tasklet')

        # Continue iterating through the components from where we left off.
        # Component iteration is a depth-first traversal of the hierarchy,
        # therefore the next virtual machine we enounter will contain the 
        # tasklet (this assumes that tasklets are always descendents of VMs and
        # VMs can never be descendents of tasklets).
        for a_component in a_components:
            if isinstance(a_component, rift.vcs.manifest.RaVm):
                manifest.init = a_component
                manifest.a_vm = a_component
                break
        else:
            raise exc.CompilationError('Active uAgent tasklet is not in a virtual machine')

        parent_components = (rift.vcs.manifest.RaColony, rift.vcs.manifest.RaCluster, rift.vcs.manifest.RaCollection)
        cluster_parent = None
        colony_parent = None
        collection_parent = None
        for x_parent in a_components:
            if type(x_parent) in parent_components:
                if cluster_parent is None and (type(x_parent) == rift.vcs.manifest.RaCluster):
                    cluster_parent = x_parent
                if colony_parent is None and (type(x_parent) == rift.vcs.manifest.RaColony):
                    colony_parent = x_parent
                if collection_parent is None and (type(x_parent) == rift.vcs.manifest.RaCollection):
                    collection_parent = x_parent
        if colony_parent is not None:
            a_parent = colony_parent
        elif cluster_parent is not None:
            a_parent = cluster_parent
        elif collection_parent is not None:
            a_parent = collection_parent
        else:
            raise exc.CompilationError('Active uAgent tasklet virtual machine not in any collection')

        current_id = 0
        # The init phase needs to refer to the instance ID of the init VM, so
        # we need to make sure that the selected VM has been assigned an
        # instance ID.
        if manifest.init.instance_id is None:
            known = set()
            for component in manifest:
                if component.instance_id is not None:
                    known.add(component.instance_id)

            current_id = 1
            while current_id in known:
                current_id += 1

            manifest.init.instance_id = current_id
            manifest.a_vm.instance_id = current_id

        if not a_parent.instance_id:
            known = set()
            for component in manifest:
                if component.instance_id is not None:
                    known.add(component.instance_id)
 
            current_id = 1
            while current_id in known:
                current_id += 1
            a_parent.instance_id = current_id
 
        parent_id = a_parent.instance_id
        manifest.a_vm.parent = '{}-{}'.format(a_parent.name, parent_id)

        manifest.s_vm = None
        if len(manifest.mgmt_ip_list) > 1:
            s_components = (component
                    for colony in manifest.components
                    for component in rift.vcs.core.component_iterator(colony))
            # Iterate through the components until the active uAgent is found
            for s_component in s_components:
                if isinstance(s_component, rift.vcs.manifest.RaUagent) and not s_component.mode_active:
                    break
            else:
                raise exc.CompilationError('Unable to find the Standby uAgent tasklet')
    
            # Find the VM
            for s_component in s_components:
                if isinstance(s_component, rift.vcs.manifest.RaVm):
                    manifest.s_vm = s_component
                    break
            else:
                raise exc.CompilationError('Standby uAgent tasklet is not in a virtual machine')
    
            # Find the Cluster
            for s_parent in s_components:
                if isinstance(s_parent, parent_components):
                    break
            else:
                raise exc.CompilationError('Standby uAgent tasklet virtual machine not in any collection')
            if s_parent.name != a_parent.name:
                raise exc.CompilationError('uagent active tasklet virtual machine "{}"'
                     ' not in same collection as standby "{}"'.format(a_parent.name, s_parent.name))

            manifest.s_vm.parent = '{}-{}'.format(s_parent.name, parent_id)

class AssignIPAddresses(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Assign IPs to the manifest

        Iterates over all of the virtual machines in the system and creates a
        list that is added to the manifest.

        Arguments:
            manifest - an RaManifest object
            sysinfo  - a SystemInfo object

        """
        addrs = [vm.ip for vm in sysinfo.list_by_class(rift.vcs.VirtualMachine)]
        manifest.ipaddresses = addrs
        manifest.mgmt_ip_list = sysinfo.mgmt_ip_list
        if manifest.mgmt_ip_list:
            manifest.mgmt_ip_list.sort()
        elif sysinfo and sysinfo.zookeeper:
            manifest.mgmt_ip_list = [sysinfo.zookeeper.master_ip]


class SetManifestFlags(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Set a group of flags on the manifest

        Arguments:
            manifest - an RaManifest object
            sysinfo  - a SystemInfo object

        """
        manifest.multi_broker = sysinfo.multi_broker
        manifest.multi_dtsrouter = sysinfo.multi_dtsrouter
        manifest.dtsperfmgr = sysinfo.dtsperfmgr
        manifest.zookeeper = sysinfo.zookeeper
        manifest.collapse_proc = sysinfo.collapsed
        manifest.collapse_vm = sysinfo.collapsed
        manifest.registerUagent = True
        manifest.use_pool = False


class EnforceMessageBrokerPolicy(SystemTransform):
    def __call__(self, sysinfo):
        """Add/Remove Message Brokers depending on mode

        In multi-broker mode, add a local message broker to each RWVM that does
        not already have one.

        Arguments:
            sysinfo  - a SystemInfo object

        """
        if sysinfo.multi_broker:
            # Remove all brokers, the only broker listed should be the one made here.
            brokers = sysinfo.list_by_class(rift.vcs.tasklets.MsgBrokerTasklet)
            for broker in brokers:
                msg ='removing {} from manifest (duplicates in multi-broker mode)'
                logger.warning(msg.format(broker.name))
                sysinfo.remove(broker)

            # Insert our broker into the inventory
            broker = rift.vcs.tasklets.MsgBrokerTasklet(name='msgbroker')

            # Append broker to VM bootstrap
            sysinfo.vm_bootstrap.append(broker)

            # Remove any empty processes left over
            procs = sysinfo.list_by_class(rift.vcs.core.Proc)
            for proc in procs:
                if len(proc.subcomponents) == 0:
                    sysinfo.remove(proc)


class EnforceDtsRouterPolicy(SystemTransform):
    def __call__(self, sysinfo):
        """Add/Remove DTSRouter depending on mode

        In multi-dtsrouter mode, add a local dtsrouter to each RWVM that does
        not already have one.

        Arguments:
            sysinfo  - a SystemInfo object

        """
        if sysinfo.multi_dtsrouter:
            # Remove all dtsrouters, the only dtsrouter listed should be the one made here.
            dtsrouters = sysinfo.list_by_class(rift.vcs.tasklets.DtsRouterTasklet)
            for dtsrouter in dtsrouters:
                msg ='removing {} from manifest (duplicates in multi-dtsrouter mode)'
                logger.warning(msg.format(dtsrouter.name))
                sysinfo.remove(dtsrouter)

            # Insert our dtsrouter into the inventory
            dtsrouter = rift.vcs.tasklets.DtsRouterTasklet(name='dtsrouter')

            # Append dtsrouter to VM bootstrap
            sysinfo.vm_bootstrap.append(dtsrouter)

            # Remove any empty processes left over
            procs = sysinfo.list_by_class(rift.vcs.core.Proc)
            for proc in procs:
                if len(proc.subcomponents) == 0:
                    sysinfo.remove(proc)

class EnforceDtsPerfMgrPolicy(SystemTransform):
    def __call__(self, sysinfo):
        """Add/Remove DTSPerfMgr depending on mode

        In dtsperfmgr mode, add a dtsperfmgr instance to the first RWVM

        Arguments:
            sysinfo  - a SystemInfo object
        """
        if sysinfo.dtsperfmgr:
            # Remove all dtsperfmgrs, the only dtsperfmgr listed should be the one made here.
            dtsperfmgrs = sysinfo.list_by_class(rift.vcs.tasklets.DtsPerfMgrTasklet)
            for dtsperfmgr in dtsperfmgrs:
                logger.warning('removing {} from manifest (with-dts-perf)'.format(dtsperfmgr.name))
                sysinfo.remove(dtsperfmgr)

            # Insert our dtsperfmgr into the inventory
            dtsperfmgr = rift.vcs.tasklets.DtsPerfMgrTasklet(name='dtsperfmgr')

            vm = sysinfo.find_by_class(rift.vcs.core.VirtualMachine)
            vm.add_tasklet(dtsperfmgr)


class AddLogd(SystemTransform):
    def __call__(self, sysinfo):
        """Add Logd instances depending on mode.

        Each physical machine needs to have exactly one Logd instance.

        Arguments:
            sysinfo   - a SystemInfo object
        """
        logds = sysinfo.list_by_class(rift.vcs.tasklets.LogdTasklet)
        for logd in logds:
            msg = 'removing {} from sysinfo'
            logger.warning(msg.format(logd.name))
            sysinfo.remove(logd)

        logd = rift.vcs.tasklets.LogdTasklet(name='logd')
        if sysinfo.collapsed:
            # Pick a VM, any VM
            vm = sysinfo.find_by_class(rift.vcs.core.VirtualMachine)
            vm.add_tasklet(logd)
        else:
            sysinfo.vm_bootstrap.append(logd)


class UseMockCli(SystemTransform):
    def __call__(self, sysinfo):
        """ Change the Rift CLI into a sleep command

        Arguments:
            sysinfo  - a SystemInfo object
        """
        if sysinfo.mock_cli:
            logger.info("Using Mock CLI.  Replacing rift CLI with sleep")
            rift.vcs.RiftCli.exe = "/bin/sleep"
            rift.vcs.RiftCli.args = "1000000"


class AddValgrind(ManifestTransform):
    def __call__(self, manifest, sysinfo):
        """Add valgrind as wrapping process for components provided on command line

        Arguments:
            manifest - an RaManifest object
            sysinfo - a SystemInfo object
        """
        if sysinfo.valgrind is None:
            return

        # Create a generator of components from the manifest
        components = (component
                    for colony in manifest.components
                    for component in rift.vcs.core.component_iterator(colony))

        # Iterate through the components and enable valgrind on matching ones
        for component in components:
            if component.name in sysinfo.valgrind:
                component.valgrind = True


class AssignNetconfHostToRiftCli(SystemTransform):
    def __call__(self, sysinfo):
        """Ensure that RiftCli connects to the right Netconf server IP address.

        Arguments:
            sysinfo - a SystemInfo object

        """
        cli_proc = sysinfo.find_by_class(rift.vcs.RiftCli)
        if cli_proc is None:
            return

        #use localhost always
        cli_proc.netconf_host = "127.0.0.1"

        if sysinfo.agent_mode == "RWXML":
            cli_proc.use_netconf = False
       
# vim: sw=4 et
