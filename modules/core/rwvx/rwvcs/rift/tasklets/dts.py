
# STANDARD_RIFT_IO_COPYRIGHT

import abc
import asyncio
import collections
import contextlib
import functools
import importlib
import itertools
import logging
import sys
import traceback

import gi
gi.require_version('RwDts', '1.0')
gi.require_version('RwTypes', '1.0')

import gi.repository.ProtobufC
import gi.repository.RwDts as rwdts
import gi.repository.RwTypes as rwtypes
from gi.repository import RwKeyspec

import rift.tasklets
import rwlogger

from rift.rwpb.pathwalker import (
    KeyBuilder,
)

if sys.version_info < (3, 4, 4):
    asyncio.ensure_future = asyncio.async

logger = logging.getLogger()

class DtsError(Exception):
    pass

class RegistrationError(Exception):
    def __init__(self, xpath, status=0):
        super(RegistrationError, self).__init__(
                'Failed to register xpath %s, status %d' % (xpath, status))


class ResponseError(Exception):
    pass


class RegistrationElementError(Exception):
    pass


class TransactionException(Exception):
    """
    Base level transaction exception:
    1. Sets the most probable error as the default exception message.
    2. Also provides a API similar to query_error C API, which yields all the
        errors.
    """
    def __init__(self, xact):
        """
        @param xact - Transaction Instance
        """
        self.xact = xact
        error_cause, msg = self.xact.get_error_heuristic()
        super().__init__(msg)

    def query_error(self):
        """
        @return Iterator which is generated by Transaction's query_error
        """
        return self.xact.query_error()


class TransactionFailed(TransactionException):
    """
    Raised when a transaction fails.
    """
    pass


class TransactionAborted(TransactionException):
    """
    Raised when a transaction is aborted.
    """
    pass

class BlockExecuteError(Exception):
    """
    Raised when execution of a Query Block fails
    """
    pass

def pbcm_to_gi(pbcm):
    """
    Convert a ProtobufC.Message to the appropriate GI object

    @param pbcm - pbcm to convert
    @return     - GI object matching pbcm definition
    @raises     - ImportError on bad typename
                  ValueError if get_gi_typename() gives a bad path
    """
    path_array = pbcm.get_gi_typename().split('.')
    if len(path_array) < 2:
        raise ValueError('pbcm typename does not have a namespace and type: %s' % (
            pbcm.get_gi_typename(),))

    ns = '.'.join(path_array[:-1])
    typename = path_array[-1]

    mod = importlib.import_module('gi.repository.%s' % (ns,))
    gi_type = getattr(mod, typename)
    msg = gi_type.from_pbcm(pbcm)
    return msg


class QueryResult(object):
    def __init__(self, handle):
        """
        Create a query result object from a raw DTS QueryResult handle.

        @param handle - RwDts.QueryResult handle
        """
        self._handle = handle
        self._result = pbcm_to_gi(handle.get_protobuf()) if handle.get_protobuf() is not None else None

    def __str__(self):
        return str({
            'result': self.result.as_dict(),
            'xpath': self.xpath,
        })

    @property
    def result(self):
        """
        A GI PBCM representing the a single result of the query
        """
        return self._result

    @property
    def xml(self):
        """
        The query result as represented by xml
        """
        return self._handle.get_xml()

    @property
    def keyspec(self):
        """
        The keyspec assoicated with the result, RwKeyspec.Path
        """
        return self._handle.get_keyspec()

    @property
    def xpath(self):
        """
        The xpath associated with the result
        """
        return self._handle.get_xpath()


class AbstractResultIterator(object, metaclass=abc.ABCMeta):
    """
    Defines the basic protocol for every Result Iterator. Every
    ResultIterator should act as an Iterator (obviously) and also must be a
    callable, for callbacks

    """
    def __init__(self, loop):
        """
        The Iterator consist of a Queue into which the results, wrapped into
        futures, gets added.

        @param loop - asyncio loop being used
        """
        self._loop = loop
        self._futures = collections.deque([asyncio.Future(loop=loop)])
        self._got_first_callback = asyncio.Event(loop=loop)
        self._no_responses = asyncio.Event(loop=loop)

    @property
    def ready(self):
        """
        Event which will be set when the iterator has been seeded.
        Callers should first 'yield from qri.ready' prior to attempting to
        iterate over the responses.  Failure to do so will cause the
        first call to iter() to raise a ValueError
        """
        return self._got_first_callback.wait()

    def __iter__(self):
        if not self._got_first_callback.is_set():
            raise ValueError('ResultIterator has not yet recieved the first response')

        def generator():
            if self._no_responses.is_set():
                return

            f = self._futures[0]

            yield f
            self._futures.popleft()

            while self._futures:
                yield self._futures[0]
                self._futures.popleft()
        return generator()

    @abc.abstractmethod
    def __call__(self):
        """
        Callback function that gets triggered when there is some result
        available for the Transaction.
        """
        pass

    @abc.abstractmethod
    def _get_result(self, xact_or_block):
        """
        This method takes care of getting the result out of the xact/block.

        @param xact_or_block - Instance of Transaction/TransactionBlock
        """
        pass

    @abc.abstractmethod
    def is_xact_complete(self, xact_status):
        """
        Hook for subclasses to indicate the end of xact.

        Args:
            xact_status (TransactionStatus): Pythonic wrapper of xact_status

        Returns:
            bool: Indicates if the xact is done.
        """
        pass

    def set_future(self, future, result, exception=False):
        """
        Marks the future completed based on the exception flag. This routine
        provides the default behaviour for the iterator

        1\ On success (exception=True), marks the Future as completed with
           result
        2\ On failure (exception=False), marks the Future as completed with
           exception

        @param future    - Instance of asyncio.Future, which is present in the
                results queue
        @param result    -  QueryResult or exception(TransactionAborted)
        @param exception -  (Bool) defaults to False.
        """
        func = None
        if exception:
            func = getattr(future, "set_exception")
        else:
            func = getattr(future, "set_result")

        self._loop.call_soon_threadsafe(func, result)


class QueryResultIterator(AbstractResultIterator):
    """
    Create an iterator from DTS Query callback responses.  The
    QueryResultIterator implements around a stateful callback that can be
    passed to any DTS query.  It will then be in an unready state (as
    reflected by the ready property) until the first response from DTS is
    received.  Once this has occurred, the QueryResultIterator can be used
    to iterate over responses as they come in.

    For example:
        qri = QueryResultIterator(myloop, myblock)
        dts.query(..., callback=qri, ...)
        yield from qri.ready

        for i in qri:
            result = yield from i

    """
    def __init__(self, loop):
        super().__init__(loop)
        self._got_some_result = False

    def _get_result(self, xact):
        """
        @param xact - instance of Transaction
        """
        return xact.query_result()

    def is_xact_complete(self, xact_status):
        """The status of the iterator is determined by the xact_status flag
        """
        return xact_status.is_done()

    def __call__(self, xact, xact_status_in, __):
        """
        So, this is fun.  We have five states we want to handle here.

        - Query went out, no one responded with an ACK.  In this case
        we want to allow the generator in __iter__ to exit early so
        that callers don't have to test for empty responses.  This is
        handled by the self._no_responses Event.

        - Query went out, only response was a failure or abort.  Unlike
        the previous case, we need to have the generator return a future
        with the appropriate exception set.  This is handled in the
        final check for responses_done and status in terminal_states.

        - Query went out, got at least one good response.  The generator
        should loop through all futures, each of which contains one
        query_result.

        - Query went out, got at least one response but the transaction
        was either aborted or failed.  In this case we the generator to
        return futures for each of the valid responses that were returned
        but to also mark the last future with an exception reflecting
        the error.

        -Query went out, we got multiple empty responses before the xact moves
        to a final state. This happens when using the iterator with
        transactions. This scenario is handled by using the _got_some_result
        flag

        """
        xact_status = TransactionStatus(xact_status_in)
        xact = Transaction(xact, loop=self._loop)

        result = self._get_result(xact)

        is_xact_complete = self.is_xact_complete(xact_status)
        logger.debug("{}: xact_done: {} - rsp_done: {} - got result: {}".format(
                self.__class__.__name__,
                xact_status.is_done(),
                xact_status.is_responses_done(),
                result))

        # Check if the query succeeded but had no responses.
        if (result is None
                and is_xact_complete
                and not xact_status.is_failed()
                and not self._got_first_callback.is_set()):
            self._loop.call_soon_threadsafe(self._no_responses.set)
            self._loop.call_soon_threadsafe(self._got_first_callback.set)
            return

        for future in self._futures:
            if not future.done():
                break
        else:
            raise RuntimeError('Expected pending future not found')

        # There may be multiple results in the response, so loop through
        # and add a future for each.
        while result is not None:
            self.set_future(future, QueryResult(result))
            self._got_some_result = True

            result = self._get_result(xact)

            # Create a new Future for the Exception, otherwise exit the loop
            if result is None:
                # If the transaction failed, we need to inject an extra future
                # now, which will be filled out with the transaction error
                # outside of this loop.  That is done outside of the loop
                # so that if there were no results in this callback, the
                # future will still be appended and have the exception set
                if is_xact_complete and xact_status.is_failed():
                    self._futures.append(asyncio.Future(loop=self._loop))
                break

            future = asyncio.Future(loop=self._loop)
            self._futures.append(future)

        if not self._got_first_callback.is_set() and self._got_some_result:
            self._loop.call_soon_threadsafe(self._got_first_callback.set)

        if not is_xact_complete and self._got_some_result:
            # More responses might come, so add an additional Future
            self._futures.append(asyncio.Future(loop=self._loop))
        elif xact_status.is_failed():
            exception = xact_status.get_exception(xact)
            logger.debug("Xact failed with {}".format(
                    exception.__class__.__name__))
            # Transaction is Done and has failed, set the exception
            self.set_future(self._futures[-1], exception,
                    exception=True)
            self._loop.call_soon_threadsafe(self._got_first_callback.set)


class SubQueryResultIterator(QueryResultIterator):
    """
    SubQueryResultIterator(SQRI):

    SQRI is associated with a correlation-id (corrid).
    """
    def __init__(self, block, corrid, loop):
        """
        @param corrid - correlation-id of the subquery in the transaction
                block
        """
        super().__init__(loop)
        self._block = block
        self._corrid = corrid

    def _get_result(self, _):
        """
        Gets the result (if available) for the corrid.
        Instead of getting results from Transaction, we do a corrid based lookup
        on the block instance

        """
        return self._block.query_result(self._corrid)

    def is_xact_complete(self, xact_status):
        return xact_status.is_responses_done()


class BlockResultIterator(AbstractResultIterator):
    """
    BlockResultIterator(BRI)

    BRI is specifically designed for working with TransactionBlock. The BRI
    consumes a TransactionBlock instance and creates
    SubQueryResultIterator(SQRI) for each subquery.

    This provides us with the flexibility of querying based on a particular
    corrid or a bunch of corrids

    Note:
    Currenlty there is no way to determine if a particular subquery is
    "finished" in C API. So to handle this we will broadcast the failure
    to all SQRI instances and filter them out later.

    """
    _ANY_CORRID = 0

    def __init__(self, loop, block):
        super().__init__(loop)
        self._block = block

        # Creating a single SQRI for each subquery
        self._qris = {corrid: SubQueryResultIterator(self._block, corrid, self._loop)
                for corrid in range(1, self._block._next_corrid)}

    def _get_result(self):
        # Just to make the meta happy.
        pass

    def is_xact_complete(self, xact_status):
        return xact_status.is_responses_done()

    @property
    def ready(self):
        """
        Overriding the ready. Here we define the BQI to be ready if all the
        SQRIs are ready.

        """
        events = [qri.ready for qri in self._qris.values()]

        return asyncio.gather(*events, loop=self._loop)

    def __iter__(self, corrid=None):
        """
        @param corrid - (Optional), int/list. To query based on corrid id(s)
        """
        if not self._got_first_callback.is_set():
            raise ValueError('BlockResultIterator has not yet recieved the first response')

        iterables = []
        if corrid and corrid != self._ANY_CORRID:
            if not isinstance(corrid, list):
                corrid = [corrid]

            for cid in corrid:
                if cid not in self._qris:
                    raise ValueError("Invalid corrid ID: %d provided" % cid)
                iterables.append(self._qris[cid])
                self._qris.pop(cid)

        else:
            # Join the iterables of all the subqueries.
            iterables = list(self._qris.values())
            # empty the list
            self._qris = {}

        for f in itertools.chain(*iterables):
            try:
                yield from f
                yield f
            except TransactionFailed:
                # Each subquery will contain a copy of TransactionFailed notice.
                # We will discard it as the BQI itself has a copy of it.
                pass

        # The BQI has only one Future, that will contain the Transaction failure
        # In case of a successful transaction the Future is discarded with
        # the _no_responses flag.
        for f in super().__iter__():
            yield f

    def __call__(self, xact, xact_status_in, __):
        """
        So for every callback the block receives, we call every instance of SQRI

        Also note that the BQI itself has a futures queue attached to itself.
        We will be using this to capture the transaction failures. To
        understand better for a callback here are the set of events that will
        happen

        1. The callback calls every instance of SRQI it holds, with the same params
        2. The SQRI in turn calls the TransactionBlock's get_result with it's
           correlation-id
            a. In case of Transaction failure also every SQRI is called with
               the failed status. So, this means that each SQRI has the same
               failure message. This is because, currently there is no way to
               identify if a particular sub-query is done (ENHANCEMENT)
        3. After the first callback, the _got_first_callback event is triggered
        4. Finally the overall Block success/failure is recorded in the future
           instance stored in the BRI's queue.

        """
        # Broadcast the callback to each SRQIs
        for corrid, sqri in self._qris.items():
            logger.debug("Broadcasting to corrid: {}".format(corrid))
            sqri(xact, xact_status_in, __)

        if not self._got_first_callback.is_set():
            self._loop.call_soon_threadsafe(self._got_first_callback.set)

        xact_status = TransactionStatus(xact_status_in)
        xact = Transaction(xact, loop=self._loop)

        is_xact_complete = self.is_xact_complete(xact_status)
        logger.debug("{}: Completed state is {}.".format(
            self.__class__.__name__, is_xact_complete))

        # If the transaction has failed record the failure in the BRI instance
        if is_xact_complete and xact_status.is_failed():
            exception = xact_status.get_exception(xact)
            logger.debug("{}: failed with status: {}".format(
                    self.__class__.__name__, exception.__class__.__name__))

            self.set_future(self._futures[0], exception,
                    exception=True)
        elif is_xact_complete and not xact_status.is_failed():
            # Othewise mark is as no response, so the iterator can break early
            self._loop.call_soon_threadsafe(self._no_responses.set)

    def query_result(self, corrid):
        """
        Returns a corrid based QRI. Also adds a Transaction failure
        incase the of the Block has failed.
        """
        return self.__iter__(corrid=corrid)


class TransactionBlock(object):
    def __init__(self, block, loop, on_abort=None, on_failure=None):
        """
        Create a TransactionBlock object from a raw RwDts.XactBlock handle

        @param block      - RwDts.XactBlock handle
        @param loop       - asyncio loop
        @param on_abort   - function to call if the transaction is aborted
        @param on_failure - function to call if the transaction fails
        """
        self._block = block
        self._loop = loop
        self._on_abort = None
        self._on_failure = None
        self._next_corrid = 1

        if on_abort is not None and asyncio.iscoroutinefunction(on_abort):
            raise ValueError('on_abort cannot be a coroutine')

        if on_failure is not None and asyncio.iscoroutinefunction(on_failure):
            raise ValueError('on_failure cannot be a coroutine')

    @property
    def handle(self):
        """
        Raw RwDts.XactBlock handle
        """
        return self._block

    def handle_abort(self):
        """
        If a handler was specified for transaction abort, add it to the event
        loop.
        """
        if self._on_abort is not None:
            self._loop.call_soon_threadsafe(self._on_abort, self)
            self._loop.scheduler_tick()

    def handle_failure(self):
        """
        If a handler was specified for transaction failure, add it to the event
        loop.
        """
        if self._on_failure is not None:
            self._loop.call_soon_threadsafe(self._on_failure, self)
            self._loop.scheduler_tick()

    def _add_query(self, xpath, action, flags=0, msg=None):
        if msg is not None:
            msg = msg if isinstance(msg, gi.repository.ProtobufC.Message) else msg.to_pbcm()

        if isinstance(xpath, KeyBuilder):
            xpath = xpath._path

        corrid = self._next_corrid
        status = self._block.add_query(xpath, action, flags, corrid, msg)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationError(xpath, status)

        self._next_corrid += 1
        return corrid

    def add_query_create(self, xpath, msg, flags=0):
        """
        Add a CREATE query to the block

        @param xpath  - path at which to create data
        @param msg    - path GI PBCM payload
        @param flags  - RwDts.Flag
        @return       - query corrid
        @raises       - RegistrationError
        """
        return self._add_query(xpath, rwdts.QueryAction.CREATE, flags, msg)

    def add_query_read(self, xpath, flags=0):
        """
        Add a READ query to the block

        @param xpath  - path to read
        @param flags  - RwDts.Flag
        @return       - query corrid
        @raises       - RegistrationError
        """
        return self._add_query(xpath, rwdts.QueryAction.READ, flags)

    def add_query_update(self, xpath, msg, flags=0):
        """
        Add an UPDATE query to the block

        @param xpath  - path at which to update data
        @param msg    - path GI PBCM payload
        @param flags  - RwDts.Flag
        @return       - query corrid
        @raises       - RegistrationError
        """
        return self._add_query(xpath, rwdts.QueryAction.UPDATE, flags, msg)

    def add_query_delete(self, xpath, flags=0):
        """
        Add a DELETE query to the block

        @param xpath  - path to delete
        @param flags  - RwDts.Flag
        @return       - query corrid
        @raises       - RegistrationError
        """
        return self._add_query(xpath, rwdts.QueryAction.DELETE, flags)

    def add_query_rpc(self, xpath, msg, flags=0):
        """
        Add a RPC query to the block

        @param xpath  - RPC path
        @param msg    - RPC input GI PBCM
        @param flags  - RwDts.Flag
        @return       - query corrid
        @raises       - RegistrationError
        """
        return self._add_query(xpath, rwdts.QueryAction.RPC, flags, msg)

    @asyncio.coroutine
    def execute(self, flags=0, after_block=None, now=False):
        """
        Execute the block.

        @param flags        - RwDts.Flag
        @param after_block  - queue this block to execute after the specifed block
        @param now          - execute this block now
        @return             - iterator yielding futures for each response
        @raises             - BlockExecuteError
        """
        if after_block is not None and now:
            raise AttributeError('Cannot execute now and after a specified block')

        qri = BlockResultIterator(self._loop, self)
        if now:
            status = self._block.execute_immediate(flags, qri, None)
        else:
            status = self._block.execute(flags, qri, None, after_block)

        if status != rwtypes.RwStatus.SUCCESS:
            raise BlockExecuteError()

        yield from qri.ready
        return qri

    def has_more_results(self, corrid=None):
        if not corrid:
            return self._block.get_more_results()
        return self._block.get_query_more_results(corrid)

    def query_result(self, corrid=None):
        if not corrid:
            return self._block.query_result()
        return self._block.query_result(corrid)


class Transaction(object):
    def __init__(self, xact, loop):
        """
        Create a Transaction object from a raw RwDts.Xact handle

        @param xact - RwDts.Xact handle
        @param loop - asyncio loop
        """
        self._xact = xact
        self._loop = loop

    @property
    def id(self):
        """
        Returns the ID of the transaction.
        """
        return getattr(self._xact, "id", None)

    def __str__(self):
        return "Transaction(xact_id=%s)" % self.id

    @property
    def xact(self):
        return self._xact

    @property
    def handle(self):
        """
        Returns the raw xact handle instance.
        """
        return self._xact

    def has_more_results(self):
        return self._xact.get_more_results()

    def query_result(self):
        return self._xact.query_result()

    def block_create(self, on_abort=None, on_failure=None):
        block_handle = self._xact.block_create()
        return TransactionBlock(block_handle, self._loop, on_abort, on_failure)

    def get_error_heuristic(self, corrid=0):
        status, xpath, err_cause, errstr = self._xact.get_error_heuristic(corrid)
        return (err_cause, errstr)

    def query_error(self, corrid=0):
        """
        A wrapper on top of rwdts_xact_query_error. Also enriches the error
        with meta data such as path, cause and error message.

        @param corrid - (Optional) correlation ID, default to 0
        @yield returns a tuple containing: (path, cause, error message)

        """
        error = self._xact.query_error(corrid)
        while error is not None:
            path = error.get_xpath()
            cause = error.get_cause()
            err_str = error.get_errstr()
            yield (path, cause, err_str)
            error = self._xact.query_error(corrid)

    def abort(self, error_msg=None, status=rwtypes.RwStatus.FAILURE):
        """
        Abort the current XACT

        @param error_msg - Error message
        @param status - (Optional) RwStatus flag
        """
        self._xact.abort(status, error_msg)


class TransactionInfo(object):
    def __init__(self, xact_info):
        """
        Create a TransactionInfo object from a raw DTS xact_info GI object

        @param xact_info  - rwdts_xact_info_t GI reference
        """
        self._xact_info = xact_info
        self._raw_xact = self._xact_info.get_xact()

    @property
    def xact(self):
        return Transaction(self._raw_xact, loop=asyncio.get_event_loop())

    @property
    def handle(self):
        """
        Return raw RwDts.XactInfo instance
        """
        return self._xact_info

    @property
    def query_action(self):
        return self.handle.get_query_action()

    def respond_xpath(self, rsp_code, xpath=None, msg=None):
        """
        Send a response for this transaction using xpath as key

        @param rsp_code - XactRspCode
        @param xpath    - xpath to use as key
        @param msg      - protobuf GI message to respond with (to_pbcm() will be called if necessary).
        @raises         - ResponseError on any failure
        """
        if msg is not None:
            msg = msg if isinstance(msg, gi.repository.ProtobufC.Message) else msg.to_pbcm()

        status = self._xact_info.respond_xpath(rsp_code, xpath, msg)
        if status != rwtypes.RwStatus.SUCCESS:
            raise ResponseError('Failed to respond on xpath %s: %s' % (xpath, status))

    def send_error_xpath(self, rwstatus, xpath, errmsg):
        """
        Send error response to for this transaction using xpath as key

        @param rwstatus - RwTypes.RwStatus
        @param xpath    - xpath to use as key
        @param errmsg   - error message
        @raises         - ResponseError on any failure
        """
        status = self._xact_info.send_error_xpath(rwstatus, xpath, errmsg)
        if status != rwtypes.RwStatus.SUCCESS:
            raise ResponseError('Failed to send error on xpath %s: %s' % (xpath, status))

    def transactional(self):
        """
        Checks if the query is 3 phase transactional type 

        """
        try:
            return(self._xact_info.transactional())
        except:
            raise ResponseError('Failed to get transactional status')

class TransactionStatus(object):
    """
    A thin wrapper on top of rwdts_xact_info_t
    """
    def __init__(self, xact_status):
        """
        @param xact_status - rwdts_xact_info_s handle
        """
        self._xact_status = xact_status
        self._FAILURE_STATES = {
                rwdts.XactMainState.ABORTED: TransactionAborted,
                rwdts.XactMainState.FAILURE: TransactionFailed,
                }

        self._SUCCESS_STATES = [rwdts.XactMainState.COMMITTED]

    @property
    def handle(self):
        """
        Return raw handle
        """
        return self._xact_status

    def is_done(self):
        """
        Convenience method to check if the transaction has no more responses
        """
        return self._xact_status.xact_done

    def is_responses_done(self):
        """
        Convenience method to check if the transaction has no more responses
        """
        return self._xact_status.responses_done

    def is_success(self):
        """
        Convenience method for checking the success state
        """
        return self._xact_status.status in self._SUCCESS_STATES

    def is_failed(self):
        """
        Convenience method for checking the failure state
        """
        return self._xact_status.status in self._FAILURE_STATES

    def get_exception(self, xact):
        """
        Wrapper method to build the pythonic exception for the failure states.

        @param xact - Instance of Transaction
        @return TransactionException incase of a failed transaction
        @raises KeyError, incase the method is called for a successful
                transaction.
        """
        try:
            exception = self._FAILURE_STATES[self._xact_status.status]
            exception = exception(xact)
            return exception
        except KeyError:
            # Ideally this should not happen, but for
            # completeness we will add a KeyError here.
            KeyError("Invalid failure state for xact: %s" %
                    str(self._xact_status.status))

class Shard(object):
    def __init__(self, shard_handle, loop):
        """
        Create a Shard from a raw DTS member_reg_handle

        @param shard_handle - GI RwDts.ShardHandle to wrap
        @param loop       - Event loop to use
        """
        self._shard_handle = shard_handle
        self._loop = loop

    def appdata_register_safe_key(self, getnext=None, take=None, put=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param take - take fn ptr
        @param put - put fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_safe_keyspec(getnext, take, put, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_queue_key(self, getnext=None, copy=None, pbdelta=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param copy - copy fn ptr
        @param pbdelta - pbdelta fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_queue_keyspec(getnext, copy, pbdelta, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_unsafe_key(self, getnext=None, get=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param get - get fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_unsafe_keyspec(getnext, get, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_unsafe_pe(self, getnext=None, get=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param get - get fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_unsafe_pe(getnext, get, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')        

    def appdata_register_queue_pe(self, getnext=None, copy=None, pbdelta=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param copy - copy fn ptr
        @param pbdelta - pbdelta fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_queue_pe(getnext, copy, pbdelta, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_safe_pe(self, getnext=None, take=None, put=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param take - take fn ptr
        @param put - put fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_safe_pe(getnext, take, put, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_safe_minikey(self, getnext=None, take=None, put=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param take - take fn ptr
        @param put - put fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_safe_minikey(getnext, take, put, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata') 

    def appdata_register_queue_minikey(self, getnext=None, copy=None, pbdelta=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param copy - copy fn ptr
        @param pbdelta - pbdelta fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_queue_minikey(getnext, copy, pbdelta, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_register_unsafe_minikey(self, getnext=None, get=None, create=None, delete_fn=None, ud=None):
        """
        Register with appdata
        @param getnext - getnext fn ptr
        @param get - get fn ptr
        @param create - create fn ptr
        @param delete_fn - delete fn ptr
        @param ud - user data
        """
        status = self._shard_handle.appdata_register_unsafe_minikey(getnext, get, create, delete_fn, ud)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to register appdata')

    def appdata_create(self, xpath=None, msg=None):
        payload = msg if isinstance(msg, gi.repository.ProtobufC.Message) else msg.to_pbcm()
        status = self._shard_handle.appdata_create_element_xpath(xpath, payload)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to create appdata')

class Registration(object):
    def __init__(self, reg_handle, xpath, dts, loop):
        """
        Create a Registration from a raw DTS member_reg_handle

        @param reg_handle - GI RwDts.MemberRegHandle to wrap
        @param xpath      - xpath to registration point
        @param loop       - Event loop to use
        """
        self._reg_handle = reg_handle
        self._xpath = xpath
        self._dts = dts
        self._loop = loop
        self._shards = []

    def get_xact_elements(self, xact=None, include_keyspec=False):
        """
        Iterator over registration elements based on a transaction handle.

        Note that this iterator cannot be stacked, RIFT-7127

        #param xact    - Transaction() instance
        """

        # If the Transaction instance was passed in, then grab the underlying
        # dts transaction handle.
        if xact is not None:
            xact = xact.xact

        cursor = self._reg_handle.get_cursor(xact)

        while True:
            pbcm, ks = self._reg_handle.get_next_element(cursor, xact)
            if pbcm is None:
                break

            if not include_keyspec:
                yield pbcm_to_gi(pbcm)
            else:
                yield (pbcm_to_gi(pbcm), ks)

        self._reg_handle.delete_cursors(xact)
        raise StopIteration()

    @property
    def elements(self):
        """
        Iterator over registration elements.

        Note that this iterator cannot be stacked, RIFT-7127
        """
        return self.get_xact_elements()

    def shards(self):
        """
        Iterator over the registrations associated with this AppConfGroup
        """
        for shard in self._shards:
            yield shard
        raise StopIteration()

    @asyncio.coroutine
    def audit(self, action):
        """
        Run a DTS audit on this registration.

        @param action - Type of audit to run, RwDts.AuditAction
        @return       - Audit result, RwDts.AuditResult
        """
        done = asyncio.Future(loop=self._loop)

        def on_audit_complete(apih, regh, result, _):
            self._loop.call_soon_threadsafe(done.set_result, result)
            self._loop.scheduler_tick()

        self._reg_handle.audit(action, on_audit_complete, None)
        ret = yield from done
        return ret

    def _get_xact(self, xact):
        """
        Get the raw xact object from the python wrapper.
        """
        if xact is None:
            return xact

        if type(xact) is Transaction:
            # Get the raw handle from the py wrapper
            return xact.xact

        return xact

    def create_element(self, xpath, msg, xact=None):
        """
        Create an element at this registration point

        @param xpath  - xpath at which this object will be created
        @param msg    - GI Box protobuf message to be created
        @param flags  - RwDts.Flag
        @raises       - RegistrationElementError on failure
        """

        xact = self._get_xact(xact)
        payload = msg if isinstance(msg, gi.repository.ProtobufC.Message) else msg.to_pbcm()

        status = self._reg_handle.create_element_xpath(xpath, payload, xact)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to create element for xpath %s' % (xpath,))

    def update_element(self, xpath, msg, flags=0, xact=None):
        """
        Update an element at this registration point

        @param xpath  - xpath at which to update
        @param msg    - updated GI Box protobuf message
        @param flags  - RwDts.Flag
        @param xact   - 
        @raises       - RegistrationElementError on failure
        """
        xact = self._get_xact(xact)
        payload = msg if isinstance(msg, gi.repository.ProtobufC.Message) else msg.to_pbcm()

        status = self._reg_handle.update_element_xpath(xpath, payload, flags, xact)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to update element for xpath %s' % (xpath,))

    def get_element(self, xpath):
        """
        Get an element at this registration point

        @param xpath  - xpath at which to get element
        @return       - GI Box protobuf message
        @raises       - RegistrationElementError on failure
                        ValueError if no element exists
        """
        status, ks, pbcm = self._reg_handle.get_element_xpath(xpath)

        if status != rwtypes.RwStatus.SUCCESS:
            raise ValueError('No element at xpath %s status %s' % (xpath,))

        if pbcm is None:
            raise ValueError('No element at xpath %s' % (xpath,))

        return pbcm_to_gi(pbcm)

    def delete_element(self, xpath, xact=None):
        """
        Delete an element at this registration point

        @param xpath  - xpath at which to delete element
        @raises       - RegistrationElementError on failure
        """
        xact = self._get_xact(xact)
        status = self._reg_handle.delete_element_xpath(xpath, None, xact)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to delete element for xpath %s' % (xpath,))

    def get_shard(self):
        """
        Get shard associated with this registration 

        """
        sha = self._reg_handle.get_shard()
        shard_hand = Shard(sha, self._loop)
        self._shards.append(shard_hand)
        return shard_hand

    @asyncio.coroutine
    def shard_init(self, xact=None, parent=None, flags=0):
        """
        Shard int at registration point
         
        @param xact - If the shard init is transactional
        @param parent - shard parent
        @param flags - Registration flags
        """

        sha = rwdts.ShardHandle.new(self._reg_handle, flags, rwdts.ShardFlavor.NULL, None, rwdts.ShardKeyfunc.NOP, None, rwdts.ShardAnycast.ROUND_ROBIN, None)
        shard_hand = Shard(sha, self._loop)
        self._shards.append(shard_hand)
        return shard_hand

    def deregister(self):
        """
        Deregister the keyspec from the reg handle
        """

        status = self._reg_handle.deregister()
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationElementError('Failed to deregister')

class AppConfGroup(object):
    class Handler(object):
        """
        Appconf Group Handler

        This class contains the handlers to be executed when an Appconf Group
        enters a specific state.  All of these functions will be wrapped in a
        coroutine that executes within the event-loop context.  However, they
        must not be coroutines themselves as they must exit without yielding
        control to the event loop.

        @param on_init      - Called when a new transaction starts
            on_init(AppConfGroup, RwDts.Xact)

        @param on_deinit    - Called when a transaction finishes
            on_deinit(AppConfGroup, RwDts.Xact)

        @param on_validate  - Called when the group starts the validation phase
            on_validate(DTS, AppConfGroup, RwDts.Xact)

        @param on_apply     - Called when the group enters the apply phase
            on_apply(DTS, AppConfGroup, RwDts.Xact, RwDts.AppconfAction)
        """
        def __init__(self, on_init=None, on_deinit=None, on_validate=None, on_apply=None):
            self.on_init = on_init
            self.on_deinit = on_deinit
            self.on_validate = on_validate
            self.on_apply = on_apply

            for f in ('on_init', 'on_deinit', 'on_validate'):
                ref = getattr(self, f)
                if ref is None:
                    continue

                if asyncio.iscoroutinefunction(ref):
                    raise ValueError('%s cannot be a coroutine' % (f,))

    def __init__(self, appconf_group, dts):
        """
        Create a new AppConfigGroup from a raw RwDts.AppconfGroup.

        @param appconf_group  - raw RwDts.AppconfGroup instance
        @param dts            - DTS instance used to create the appconf_group
        """
        self._acg = appconf_group
        self._dts = dts
        self._regs = []
        self._scratch = {}
        self.scheduler = TaskScheduler(self._dts)

    @property
    def handle(self):
        """
        The backing RwDts.Appconf instance
        """
        return self._acg

    @property
    def scratch(self):
        """
        Returns the scratch(python dict). Contains data per transaction
        {xac.id => {xact data}}
        """
        return self._scratch

    @property
    def registrations(self):
        """
        Iterator over the registrations associated with this AppConfGroup
        """
        for reg in self._regs:
            yield reg
        raise StopIteration()

    def register(self, xpath, flags, on_prepare=None):
        """
        Register an appconf using xpath

        @param xpath      - xpath associated with this registration
        @param flags      - bitwise or-ed RwDts.Flags to use
        @param on_prepare - prepare callback for this registration
            on_prepare(DTS, AppConfGroup, RwDts.Xact, TransactionInfo, RwDts.KeyspecPath, GIBox)
        @return           - Registration instance.
        @raises           - RegistrationError on failure
        """
        def wrap_on_prepare(f):
            """
            Convert dts, acg and xact_info to wrapped objects.  Drop context
            and scratch.  Convert raw pbcm to Gi Box
            """
            @functools.wraps(f)
            def wrapper(raw_dts, raw_acg, xact, xact_info, ks, msg, _, *args):
                xact_info = TransactionInfo(xact_info)
                xact = Transaction(xact, loop=self._dts.loop)

                msg = pbcm_to_gi(msg)
                exp_clbk = ExceptionRule.send_nack(xact_info, None)

                scratch = self.scratch.setdefault(xact.id, {})
                self.scheduler.schedule_task(
                        f,
                        self._dts,
                        self,
                        xact,
                        xact_info,
                        ks,
                        msg,
                        scratch,
                        exception_callback=exp_clbk)

            return wrapper if f is not None else None

        if on_prepare is not None and not asyncio.iscoroutinefunction(on_prepare):
            raise ValueError("on_prepare must be a coroutine or None")

        status, reg_handle = self._acg.register_xpath(
                xpath,
                flags,
                wrap_on_prepare(on_prepare))
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationError(xpath, status)

        reg = Registration(reg_handle, xpath, self._dts, self._dts.loop)
        self._regs.append(reg)

        return reg

class ExceptionRule(object):
    """
    A class that contains all the exception handling rules/callbacks.
    """
    @classmethod
    def send_nok(cls, xact_info, exception=None):
        """
        Rule send_nok:

        @param xact_info - Instance of TransactionInfo
        @param exception - exception message
        @return a callable if @exception is None, otherwise
                rwdts.MemberRspCode.ACTION_NOT_OK

        Logs the exception using "send_error_path" API and returns NOT_OK flag.
        """
        if exception is None:
            return functools.partial(cls.send_nok, xact_info, exception=None)

        cls.send_error(xact_info, exception)
        return rwdts.MemberRspCode.ACTION_NOT_OK

    @classmethod
    def send_nack(cls, xact_info, kspath, exception=None):
        """
        Rule send_nack:

        @param xact_info - Instance of TransactionInfo
        @param kspath    - raw key spec path
        @param exception - Exception string
        @return a callable if @exception is None, otherwise nothing

        Logs the exception and returns a NACK flag for the given keyspec.
        """
        if exception is None:
            return functools.partial(cls.send_nack, xact_info, kspath,
                    exception=None)

        cls.send_error(xact_info, exception)
        xact_info.handle.respond_keyspec(rwdts.XactRspCode.NACK, kspath)

    @classmethod
    def send_error(cls, xact_info, exception=None):
        """
        Rule send_error:

        @param xact_info - TransactionInfo instance
        @param exception - Exception string
        @return a callable if @exception is None, otherwise nothing

        Logs the error using the send_error_xpath API
        """
        if exception is None:
            return functools.partial(cls.send_error, xact_info, exception=None)

        xact_info.send_error_xpath(rwtypes.RwStatus.FAILURE, None, exception)

    @classmethod
    def abort_xact(cls, xact, exception=None, return_flag=None):
        """
        Rule abort_xact

        @param xact        - Instance of Transaction
        @param exception   - exception string
        @param return_flag - (Optional) If set returns the value
        @return @return_flag

        Aborts the transaction and retuns the @return_flag param, if set.
        """
        if exception is None:
            return functools.partial(cls.abort_xact, xact, exception=None,
                    return_flag=return_flag)

        xact.abort(exception)

        if return_flag:
            return return_flag

class TaskScheduler(object):
    """Contains all wrappers over asyncio schedule api. The wrappers take care
    of capturing all exceptions from coros and throws them to console or
    to the callback if specified.
    """
    def __init__(self, dts):
        """
        Args:
            @param dts : Dts handle.
        """
        self.dts = dts

    def exec_soon(self, func, *args, exception_callback=None, **kwargs):
        """
        A thin wrapper on top of the asycio's call_soon_threasafe APIs. The
        wrapper adds exception handling and triggers the exception callback
        in case of an exception.

        @param func   - The function that needs to be executed in the loop
        @param args   - Arguments to @func
        @param kwargs - Keyword arguments to the @func
        @keyword exception_callback - (Optional) Callback to be triggered
            in-case of an exception(Keyword-only argument)
        """
        def handle_exception(loop, context):
            """
            @param loop    - The loop in which the exception was triggered
            @param context - A dict containing the exception message and meta-data
                    about the exception.
            """
            exception = context['exception']
            # Format the exception to a string.
            if exception_callback is not None:
                exp_str = context.get('message', "")
                exp_str += "\n" + str(exception)
                exception_callback(exception=exp_str)
            else:
                raise exception

        handler= self.dts.loop.call_soon_threadsafe(func, *args, **kwargs)
        # Register the exception callback.
        self.dts.exception_handler.register_handle_clbk(handler,
                handle_exception)
        self.dts.loop.scheduler_tick()
        self.dts.exception_handler.clear_handle_clbk(handler)

    def exec_now(self, func, *args, exception_callback=None, **kwargs):
        """
        A wrapper on top of asyncio's run_until_complete.

        @param func   - The function that needs to be executed in the loop
        @param args   - Arguments to @func
        @param kwargs - Keyword arguments to the @func
        @keyword exception_callback - (Optional) Callback to be triggered
                in-case of an exception
        @raise Exception, in case an exception occured and no callback was
                provided.
        @return The result of func or the exception_callback in case of an
                exception.
        """
        try:
            ret = self.dts.loop.run_until_complete(func(*args, **kwargs))
            return ret
        except Exception as e:
            if exception_callback is not None:
                exp_str = traceback.format_exc()
                return exception_callback(exception=exp_str)
            else:
                # Falling back to default behaviour.
                raise e

    def schedule_task(self, coro, *args, exception_callback=None, **kwargs):
        """
        A wrapper on top of asyncio's ensure_future/async. Wraps the coro
        into another coro to handle exceptions, if any.

        @param coro   - coroutine that needs to be executed in the loop
        @param args   - Arguments to @coro
        @param kwargs - Keyword arguments to the @coro
        @keyword exception_callback - (Optional) Callback to be triggered
                in-case of an exception(Keyword-only argument)
        """
        @asyncio.coroutine
        def handle_exception():
            """
            Wraps the function to be scheduled into a coroutine
            for handling exceptions and triggers the callback in case
            of exception.
            """
            try:
                yield from coro(*args, **kwargs)
            except Exception as e:
                if exception_callback is not None:
                    exp_str = traceback.format_exc()
                    sys.stderr.write(exp_str)
                    exception_callback(exception=exp_str)
                else:
                    raise e

        asyncio.ensure_future(handle_exception(),
                loop=self.dts.loop)
        self.dts._loop.scheduler_tick()


class EventAdapter(object):
    def __init__(self, handler, dts, registration=None):
        """
        A top level class which basically provides the bare-bone elements
        for the Adapters.

        The adapters provides a bridge between the C callbacks and python
        callbacks, and provides exception handling for callbacks.

        @param handler - Handler instance containing all event callbacks
        @param dts     - DTS instance containing the event loop
        @param registration - Handle to the registered object for which
            the callbacks are wrapped by the adapter.
        """
        self.handler = handler
        self.dts = dts
        self.registration = registration
        self.scheduler = TaskScheduler(self.dts)


class RegistrationEventAdapter(EventAdapter):
    """
    A class that wraps all the callbacks. Takes care of replacing GI objects
    into python objects

    RwDts.MemberRegHandle => Registration
    pbcm                  => Appropriate GI object
    xact_info             => TransactionInfo
    """

    def __init__(self, handler, dts, registration=None):
       super().__init__(handler, dts, registration)
       self.registration_ready = asyncio.Event(loop=self.dts.loop)

    def validate_and_correct_flags(self, flags):
        """
        Verify the input flags and correct it if necessary based on the
        following rules.

        1. If a publisher has no prepare callable, check and insert
           NO_PREP_READ flag.
        """

        # Rule 1
        if flags & rwdts.Flag.PUBLISHER == rwdts.Flag.PUBLISHER and \
                self.handler.on_prepare is None:
            flags = flags|rwdts.Flag.NO_PREP_READ

        return flags

    def on_ready(self):
        """
        Wraps the on_ready callback, dropping the userdata argument and moving
        execution into the asyncio loop
        """
        on_ready = self.handler.on_ready

        @functools.wraps(on_ready)
        def wrapper(raw_regh, status, _):
            self.scheduler.schedule_task(on_ready, self.registration, status,
                    exception_callback=ExceptionRule.send_error(status))
        self.registration_ready.set()
        return wrapper if on_ready is not None else None

    def on_prepare(self):
        """
        Wraps the on_prepare callback, converting xact_info to
        TransactionInfo, pbcm to GI Box,dropping userdata and moving
        execution into the asyncio loop by returning ACTION_ASYNC

        """
        on_prepare = self.handler.on_prepare

        @functools.wraps(on_prepare)
        def wrapper(xact_info, query_action, ks_path, pbcm, _):
            xact_info = TransactionInfo(xact_info)
            msg = pbcm_to_gi(pbcm) if pbcm is not None else None

            # RIFT-10038: We don't want to respond with the input keyspec,
            # as it can be wildcard, in case of exception. So setting it to
            # None.
            exp_clbk = ExceptionRule.send_nack(xact_info, None)
            self.scheduler.schedule_task(
                    on_prepare,
                    xact_info,
                    query_action,
                    ks_path,
                    msg,
                    exception_callback=exp_clbk)

            return rwdts.MemberRspCode.ACTION_ASYNC
        return wrapper if on_prepare is not None else None

    def on_commit(self):
        return self._on_callback(self.handler.on_commit)

    def on_precommit(self):
        return self._on_callback(self.handler.on_precommit,
                ExceptionRule.send_nok)

    def on_abort(self):
        return self._on_callback(self.handler.on_abort)

    def _on_callback(self, func, exception_callback=None):
        """
        Wrapper for the remainder of the callbacks, converts xact_info to
        TransactionInfo, drops userdata and moves execution into the asyncio
        loop by wrapping the function in a coroutine.
        """
        @functools.wraps(func)
        def wrapper(xact_info, _):
            xact_info = TransactionInfo(xact_info)
            exp_clbk = None
            if exception_callback is not None:
                exp_clbk = exception_callback(xact_info)
            @asyncio.coroutine
            def run_in_event_loop():
                return func(xact_info)
            ret = self.scheduler.exec_now(
                    run_in_event_loop,
                    exception_callback=exp_clbk)
            return ret

        return wrapper if func is not None else None


class GroupEventAdapter(EventAdapter):
    """
    A class that is responsible for wrapping all the GI objects into pythonic
    wrappers.

    Transforms:
        RwDts       => DTS
        RwDts.Group => Group
        RwDts.Xact  => Transaction

    NOTE: Here we are droppping ud & scratch params from C and instead creating
    a local scratch (dict) which is native to python, which makes debugging
    easier.
    """
    def on_init(self):
        """
        Wraps the on_init callback. Here we drop add an additional scratch
        param to the callback, this provides the client app to stash any
        data during the on_init callback.
        """
        on_init = self.handler.on_init

        @functools.wraps(on_init)
        def wrapper(raw_group_reg, xact_raw, *args):
            """
            Called when a transaction begins.
            """
            xact = Transaction(xact_raw, self.dts.loop)

            # Here we set the scratch per transaction
            scratch = self.registration.scratch.setdefault(xact.id, {})
            if on_init is not None:
                @asyncio.coroutine
                def run_in_event_loop():
                    on_init(self.registration, xact, scratch)
 
                self.scheduler.exec_now(
                        run_in_event_loop, 
                        exception_callback=ExceptionRule.abort_xact(xact))

        return wrapper

    def on_deinit(self):
        """
        Removes the scratch associated with the transaction, if present.
        """
        on_deinit = self.handler.on_deinit

        @functools.wraps(on_deinit)
        def wrapper(raw_group_reg, xact_raw, *args):
            """
            Called when the transaction ends.
            """
            xact = Transaction(xact_raw, self.dts.loop)
            scratch = self.registration.scratch.setdefault(xact.id, {})
            if scratch is not None and scratch:
                print("GroupEventAdapter: on_deinit: self=", self, "scratch=", scratch, "**")

            if on_deinit is not None:
                @asyncio.coroutine
                def run_in_event_loop():
                    on_deinit(self.registration, xact, scratch)

                self.scheduler.exec_now(run_in_event_loop)
                        
            # We want the scratch to be removed only after the deinit callback
            # is done. This ensures that the scratch is still available for
            # the client within the 'on_deinit' callback.
            self.scheduler.exec_soon(
                    self.registration.scratch.pop,
                    xact.id,
                    None)

        return wrapper

    def on_event(self):
        """
        Wraps the on_event callback and also removes scratch param from C API
        and replaces it with python scratch space.

        """
        on_event = self.handler.on_event

        @functools.wraps(on_event)
        def wrapper(raw_dts, raw_group_reg, xact_raw, xact_event, scratch_raw):
            """
            Called for transaction-wide events such as PRECOMMIT, SUBCOMMIT,
            COMMIT and ABORT
            """
            xact = Transaction(xact_raw, self.dts.loop)
            @asyncio.coroutine
            def run_in_event_loop():
                scratch = self.registration.scratch.setdefault(xact.id, {})

                return on_event(self.dts, self.registration,
                        xact, xact_event, scratch)

            exp_clbk = ExceptionRule.abort_xact(xact,
                    return_flag=rwdts.MemberRspCode.ACTION_NOT_OK)

            if not asyncio.iscoroutinefunction(on_event):
              ret = self.scheduler.exec_now(
                      run_in_event_loop,
                      exception_callback=exp_clbk)
              return ret
            else:
              scratch = self.registration.scratch.setdefault(xact.id, {})
              ret = self.scheduler.exec_now(
                        on_event,
                        self.dts,
                        self.registration,
                        xact,
                        xact_event,
                        scratch,
                        exception_callback=exp_clbk)
              return ret

        return wrapper if on_event is not None else None


class AppConfEventAdapter(EventAdapter):
    """
    Each of the following wrappers will replace the following:
      raw dts instance    -> self.dts
      raw appconfig_group -> AppConfigGroup instance (self.registration)
      raw xact            -> Transaction (python object)
    The will also move execution to the asyncio loop.

    NOTE: Here we are droppping ud & scratch params from C and instead creating
    a local scratch (dict) which is native to python, which makes debugging
    easier.
    """
    def on_init(self):
        """
        Called when the transaction begins
        """
        on_init = self.handler.on_init

        @functools.wraps(on_init)
        def wrapper(raw_ac, xact_raw, *args):
            xact = Transaction(xact_raw, self.dts.loop)

            # Here we set the scratch per transaction
            scratch = self.registration.scratch.setdefault(xact.id, {})

            # We pass the newly created scratch to the 'on_init' callback.
            # This provides the client app to stash any data during the on_init
            # callback.
            if on_init is not None:
                @asyncio.coroutine
                def run_in_event_loop():
                    on_init(self.registration, xact, scratch)

                self.scheduler.exec_now(
                        run_in_event_loop,
                        exception_callback=ExceptionRule.abort_xact(xact))

        return wrapper

    def on_deinit(self):
        """
        Called when transaction ends.
        """
        on_deinit = self.handler.on_deinit

        @functools.wraps(on_deinit)
        def wrapper(raw_ac, xact_raw, ud, scratch_raw):
            xact = Transaction(xact_raw, self.dts.loop)

            scratch = self.registration.scratch.setdefault(xact.id, {})
            if scratch is not None and scratch:
                print("AppConfEventAdapter: on_deinit: self=", self, "scratch=", scratch, "**")
            if on_deinit is not None:
                @asyncio.coroutine
                def run_in_event_loop():
                    on_deinit(self.registration, xact, scratch)

                self.scheduler.exec_now(run_in_event_loop)

            # We want the scratch to be removed only after the deinit callback is
            # done. This ensures that the scratch is still available for
            # the client within the 'on_deinit' callback.
            self.scheduler.exec_soon(
                    self.registration.scratch.pop,
                    xact.id,
                    None)

        return wrapper

    def on_validate(self):
        """
        Called when validation phase begins
        """
        on_validate = self.handler.on_validate

        @functools.wraps(on_validate)
        def wrapper(raw_dts, raw_ac, xact_raw, ud, scratch_raw):
            xact = Transaction(xact_raw, self.dts.loop)
            scratch = self.registration.scratch.setdefault(xact.id, {})

            @asyncio.coroutine
            def run_in_event_loop():
                on_validate(self.dts, self.registration, xact, scratch)

            self.scheduler.exec_now(
                    run_in_event_loop,
                    exception_callback=ExceptionRule.abort_xact(xact))

        return wrapper if on_validate is not None else None


    def on_apply(self):
        """
        Called when apply phase begins
        """
        on_apply = self.handler.on_apply

        @functools.wraps(on_apply)
        def wrapper(raw_dts, raw_ac, xact_raw, action, ud, scratch_raw):
            xact = Transaction(xact_raw, self.dts.loop)
            exception_callback = None
            if xact_raw is not None:
                # On apply gets called multiple time, before & during the
                # transaction.
                # We want the TransactionAbort behaviour only during
                # the transaction.
                exception_callback = ExceptionRule.abort_xact(xact)

            scratch = self.registration.scratch.setdefault(xact.id, {})

            @asyncio.coroutine
            def run_in_event_loop():

                on_apply(self.dts, self.registration,
                         xact, action, scratch)

            if not asyncio.iscoroutinefunction(on_apply):
              self.scheduler.exec_now(
                      run_in_event_loop,
                      exception_callback=exception_callback)

            else:
                self.scheduler.schedule_task(
                        on_apply,
                        self.dts,
                        self.registration,
                        xact,
                        action,
                        scratch,
                        exception_callback=exception_callback)

        return wrapper if on_apply is not None else None


class Group(object):
    class Handler(object):
        """
        Group Handler

        This class contains a bunch of handles to be executed when
        group-register enters a state.

        @param on_init      - Called when a new transaction starts
            on_init(Group, RwDts.Xact)

        @param on_deinit    - Called when a transaction finishes
            on_deinit(Group, RwDts.Xact)

        @param on_event     - Called for transaction-wide events (PRECOMMIT,
                              SUBCOMMIT, COMMIT, ABORT)
            on_event(DTS, AppConfGroup, RwDts.Xact, RwDts.MemberEvent)
        """
        def __init__(self, on_init=None, on_deinit=None, on_event=None):
            self.on_init = on_init
            self.on_deinit = on_deinit
            self.on_event = on_event

            for f in ('on_init', 'on_deinit'):
                ref = getattr(self, f)
                if ref is None:
                    continue

                if asyncio.iscoroutinefunction(ref):
                    raise ValueError('%s cannot be a coroutine' % (f,))

    def __init__(self, group_register, dts):
        """
        Create a new Group instance from a raw RwDts.Group.

        @param group_register - raw RwDts.Group instance
        @param dts            - DTS instance used to create the appconf_group
        """
        self._reg = group_register
        self._dts = dts
        self._regs = []
        self._scratch = {}

    @property
    def handle(self):
        """
        Raw RwDts.Group instance
        """
        return self._reg

    @property
    def registrations(self):
        """
        Iterator over the registrations associated with this Group
        """
        return (reg for reg in self._regs)

    @property
    def scratch(self):
        """
        Returns a dict containing the data per transaction

        {Transaction_ID => {<Data per transaction>}}
        """
        return self._scratch

    def register(self, xpath, handler, flags=0):
        """
        Register an Group using xpath

        @param xpath      - xpath associated with this registration
        @param handler    - DTS.RegistrationHandler instance
        @param flags      - bitwise or-ed RwDts.Flags to use
        @return           - Registration instance.
        @raises           - RegistrationError on failure
        """
        adapter = RegistrationEventAdapter(handler, self._dts)

        status, reg_raw = self._reg.register_xpath(
                xpath,
                adapter.on_ready(),
                adapter.on_prepare(),
                adapter.on_precommit(),
                adapter.on_commit(),
                adapter.on_abort(),
                flags,
                None)

        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationError(xpath, status)

        regh = Registration(reg_raw, xpath, self._dts, self._dts.loop)

        # The on_ready callback needs the Registration handle(regh), but the
        # handle is created only after the 'member_register_xpath' call.
        # Once we have acces we set it on the adapter object to be passed on to
        # the callbacks
        adapter.registration = regh

        self._regs.append(regh)

        return regh


class LoopExceptionHandler(object):
    """
    A class that replaces the default_exception_handler of the asyncio's loop.

    Why?
    ---
    The default_exception_handler in asyncio, throws the exception when a
    task fails with an exception. This behaviour is not desirable in some
    cases.

    In certain cases we might want to customize this behaviour. This can be
    simply done by setting a custom callback in set_exception_handler, but doing
    this will permanently change the exception_callback for the loop. This is
    also not desirable.

    So the solution here is to go for a hybrid approach, by using a model
    similar to asyncio's callback mechanism.

    Details:
    ------
    Any component in the API that wants custom exception hanling to be done
    can register an exception_callback using a key. A key can be anything
    defined in context dict
    https://docs.python.org/3/library/asyncio-eventloop.html#error-handling-api

    example:
    def handle_exception(loop, context):
        # Specific handling goes here..
        pass
    handler= self.dts.loop.call_soon_threadsafe(func, *args, **kwargs)
    # Register the exception callback.
    self.dts.exception_handler.register_handle_clbk(handler,
            handle_exception)

    Currently only support handle as key, but can be extended for Future and more
    """
    def __init__(self, loop):
        """
        @param loop - Event loop for which we need to extend exception handling
        The method also set a custom exception handler for the loop.

        """
        # Setting up constants
        self.KEY_HANDLE = 'handle'
        self.KEYS = [self.KEY_HANDLE]

        self._default_handler = loop.default_exception_handler
        self._callbacks = collections.defaultdict(dict)
        loop.set_exception_handler(self.exception_callback)

    def exception_callback(self, loop, context):
        """
        The default exception callback for the loop
        @param loop - Current execution loop
        @param context - Dict containng keys and exception messages
        https://docs.python.org/3/library/asyncio-eventloop.html#error-handling-api
        """
        exception_handled = False
        for key in self.KEYS:
            # See if we have a registered callback for the key
            try:
                handle = context[key]
                callback = self._callbacks[key].pop(handle)
                exception_handled = True
                callback(loop, context)
            except KeyError:
                pass

        if not exception_handled:
            self._default_handler(context)

    def register_callback(self, key, handle, callback):
        """
        @param key - Defines the kind of registration. Handle, Future 
        @param callback - Callback to be triggered
        @param handle - Instance of Handle/Future/Protocol etc
        """
        self._callbacks[key][handle] = callback

    def clear_callback(self, key, handle):
        """
        If the handle still exists then clean up the handle to prevent
        memory leak.
        """
        if handle in self._callbacks[key]:
            del self._callbacks[key][handle]

    def register_handle_clbk(self, handle, callback):
        """
        A convenience method for register callback for asyncio.Handle
        """
        self.register_callback(self.KEY_HANDLE, handle, callback)

    def clear_handle_clbk(self, handle):
        """
        A convenience method for deregister callback for asyncio.Handle
        """
        self.clear_callback(self.KEY_HANDLE, handle)



class DTS(object):
    class RegistrationHandler(object):
        """
        Registration Handler.

        This class contains the handlers to be executed when DTS enters a given
        state.  Where possible, native GI objects will be converted to more
        pythonic wrappers like TransactionInfo and ProtobufC.Messages will be
        converted to the GI Box type.

        @param on_ready   -  DTS invokes this callback when a registration is ready.
                             The status argument indicates whether the registration
                             is successfull.
            @asyncio.coroutine
            on_ready(rwdts.MemberRegHandle, RwTypes.RwStatus)

        @param on_prepare -  Handle prepare phase of a transaction.  Note that ACTION_ASYNC
            will be returned to DTS automatically and the coroutine scheduled on the event
            loop.
            @asyncio.coroutine
            on_prepare(TransactionInfo, RwDts.QueryAction, RwKeyspec.Path, GIBox msg)

        @param on_precommit - Handle precommit phase of a transaction
            on_precommit(TransactionInfo)

        @param on_commit - Handle commit phase of a transaction
            on_commit(TransactionInfo)

        @param on_abort - Handle transaction abort
            on_abort(TransactionInfo)

        """
        def __init__(self, on_ready=None, on_prepare=None, on_precommit=None, on_commit=None, on_abort=None):
            self.on_ready = on_ready
            self.on_prepare = on_prepare
            self.on_precommit = on_precommit
            self.on_commit = on_commit
            self.on_abort = on_abort

            for f in ('on_precommit', 'on_commit', 'on_abort'):
                ref = getattr(self, f)
                if ref is None:
                    continue

                if asyncio.iscoroutinefunction(ref):
                    raise ValueError('%s cannot be a coroutine' % (f,))

            for f in ('on_ready', 'on_prepare'):
                ref = getattr(self, f)
                if ref is None:
                    continue

                if not asyncio.iscoroutinefunction(ref):
                    raise ValueError('%s must be a coroutine' % (f,))


    class Transaction(object):
        """
        Convenience class for creating and handling transactions.

        Usage:
        xact = Transaction(dts)
        with xact.create():
            ...

        qri = yield from xact.commit()

        for r in qri:
            yield from r

        Note: We want the callbacks to be handled in an async manner and 
        Async context manager is not available in python as of now, so splitting
        it into two components contextlib and coroutine.
        """
        def __init__(self, dts):
            """
            Args:
                dts (DTS): DTS instance
            """
            self.dts = dts
            self.qri = QueryResultIterator(self.dts.loop)

        @contextlib.contextmanager
        def create(self, flags=0):
            """
            Context manager which creates a new transaction.
            While within the context, new block may be added to the transaction.

            @param flags  - RwDts.Flag
            @return       - new Transaction instance
            """
            raw_xact = self.dts.handle.xact_create(flags, self.qri, None)
            self.xact = Transaction(raw_xact, self.dts.loop)

            try:
                yield self.xact
            except TransactionAborted:
                raw_xact.abort()

        def create_xact(self, flags=0):
            raw_xact = self.dts.handle.xact_create(flags, self.qri, None)
            return raw_xact

        @asyncio.coroutine
        def commit(self):
            """
            Signal the end of xact

            Returns:
                QueryResultIterator: Instance of QRI
            """
            self.xact.handle.commit()

            yield from self.qri.ready
            return self.qri

    def __init__(self, tasklet_info, schema, loop, on_state_change=None):
        """
        Convenience wrapper around DTS methods that require callbacks.  Each
        callback function is converted into a asyncio compatible
        Future/Task/Coroutine that can be used with yield from.

        Attributes:
            ready - asyncio.Event set when communication with DTS has been
                    established.

        @param tasklet_info     - tasklet info for current tasklet
        @param schema           - yang schema to use (RwYangPb.Schema)
        @param loop             - loop being used by current tasklet
        @param on_state_change  - callback executed when the dts state changes.
        @param dtsh             - wrap around existing dtsh
            This will be executed in the event loop context
            on_state_change(RwDtsState)
        """
        self.ready = asyncio.Event(loop=loop)
        self._loop = loop
        # Explicitly set the default event loop for the thread. This makes
        # life easier for end users, as they don't have to pass the
        # loop param explicity with every Future/Coro.
        asyncio.set_event_loop(self._loop)
        self.exception_handler = LoopExceptionHandler(self._loop)
        #self._log = rift.tasklets.logger_from_tasklet_info(tasklet_info)
        log_name = tasklet_info.instance_name.replace('.', '_')
        self._log = logging.getLogger('rw.dts.%s' % (log_name,))
        self._log_hdl = tasklet_info.get_rwlog_ctx()
        self._log.addHandler(
                rwlogger.RwLogger(
                    subcategory="dts",
                    log_hdl=self._log_hdl,
                    )
                )

        self._appconf_groups = []
        self._group_regs = []
        self._schema = schema

        def wrap_state_change(f):
            """
            Strip api handle reference and user data from state change callback and
            mark fire this instance's ready event if it hasn't already been fired.
            """
            @functools.wraps(f)
            def wrapper(apih, state, _):
                if not self.ready.is_set():
                    self._loop.call_soon_threadsafe(self.ready.set)

                if f is not None:
                    asyncio.ensure_future(f(state), loop=self._loop)

                if not self._loop.is_running():
                    self._loop.scheduler_tick()
            return wrapper

        if on_state_change is not None and not asyncio.iscoroutinefunction(on_state_change):
            raise ValueError("on_state_change callback must be a coroutine")

        self._schema = schema

        #self._dts = rwdts.Api.find_dtshandle(tasklet_info)
        self._dts = None
        if self._dts is None:
            self._dts = rwdts.Api.new(
                tasklet_info,
                schema,
                wrap_state_change(on_state_change),
                None)

    @property
    def handle(self):
        """
        Return the dts api handle.  To be used for synchronous api calls
        """
        return self._dts

    @property
    def loop(self):
        """
        Return the asyncio loop being used by DTS
        """
        return self._loop

    @property
    def schema(self):
        """
        Return the schema passed into DTS API creation
        """
        return self._schema

    @asyncio.coroutine
    def _create_update_delete(self, xpath, action, flags, msg=None):
        """
        Wrapper around CREATE/UPDATE/DELETE DTS queries
        """
        future = asyncio.Future(loop=self._loop)
        status = None

        if isinstance(xpath, KeyBuilder):
            xpath = xpath._path

        def on_response(xact, evt, _):
            nonlocal status

            xact = Transaction(xact, self._loop)
            status = TransactionStatus(xact.handle.status)

            if status.is_responses_done():
                func = "set_result"
                value = None
                if status.is_failed():
                    # XACT failed, so get the corresponding pythonic
                    # exception and set it, along with the message.
                    exception = status.get_exception(xact)
                    func = 'set_exception'
                    value = exception

                self._loop.call_soon_threadsafe(
                        getattr(future, func),
                        value)
                self._loop.scheduler_tick()

        if msg is not None and not isinstance(msg, gi.repository.ProtobufC.Message):
            msg = msg.to_pbcm()

        if flags & rwdts.XactFlag.RET_PAYLOAD and \
                   (action == rwdts.QueryAction.CREATE or action == rwdts.QueryAction.UPDATE):
            qri = QueryResultIterator(self._loop)
            xact = self._dts.query(xpath, action, flags, qri, None, msg)

            yield from qri.ready
            return qri
        else :
            xact = self._dts.query(
                    xpath,
                    action,
                    flags,
                    on_response,
                    None,
                    msg)
            yield from future

    @asyncio.coroutine
    def _read_rpc(self, xpath, action, flags, msg=None):
        """
        Wrapper around a DTS READ/RPC query.  This method will return a
        generator that can be iterated over to get asyncio.Futures which can be
        yielded from.  As responses come in, a single future will be updated
        with the QueryResult.  Once DTS signals that the transaction is done,
        the generator will exit.
        """
        qri = QueryResultIterator(self._loop)

        if isinstance(xpath, KeyBuilder):
            xpath = xpath._path

        if msg is not None and not isinstance(msg, gi.repository.ProtobufC.Message):
            msg = msg.to_pbcm()

        xact = self._dts.query(xpath, action, flags, qri, None, msg)

        yield from qri.ready
        return qri

    @asyncio.coroutine
    def audit(self, action):
        """
        Run a DTS audit.

        @param action - Type of audit to run, RwDts.AuditAction
        @return       - Audit result, RwDts.AuditResult
        """
        done = asyncio.Future(loop=self._loop)

        def on_audit_complete(apih, regh, result, _):
            self._loop.call_soon_threadsafe(done.set_result, result)
            self._loop.scheduler_tick()

        self._dts.audit(action, on_audit_complete, None)
        ret = yield from done
        return ret

    @asyncio.coroutine
    def query_create(self, xpath, flags, msg):
        """
        Issue a DTS Query with the CREATE action.

        @param xpath  - path to create
        @param flags  - DTS query flags
        @param msg    - GI Box to store at the specified xpath
        @raises       - TransactionAborted, TransactionFailed
        """
        ret = yield from self._create_update_delete(
                xpath,
                rwdts.QueryAction.CREATE,
                flags,
                msg)
        return ret

    @asyncio.coroutine
    def query_read(self, xpath, flags=0):
        """
        Wrapper around a DTS READ query.  This method will return a generator
        that can be iterated over to get asyncio.Futures which can be yielded
        from.  As responses come in, a single future will be updated with a
        QueryResult.  Once DTS signals that the transaction is done, the
        generator will exit.
        """
        ret = yield from self._read_rpc(xpath, rwdts.QueryAction.READ, flags)
        return ret

    def send_notification(self, msg):
        """
        Issue a DTS notification. 
        @param xpath  - path to create
        @param msg    - GI Box to store at the specified xpath
        """
        self._dts.send_notification(msg)

    @asyncio.coroutine
    def query_update(self, xpath, flags, msg):
        """
        Issue a DTS Query with the UPDATE action.

        @param xpath  - xpath to update
        @param flags  - DTS query flags
        @param msg    - Updated GI Box to store at specified xpath
        @raises       - TransactionAborted, TransactionFailed
        """
        ret = yield from self._create_update_delete(
                xpath,
                rwdts.QueryAction.UPDATE,
                flags,
                msg)
        return ret

    @asyncio.coroutine
    def query_delete(self, xpath, flags):
        """
        Issue a DTS Query with the DELETE action.

        @param xpath  - xpath to delete
        @param flags  - DTS query flags
        @raises       - TransactionAborted, TransactionFailed
        """
        yield from self._create_update_delete(
                xpath,
                rwdts.QueryAction.DELETE,
                flags)

    @asyncio.coroutine
    def query_rpc(self, xpath, flags, msg):
        """
        Wrapper around a DTS RPC query.  This method will return a generator
        that can be iterated over to get asyncio.Futures which can be yielded
        from.  As responses come in, a single future will be updated with the
        QueryResult.  Once DTS signals that the transaction is done, the
        generator will exit.
        """
        ret = yield from self._read_rpc(xpath, rwdts.QueryAction.RPC, flags, msg)
        return ret

    @asyncio.coroutine
    def register(self, xpath, handler=None, flags=0, flavor=rwdts.ShardFlavor.NULL, keyin=0, keylen=0, index=-1, startrange=0,endrange=0):
        """
        Wrapper around registering in DTS at the specified xpath.  Will yield until
        communication with DTS has been established.

        @param xpath    - xpath to register at
        @param handler  - DTS.RegistrationHandler instance
        @param flags    - DTS registration flags
        @return         - DTS registration object
        """
        self._log.debug('registering at %s', xpath)
        yield from self.ready.wait()

        if handler is None:
            handler = DTS.RegistrationHandler()

        adapter = RegistrationEventAdapter(handler, self)

        flags = adapter.validate_and_correct_flags(flags)

        status, reg = self._dts.member_register_xpath(
                xpath,
                None,
                flags,
                flavor,
                keyin,
                keylen,
                index,
                startrange,
                endrange,
                adapter.on_ready(),
                adapter.on_prepare(),
                adapter.on_precommit(),
                adapter.on_commit(),
                adapter.on_abort(),
                None)
        if status != rwtypes.RwStatus.SUCCESS:
            raise RegistrationError(xpath, status)

        yield from adapter.registration_ready.wait()

        regh = Registration(reg, xpath=xpath, dts=self._dts, loop=self._loop)

        # The on_ready callback needs the Registration handle(regh), but the
        # handle is created only after the 'member_register_xpath' call.
        # Once we have acces we set it on the adapter object to be passed on to
        # the callbacks
        adapter.registration = regh

        return regh

    def ident_key(self, xpath, index):
        """
        Generate an IDENT key for for the path element index for the given xpath  

        @param xpath      - xpath associated with this registration
        @param index      - path element index within the xpath
        @param keylen     - keylength returned 
        @return           - ident key.
        @raises           - RegistrationError on failure
        """
        key, keylen = self._dts.ident_key_gi(xpath, index)
        return key, keylen

    def deinit(self):
        """
        Initiate API deinit
        """
        self._dts.deinit()

    @contextlib.contextmanager
    def appconf_group_create(self, handler=None, xact=None):
        """
        Context manager which wraps creating an AppConf Group.  While within
        the context, all desired xpaths should be registered against.  When the
        context exits, the AppConfGroup will signal that it has completed the
        REGISTER phase provided that there were no exceptions.

        @param handler  - AppConfGroup.Handler
        @param xact     - Transaction handle to use if any.
        @return         - AppConfGroup instance suituable for creating registrations
        """
        if handler is None:
            handler = AppConfGroup.Handler()

        adapter = AppConfEventAdapter(handler, self)

        status, acg_raw = self._dts.appconf_group_create(
                xact,
                adapter.on_init(),
                adapter.on_deinit(),
                adapter.on_validate(),
                adapter.on_apply(),
                None)
        if status != rwtypes.RwStatus.SUCCESS:
            raise IOError('Failed to create an appconf group')

        acg = AppConfGroup(acg_raw, self)

        # We require the AppConf Group handle for 'on_init' callback, but we
        # have access to it only after the 'appconf_group_create' API call.
        # After getting the raw handle from the API call we wrap it and set it
        # in the adapter for 'on_init' callback
        adapter.registration = acg

        try:
            yield acg
        except:
            # There doesn't seem to be any deinit/free api for appconf groups...
            raise
        else:
            acg_raw.phase_complete(rwdts.AppconfPhase.REGISTER)
            self._appconf_groups.append(acg)

    @contextlib.contextmanager
    def transaction(self, flags=0):
        """
        Context manager which creates a new transaction.  While within the context, new
        block may be added to the transaction.  Upon exiting, the transaction will be
        committed.

        @param flags  - RwDts.Flag
        @return       - new Transaction instance

        Sample Usage:
        with dts.transaction() as xact:
            some_registration.create_element(xpath, msg, xact)
        """
        def on_xact_event(raw_xact, status, _):
            print('-'*40, raw_xact, evt)

        # RIFT-6475
        raw_xact = self._dts.xact_create(flags, None, None)
        xact = Transaction(raw_xact, self._loop)

        try:
            yield xact
        except TransactionAborted as e:
            raw_xact.abort(rwtypes.RwStatus.FAILURE, str(e))

        raw_xact.commit()

    @contextlib.contextmanager
    def group_create(self, handler=None):
        """
        Context manager which wraps creating group member registrations. All
        registrations should be done within the context. During exit, we signal
        the end of registrations by setting the REGISTER flag.

        @param handler  - Group.Handler
        @return         - Group instance (A wrapper over the group
            register GI object)

        """
        if handler is None:
            handler = Group.Handler()

        adapter = GroupEventAdapter(handler, self)

        status, group_reg_raw = self._dts.group_create(
                adapter.on_init(),
                adapter.on_deinit(),
                adapter.on_event(),)

        if status != rwtypes.RwStatus.SUCCESS:
            raise IOError('Failed to create an registration group')

        group_reg = Group(group_reg_raw, self)

        # Once we have the registration handle(Group instance), we
        # need it for callbacks such as on_event/on_init present in the
        # Adapter.
        adapter.registration = group_reg

        try:
            yield group_reg
        except:
            # There doesn't seem to be any deinit/free api for group register
            raise
        else:
            group_reg_raw.phase_complete(rwdts.GroupPhase.REGISTER)
            self._group_regs.append(group_reg)

 
    def convert_to_keyspec(self, xpath):
        """
        Covert the given xpath to keyspec based on the schema in API handle

        @param xpath  - xpath to be converted

        """
        keyspec = RwKeyspec.path_from_xpath(self.schema, xpath, RwKeyspec.RwXpathType.KEYSPEC)
        return keyspec

# vim: sw=4
