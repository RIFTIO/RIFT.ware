
/*
 * 
 * (c) Copyright RIFT.io, 2013-2016, All Rights Reserved
 *
 *
 */

/*
 * Skeletal functions can be autogenerated 
 */
#include<stdio.h> 
#include<string.h> 
#include<sys/socket.h>
#include<sys/queue.h>
#include<errno.h>
#include<netdb.h>
#include<arpa/inet.h>
#define IP_LEN 46
#include "rwlogd_default_sink.hpp"
#include "rwlogd_sink_common.hpp"
#include "rw_namespace.h"

//const int size_of_syslog 256;
#define CLI_MAX_SZ 4096
/********************************************
 * Default   Realtime Class
 ********************************************/

void print_hdr(rwlog_hdr_t *hdr)
{
  printf("%-10s %-10s %-10s %-10s %-10s\n",
         "tv_sec", "tv_usec", "elem_id", "log_category", "log_severity");
}
void print (rwlog_hdr_t *hdr)
{
  printf("%-10d %-10d %-10d %-10d %-10d\n",
         hdr->tv_sec, hdr->tv_usec, hdr->schema_id.tag, hdr->log_category, hdr->log_severity);
}


bool cmp_logts(rwlog_hdr_t *v1, rwlog_hdr_t *v2)
{

#if 1
  if(v1->time < v2->time) {
    return TRUE;
  } else if(v1->time > v2->time) {
    return FALSE;
  }
#else
  if (v1->tv_sec && v2->tv_sec) {
    if(v1->tv_sec < v2->tv_sec) {
     return TRUE;
    }else if(v1->tv_sec >  v2->tv_sec) {
     return FALSE;
    }
  }
  if (v1->tv_usec && v2->tv_usec) {
    if(v1->tv_usec < v2->tv_usec) {
      return TRUE;
    }
    else if (v1->tv_usec > v2->tv_usec) {
     return FALSE;
    }
  }
#endif
  if (v1->hostname[0] && v2->hostname[0] ) {
    int res = strncmp(v1->hostname,v2->hostname,sizeof(v1->hostname));
    if(res < 0) {
      return TRUE;
    }
    else if(res > 0) {
      return FALSE;
    }
  }
  if (v1->process_id && v2->process_id) {
    if(v1->process_id < v2->process_id) {
      return TRUE;
    }
    else if(v1->process_id > v2->process_id) {
      return FALSE;
    }
  }
  if (v1->thread_id && v2->thread_id) {
    if(v1->thread_id < v2->thread_id) {
      return TRUE;
    }
    else if(v1->thread_id > v2->thread_id) {
      return FALSE;
    }
  }
  if (v1->seqno && v2->seqno) {
    if(v1->seqno < v2->seqno) {
      return TRUE;
    }
    else if(v1->seqno > v2->seqno) {
      return FALSE;
    }
  }
  return FALSE;
}

bool cmp_match_logts(rwlog_hdr_t *v1, rwlog_hdr_t *v2)
{
  if (v1->tv_sec != v2->tv_sec || v1->tv_usec != v2->tv_usec ||
       v1->seqno != v2->seqno || v1->process_id != v2->process_id ||
        v1->thread_id != v2->thread_id) {
    return 0;
  }
  if(strncmp(v1->hostname, v2->hostname,sizeof(v1->hostname))) {
     return 0;
  }
  return 1;
}


rwlogd_default_sink::rwlogd_default_sink(const char *sink_name) 
{
  strncpy(sink_name_, sink_name,SINKNAMESZ);
  log_ring_ = new log_ring_t(CIRCULAR_BUFFER_FACTOR*CLI_MAX_LOG_LINES,cmp_logts);
  set_state (CONNECTED);
}

rwlog_status_t rwlogd_default_sink::pre_process_evlog(uint8_t *proto)
{
  /* Send filter matched for now for default sink till we find way 
   * to configure filters */
  return RWLOG_FILTER_MATCHED;
}

int rwlogd_default_sink::post_evlog(uint8_t *buffer)
{
  log_filter_matched++;
  add_log_to_ring(buffer);
  return 1;
}
void rwlogd_default_sink::rwlog_dump_info(int verbose)
{
  rwlogd_rt_sink_conn::rwlog_dump_info(verbose);
  log_ring_->rwlog_dump_info(verbose);
}

void rwlogd_default_sink::get_log_ring_stats(ring_buffer_stats_t *stats)
{
  stats->inserts = log_ring_->inserts_;
  stats->removal_success = log_ring_->removal_success_;
  stats->removal_failure = log_ring_->removal_failure_;
  stats->cur_size = log_ring_->cur_size_;
  stats->max_size = log_ring_->max_size_;
}


void rwlogd_default_sink::poll()
{
}
  // Log Ring APIs
rw_status_t rwlogd_default_sink::add_log_to_ring(uint8_t *buffer)
{
  int position = log_ring_->add((rwlog_hdr_t *)buffer);
 
  position = position; /* supress unused variable compilation warning */
  if(((rwlog_hdr_t *)buffer)->magic!=RWLOG_MAGIC)
  {
     RW_CRASH_MESSAGE("add_log_to_ring:bad buffer magic");
     return RW_STATUS_FAILURE;
  }
  RWLOG_DEBUG_PRINT("add_log_to_ring @ %d C%d S%d\n",
                    position,
                    (int)(((rwlog_hdr_t *)buffer)->log_category),
                    (int)(((rwlog_hdr_t *)buffer)->seqno));
#if 0
  printf("add_log_to_ring @ %d P%d C%d S%lu, sec: %u usec: %u\n",
                    position,
                    position%CLI_MAX_LOG_LINES,
                    ((rwlog_hdr_t *)buffer)->log_category,
                    ((rwlog_hdr_t *)buffer)->seqno,
                    ((rwlog_hdr_t *)buffer)->tv_sec,
                    ((rwlog_hdr_t *)buffer)->tv_usec);
#endif

  return RW_STATUS_SUCCESS;
}

void rwlogd_default_sink::remove_log_from_ring(uint8_t *buffer)
{
#if 0
  printf("remove_log_from_ring @ C%d S%lu, sec: %u usec: %u\n",
                    ((rwlog_hdr_t *)buffer)->log_category,
                    ((rwlog_hdr_t *)buffer)->seqno,
                    ((rwlog_hdr_t *)buffer)->tv_sec,
                    ((rwlog_hdr_t *)buffer)->tv_usec);
#endif

  log_ring_->remove((rwlog_hdr_t *)buffer,cmp_match_logts);
  return;
}

void rwlogd_default_sink::clear_log_from_ring()
{
#if 0
  printf("clear_log_from_ring\n");
#endif

  log_ring_->clear();
  return;
}

rwlog_status_t rwlogd_default_sink::match_category_severity(uint8_t *log_hdr,
                   uint32_t filter_cat,
                   rwlogd_filter &filter)
{
  uint32_t log_cat = (uint32_t )((rwlog_hdr_t *)log_hdr)->log_category;
  if((log_cat < 0) ||
     (log_cat>filter.filter_hdr_.num_categories)) 
  { 
    return RWLOG_FILTER_DROP;
  }
  if ((filter_cat != RW_LOG_LOG_CATEGORY_ALL) &&
      (filter_cat != log_cat))
  {
    RWLOG_DEBUG_PRINT("Cat did not  matched log_cat%d sent_cat%d \n",
                      log_cat, filter_cat);
    return RWLOG_FILTER_DROP;
  }
  rwlog_severity_t severity = (rwlog_severity_t ) ((rwlog_hdr_t *)log_hdr)->log_severity;
  if (filter.check_severity(severity, log_cat)== RWLOG_FILTER_MATCHED) {
    return RWLOG_FILTER_MATCHED;
  }
  return RWLOG_FILTER_DROP;
}
rwlog_status_t rwlogd_default_sink::match_timestamp (uint8_t *buffer, 
                     struct timeval *start_time,
                     struct timeval *end_time)
{
  /* Short-circuit; timestamp is bodged into header to avoid parsing entirely */
  if (!start_time->tv_sec && !start_time->tv_usec &&
      !end_time->tv_sec && !end_time->tv_usec) 
  {
    return RWLOG_CHECK_MORE_FILTERS;
  }
  uint32_t ev_sec = ((rwlog_hdr_t *)buffer)->tv_sec;
  uint32_t ev_usec  = ((rwlog_hdr_t *)buffer)->tv_usec;
  if (ev_sec) 
  {
    if (start_time->tv_sec || start_time->tv_usec)
    {
    if ((ev_sec < start_time->tv_sec) ||
       (ev_sec == start_time->tv_sec && 
        ev_usec < start_time->tv_usec))
    {
      RWLOG_DEBUG_PRINT("short-cut start-time %d %d %d %d \n", 
             (int)start_time->tv_sec, 
             (int)start_time->tv_usec,
             ev_sec,
             ev_usec);
      return RWLOG_FILTER_DROP;
    }
    }
    if(end_time->tv_sec || end_time->tv_usec)
    {
    if ((ev_sec > end_time->tv_sec) ||
       (ev_sec == end_time->tv_sec && 
        ev_usec > end_time->tv_usec))
    {
      RWLOG_DEBUG_PRINT("short-cut end-time\n");
      return RWLOG_FILTER_DROP;
    }
    }
  }
  return RWLOG_CHECK_MORE_FILTERS;
}
rwlog_status_t rwlogd_default_sink::match_cid(uint8_t *log, uint64_t cid, uint64_t cgid)
{
  // find the field name within the message
  if (!cid && !cgid)
  {
    return RWLOG_CHECK_MORE_FILTERS;
  }
  uint64_t callid  = ((rwlog_hdr_t *)log)->cid.callid;
  uint64_t groupid = ((rwlog_hdr_t *)log)->cid.groupid;

  if(callid == (uint64_t)-1 || groupid == (uint64_t)-1)
  {
    RWLOG_DEBUG_PRINT(" Python CID log. Go to slow path");
  }
  else
  {
    if ((cid && cid != callid) ||
        (cgid && cgid != groupid))
    {
       RWLOG_DEBUG_PRINT("No Response %lu %lu %lu %lu \n",
                     cid,
                     callid,
                     cgid,
                     groupid);
       return RWLOG_FILTER_DROP;
    }
  }
  return RWLOG_CHECK_MORE_FILTERS;
}

/*!
 * This function compare msg-id of the log from ring buffer with that from mgmt API
 * Used as part of show-log <filter-options> CLI to filter logs to be displayed
 * for implementing a get-next logic.  Returns matched only the log in buffer
 * is greater than the supplied key
 * @param [in] msg_id_key - input key from mgmt API
 * @param [in] common_params - common parameter header of log event 
 * @result  returns 0 when not matched and 1 when match successful
 *
 */
rwlog_status_t rwlogd_default_sink::match_msgid(uint8_t *buffer,
                                     rwlog_msg_id_key_t  *msg_id_key)
{
  if (!msg_id_key) {
    return RWLOG_CHECK_MORE_FILTERS;
  }
  rwlog_hdr_t *hdr= (rwlog_hdr_t *)buffer;
  bool field_present = FALSE;
  rwlog_status_t retval = RWLOG_FILTER_MATCHED;

  if (hdr->tv_sec && msg_id_key->tv_sec) {
    field_present = TRUE;
    if (hdr->tv_sec > msg_id_key->tv_sec)  {
      return RWLOG_FILTER_MATCHED;
    }
    if (hdr->tv_sec < msg_id_key->tv_sec)  {
      return RWLOG_FILTER_DROP; //NO_LOG
    }
    if (hdr->tv_usec > msg_id_key->tv_usec) {
      return RWLOG_FILTER_MATCHED;
    }
    if (hdr->tv_usec < msg_id_key->tv_usec) {
      return RWLOG_FILTER_DROP; //NO_LOG
    }
  }

  /// FIXME: check hostname in gethostname 
  if (msg_id_key->hostname[0] && hdr->hostname[0]) {
    int result;
    field_present = TRUE;
    result = strcmp(msg_id_key->hostname, hdr->hostname);
    if (result > 0 ) {
      retval = RWLOG_FILTER_MATCHED;
      goto proc_exit;
    }
    if ( result < 0 ) {
      retval = RWLOG_FILTER_DROP; //NO_LOG
      goto proc_exit;
    }
  }

  if (msg_id_key->pid && hdr->process_id) {
    field_present = TRUE;
    if (hdr->process_id < msg_id_key->pid) { 
      retval = RWLOG_FILTER_DROP; //NO_LOG
      goto proc_exit;
    }
    if (hdr->process_id > msg_id_key->pid) { 
      retval = RWLOG_FILTER_MATCHED;
      goto proc_exit;
    }
  }

  if (msg_id_key->tid && hdr->thread_id == TRUE) {
    field_present = TRUE;
    if (hdr->thread_id < msg_id_key->tid) {
      retval = RWLOG_FILTER_DROP; //NO_LOG
      goto proc_exit;
    }
    if (hdr->thread_id > msg_id_key->tid) {
      retval = RWLOG_FILTER_MATCHED;
      goto proc_exit;
    }
  }

  if (hdr->seqno && msg_id_key->seqno) {
    field_present = TRUE;
    if (hdr->seqno < msg_id_key->seqno) {
      retval = RWLOG_FILTER_DROP; //NO_LOG
      goto proc_exit;
    }
    if (hdr->seqno > msg_id_key->seqno) {
      retval = RWLOG_FILTER_MATCHED;
      goto proc_exit;
    }
  }

  if (field_present == TRUE) {
      retval = RWLOG_FILTER_DROP; //NO_LOG
  }

proc_exit:
  return(retval);
}

/*!
 * Check if the log belongs to check pointed (inactive) circular buffer
 * and return the result
 * @param   - buffer - pointer to the log event
 * @param   - inactive_buffer - pointer to check pointed circular buffer 
 * @param   - inactive_size - checkpointed circular buffer size
 * @returns - filter matched/dropped based on if log belogns to chkpt or not
 */
rwlog_status_t rwlogd_default_sink::match_inactive_logs(char *buffer,
                                        char *inactive_buffer, uint32_t inactive_size)
{
    if (inactive_buffer && buffer >= inactive_buffer && buffer < inactive_buffer+inactive_size) {
      return(RWLOG_FILTER_MATCHED);
    } 
   return(RWLOG_FILTER_DROP);
}

rw_status_t rwlogd_default_sink::get_position(int &pos,struct timeval *start_time)
{
  rwlog_hdr_t log_hdr;
  log_hdr.magic =  RWLOG_MAGIC;
  log_hdr.tv_sec = start_time->tv_sec;
  log_hdr.tv_usec = start_time->tv_usec;
  log_hdr.process_id = 0;
  log_hdr.thread_id = 0;
  log_hdr.seqno = 0;
  log_hdr.hostname[0] = '\0';
  int position = log_ring_->get_position(&log_hdr);
  if (position == -1 ) 
  {
    return RW_STATUS_FAILURE;
  }
  pos = position;
  return RW_STATUS_SUCCESS;
}

rwlog_status_t rwlogd_default_sink::apply_retrieve_filter(rwlog_hdr_t *hdr,
                                                          rwlogd_output_specifier_t *output_spec,
                                                          rwlogd_filter &local_filter)
{
  rwlog_status_t filter_status = match_timestamp((uint8_t *)hdr,&output_spec->start_time, &output_spec->end_time);
  if(filter_status != RWLOG_FILTER_DROP)
  {
    filter_status = match_cid((uint8_t *)hdr, output_spec->callid, output_spec->callgroupid);
  }
  if(filter_status != RWLOG_FILTER_DROP)
  {
    filter_status = match_category_severity((uint8_t *)hdr, output_spec->cat, local_filter);
  }
  if(filter_status != RWLOG_FILTER_DROP)
  {
    filter_status = match_msgid((uint8_t *)hdr, &output_spec->input_msg_id);
  }
  if ((filter_status != RWLOG_FILTER_DROP) && output_spec->has_inactive_logs) 
  {
    filter_status = match_inactive_logs((char *)hdr, output_spec->inactive_log_buffer,
                                                        output_spec->inactive_log_size);
  }
  if(filter_status != RWLOG_FILTER_DROP)
  {
    // Check attributes.. 
  }
  return filter_status;
}
int rwlogd_default_sink::showlog_get_string(uint8_t *proto,
                                    char *string,
                                    size_t string_sz,
                                    rwlogd_filter &filter,
                                    rwlog_msg_id_key_t  *msg_id,
                                    size_t id_string_sz,
                                    char *pdu_dump,
                                    char *pdu_hex_dump,
                                    int verbosity)
{
  ProtobufCMessage *arrivingmsg = rwlogd_sink_data::get_unpacked_proto(proto);
  if(!arrivingmsg)
  {
    return 0;
    //GTEST
  }
  int len =0;
  if(filter.protocol_filter_set_ && (check_protocol_filter(arrivingmsg,(rwlog_hdr_t *)proto,filter) != RWLOG_FILTER_MATCHED)) {
    return 0;
  }

  if(check_filter_attributes(arrivingmsg, (rwlog_hdr_t *)proto, filter) != RWLOG_FILTER_DROP)
  {
    std::ostringstream os;
    fill_common_attributes(arrivingmsg, (rwlog_hdr_t *)proto, os, msg_id);
    fill_attributes(arrivingmsg, os, pdu_dump, pdu_hex_dump, verbosity);
    len = os.str().length();
    strncpy(string, os.str().c_str(), string_sz);
    if (len >= (int)string_sz) 
    {
      len = string_sz-1;
    }
    string[len] = '\0';
  }
  rwlogd_sink_data::free_proto(arrivingmsg);
  return len;
}

rw_status_t rwlogd_default_sink::get_log(int &pos,rwlogd_output_specifier_t *output_spec)
{
  uint8_t *buffer = (uint8_t *)log_ring_->get(pos);
  if (!buffer)
  {
    return RW_STATUS_FAILURE;
  }

  rwlog_hdr_t *log_hdr = (rwlog_hdr_t *)buffer;

  /* If VNF-ID is present in request and doesnt match log hdr return no log */
  if(!uuid_is_null(output_spec->vnf_id) && uuid_compare(log_hdr->vnf_id,output_spec->vnf_id)) {
    return RW_STATUS_NO_RESPONSE;
  }


  rwlogd_filter *retrieve_filter = (rwlogd_filter *)output_spec->show_filter_ptr;
  rwlog_status_t filter_status = apply_retrieve_filter(log_hdr,output_spec, *retrieve_filter);

  RWLOG_DEBUG_PRINT("get_log @ %d C%d S%d\n",
                    pos,
                    (int)(((rwlog_hdr_t *)buffer)->log_category),
                    (int)(((rwlog_hdr_t *)buffer)->seqno));

  int len=0;

  if (filter_status != RWLOG_FILTER_DROP)
  {
    // No one told to drop. Show
    len = showlog_get_string(buffer,
                        output_spec->log_line,
                        RWLOGD_LOG_LINE_LEN,
                        *retrieve_filter,
                        &output_spec->msg_id,
                        RWLOGD_LOG_MSG_ID_LEN, 
                        output_spec->pdu_dump,
                        output_spec->pdu_hex_dump,
                        output_spec->verbosity);
  }
  if(len== 0)
  {
    return RW_STATUS_NO_RESPONSE; //NO_LOG
  }
  if(len== -1)
  {
    return RW_STATUS_FAILURE; //EOL
  }
  return RW_STATUS_SUCCESS; //LOG_OK
}

rw_status_t rwlogd_default_sink::get_log_trailing_timestamp(int pos, char *buf, size_t buf_sz) 
{
  uint8_t *buffer; 
  buffer = (uint8_t *) log_ring_->get(pos);
  if (buf && buffer) 
  {
    time_t evtime = ((rwlog_hdr_t *)buffer)->tv_sec;

    if (evtime) {
      struct timeval tv = {
        .tv_sec = ((rwlog_hdr_t *)buffer)->tv_sec,
        .tv_usec = ((rwlog_hdr_t *)buffer)->tv_usec
      };

      ++tv.tv_usec;
      if (tv.tv_usec > 1000000) {
        tv.tv_usec = 0;
        tv.tv_sec++;
      }

      char tmstr[128];
      tmstr[0]='\0';

      struct tm* tm = gmtime(&tv.tv_sec);
      strftime(tmstr, sizeof(tmstr), "%Y-%m-%dT%H:%M:%S", tm);
      int bytes = snprintf(buf, buf_sz, "%s.%06luZ", tmstr, tv.tv_usec);
      RW_ASSERT(bytes < (int)buf_sz && bytes != -1);

      return RW_STATUS_SUCCESS;
    }
  }

  return RW_STATUS_FAILURE;
}

/*****************************************
 * APis to add the Sinks to the Rwlogd 
 *****************************************/
// Call for CLI 

extern "C" rw_status_t rwlogd_create_default_sink(rwlogd_instance_ptr_t inst, const char *name)
{
  rwlogd_sink_data *obj = rwlogd_get_sink_obj (inst);
  rwlogd_sink *sink = obj->lookup_sink(name);
  if (sink) 
  {
    RWLOG_FILTER_DEBUG_PRINT("SINK MATCHED****** %s\n", name);
    return RW_STATUS_DUPLICATE;
  }
  rwlogd_default_sink *conn = new rwlogd_default_sink(name);
  obj->add_sink(conn);
  obj->default_sink = conn;
  return RW_STATUS_SUCCESS;
}

extern "C" rw_status_t rwlogd_delete_default_sink(rwlogd_instance_ptr_t inst, const char *sink_name)
{
  rwlogd_sink_data *obj = rwlogd_get_sink_obj (inst);
  rwlogd_sink *conn = obj->remove_sink(sink_name);
  obj->default_sink = NULL;
  if (conn)
  {
    delete (conn);
    return RW_STATUS_SUCCESS;
  }
  return RW_STATUS_NOTFOUND;
}

extern "C" rw_status_t rwlogd_remove_log_from_default_sink(rwlogd_instance_ptr_t inst, rwlog_hdr_t *log_hdr)
{
  rwlogd_sink_data *obj = rwlogd_get_sink_obj (inst);
  rwlogd_sink *sink = obj->default_sink;
  if(sink) {
    sink->remove_log_from_ring((uint8_t *)log_hdr);
  }
  return RW_STATUS_SUCCESS;
}

