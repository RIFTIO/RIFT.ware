
/*
 * 
 * (c) Copyright RIFT.io, 2013-2016, All Rights Reserved
 *
 *
 */

/*
 * Skeletal functions can be autogenerated 
 */
#include<stdio.h> 
#include<string.h> 
#include<sys/socket.h>
#include<sys/queue.h>
#include<errno.h>
#include<netdb.h>
#include<arpa/inet.h>
#define IP_LEN 46
#include "rwlogd_cli_sink.hpp"
#include "rwlogd_sink_common.hpp"

//const int size_of_syslog 256;
#define CLI_MAX_SZ 4096
/********************************************
 * Cli  Realtime Class
 ********************************************/
enum connection_type {
  MSNGR,
  TCP,
  UDP,
  SCTP,
  NETCONF
};

typedef struct {
  connection_type _type;
} cli_connection_params_t;

class cli_conn : public rwlogd_rt_sink_conn {
private:
  cli_connection_params_t _connection_params;
  char *cli_dest_path;
  rwmsg_destination_t *dest;
  rwmsg_clichan_t *log_cli_chan;
  Rwlogd_Client *log_cli;

public:
  cli_conn(const char *sink_name, 
           const char *hostname,
           uint32_t port,
           void *connection_params = NULL)
  {
    strncpy(sink_name_, sink_name,SINKNAMESZ);
    set_state (INIT);
    rwlogd_instance_ptr_t inst_data = (rwlogd_instance_s*)connection_params;

    int r = asprintf (&cli_dest_path, "/R/%s/%d", hostname, port);
    RW_ASSERT(r);
    if (!r) {
      return;
    }
    // Create Destination
    dest = rwmsg_destination_create(
        inst_data->rwtasklet_info->rwmsg_endpoint,
        RWMSG_ADDRTYPE_UNICAST,
        cli_dest_path);
    // Create endpoint
    log_cli_chan = inst_data->cc;
    log_cli = &inst_data->rwlogd_cli; 
    set_state (CONNECTED);
  }
  virtual ~cli_conn()
  {
    rwmsg_destination_release(dest);
    free (cli_dest_path);
  }
  virtual int post_evlog(uint8_t *proto)
  {
    rw_status_t status = RW_STATUS_SUCCESS;
    char string[CLI_MAX_SZ];
    int len  = convert_log_to_str(proto, string, CLI_MAX_SZ);
    if (len < 1)
    {
      return 1;
    }
    log_filter_matched++;
    RwlogdRegisterReq *req = 
        (RwlogdRegisterReq *)malloc(sizeof(RwlogdRegisterReq));
    rwlogd_register_req__init(req);
    req->my_key = strdup(string);
    RW_ASSERT(req); 
    if (!req) {
      return (0);
    }
    //Now send the message
    char *env = getenv("__RWLOG_CLI_SINK_GTEST_PRINT_LOG__");
    if (!env)
    {
      rwmsg_closure_t clo = { {.pbrsp = NULL} ,.ud = NULL };
      status = rwlogd__register_client(log_cli, dest, req, &clo, NULL);
    }
    else
    {
      if(string[0]!='\0')
      {
        printf("%s\n",string);
      }
      status = RW_STATUS_SUCCESS;
    }
    RW_ASSERT (status != RW_STATUS_FAILURE);
    free(req->my_key);
    free(req);
    return 1;
  }
  virtual void rwlog_dump_info(int verbose)
  {
    printf("Cli dest path = %s\n", cli_dest_path);
    rwlogd_rt_sink_conn::rwlog_dump_info(verbose);
  }
  void poll()
  {
  }
}; 

/*****************************************
 * APis to add the Sinks to the Rwlogd 
 *****************************************/
// Call for CLI 

extern "C" rw_status_t start_rwlogd_cli_sink(rwlogd_instance_ptr_t inst, const char *name, const char *host, int port)
{
  rwlogd_sink_data *obj = rwlogd_get_sink_obj (inst);
  rwlogd_sink *sink = obj->lookup_sink(name);
  if (sink) 
  {
    RWLOG_FILTER_DEBUG_PRINT("SINK MATCHED****** %s\n", name);
    return RW_STATUS_DUPLICATE;
  }
  cli_conn *conn = new cli_conn(name, host, port, inst);
  obj->add_sink(conn);
  return RW_STATUS_SUCCESS;
}

extern "C" rw_status_t stop_rwlogd_cli_sink(rwlogd_instance_ptr_t inst, const char *sink_name, const char *host, int port)
{
  rwlogd_sink_data *obj = rwlogd_get_sink_obj (inst);
  rwlogd_sink *conn = obj->remove_sink(sink_name);
  if (conn)
  {
    delete (conn);
    return RW_STATUS_SUCCESS;
  }
  return RW_STATUS_NOTFOUND;
}
