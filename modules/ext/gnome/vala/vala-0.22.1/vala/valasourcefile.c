/* valasourcefile.c generated by valac, the Vala compiler
 * generated from valasourcefile.vala, do not modify */

/* valasourcefile.vala
 *
 * Copyright (C) 2006-2009  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <valagee.h>
#include <glib/gstdio.h>
#include <gobject/gvaluecollector.h>


#define VALA_TYPE_SOURCE_FILE (vala_source_file_get_type ())
#define VALA_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFile))
#define VALA_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))
#define VALA_IS_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_FILE))
#define VALA_IS_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_FILE))
#define VALA_SOURCE_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))

typedef struct _ValaSourceFile ValaSourceFile;
typedef struct _ValaSourceFileClass ValaSourceFileClass;
typedef struct _ValaSourceFilePrivate ValaSourceFilePrivate;

#define VALA_TYPE_SOURCE_FILE_TYPE (vala_source_file_type_get_type ())

#define VALA_TYPE_CODE_CONTEXT (vala_code_context_get_type ())
#define VALA_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContext))
#define VALA_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))
#define VALA_IS_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_CONTEXT))
#define VALA_IS_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_CONTEXT))
#define VALA_CODE_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))

typedef struct _ValaCodeContext ValaCodeContext;
typedef struct _ValaCodeContextClass ValaCodeContextClass;

#define VALA_TYPE_COMMENT (vala_comment_get_type ())
#define VALA_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_COMMENT, ValaComment))
#define VALA_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_COMMENT, ValaCommentClass))
#define VALA_IS_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_COMMENT))
#define VALA_IS_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_COMMENT))
#define VALA_COMMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_COMMENT, ValaCommentClass))

typedef struct _ValaComment ValaComment;
typedef struct _ValaCommentClass ValaCommentClass;

#define VALA_TYPE_CODE_NODE (vala_code_node_get_type ())
#define VALA_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_NODE, ValaCodeNode))
#define VALA_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))
#define VALA_IS_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_NODE))
#define VALA_IS_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_NODE))
#define VALA_CODE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))

typedef struct _ValaCodeNode ValaCodeNode;
typedef struct _ValaCodeNodeClass ValaCodeNodeClass;

#define VALA_TYPE_USING_DIRECTIVE (vala_using_directive_get_type ())
#define VALA_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirective))
#define VALA_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))
#define VALA_IS_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_USING_DIRECTIVE))
#define VALA_IS_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_USING_DIRECTIVE))
#define VALA_USING_DIRECTIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))

typedef struct _ValaUsingDirective ValaUsingDirective;
typedef struct _ValaUsingDirectiveClass ValaUsingDirectiveClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))
#define _g_mapped_file_free0(var) ((var == NULL) ? NULL : (var = (g_mapped_file_free (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))

#define VALA_TYPE_CODE_VISITOR (vala_code_visitor_get_type ())
#define VALA_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitor))
#define VALA_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))
#define VALA_IS_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_VISITOR))
#define VALA_IS_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_VISITOR))
#define VALA_CODE_VISITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))

typedef struct _ValaCodeVisitor ValaCodeVisitor;
typedef struct _ValaCodeVisitorClass ValaCodeVisitorClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define VALA_TYPE_SOURCE_REFERENCE (vala_source_reference_get_type ())
#define VALA_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReference))
#define VALA_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))
#define VALA_IS_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_IS_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_SOURCE_REFERENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))

typedef struct _ValaSourceReference ValaSourceReference;
typedef struct _ValaSourceReferenceClass ValaSourceReferenceClass;
typedef struct _ValaParamSpecSourceFile ValaParamSpecSourceFile;

struct _ValaSourceFile {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaSourceFilePrivate * priv;
};

struct _ValaSourceFileClass {
	GTypeClass parent_class;
	void (*finalize) (ValaSourceFile *self);
};

typedef enum  {
	VALA_SOURCE_FILE_TYPE_NONE,
	VALA_SOURCE_FILE_TYPE_SOURCE,
	VALA_SOURCE_FILE_TYPE_PACKAGE,
	VALA_SOURCE_FILE_TYPE_FAST
} ValaSourceFileType;

struct _ValaSourceFilePrivate {
	gchar* _filename;
	ValaSourceFileType _file_type;
	gboolean _from_commandline;
	gchar* _gir_namespace;
	gchar* _gir_version;
	ValaCodeContext* _context;
	gboolean _used;
	ValaArrayList* comments;
	ValaList* _current_using_directives;
	ValaList* nodes;
	gchar* _relative_filename;
	gchar* csource_filename;
	gchar* cinclude_filename;
	ValaArrayList* source_array;
	GMappedFile* mapped_file;
	gchar* _content;
};

struct _ValaParamSpecSourceFile {
	GParamSpec parent_instance;
};


static gpointer vala_source_file_parent_class = NULL;

gpointer vala_source_file_ref (gpointer instance);
void vala_source_file_unref (gpointer instance);
GParamSpec* vala_param_spec_source_file (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_file (GValue* value, gpointer v_object);
void vala_value_take_source_file (GValue* value, gpointer v_object);
gpointer vala_value_get_source_file (const GValue* value);
GType vala_source_file_get_type (void) G_GNUC_CONST;
GType vala_source_file_type_get_type (void) G_GNUC_CONST;
gpointer vala_code_context_ref (gpointer instance);
void vala_code_context_unref (gpointer instance);
GParamSpec* vala_param_spec_code_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_context (GValue* value, gpointer v_object);
void vala_value_take_code_context (GValue* value, gpointer v_object);
gpointer vala_value_get_code_context (const GValue* value);
GType vala_code_context_get_type (void) G_GNUC_CONST;
gpointer vala_comment_ref (gpointer instance);
void vala_comment_unref (gpointer instance);
GParamSpec* vala_param_spec_comment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_comment (GValue* value, gpointer v_object);
void vala_value_take_comment (GValue* value, gpointer v_object);
gpointer vala_value_get_comment (const GValue* value);
GType vala_comment_get_type (void) G_GNUC_CONST;
gpointer vala_code_node_ref (gpointer instance);
void vala_code_node_unref (gpointer instance);
GParamSpec* vala_param_spec_code_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_node (GValue* value, gpointer v_object);
void vala_value_take_code_node (GValue* value, gpointer v_object);
gpointer vala_value_get_code_node (const GValue* value);
GType vala_code_node_get_type (void) G_GNUC_CONST;
GType vala_using_directive_get_type (void) G_GNUC_CONST;
#define VALA_SOURCE_FILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALA_TYPE_SOURCE_FILE, ValaSourceFilePrivate))
enum  {
	VALA_SOURCE_FILE_DUMMY_PROPERTY
};
ValaSourceFile* vala_source_file_new (ValaCodeContext* context, ValaSourceFileType type, const gchar* filename, const gchar* content, gboolean cmdline);
ValaSourceFile* vala_source_file_construct (GType object_type, ValaCodeContext* context, ValaSourceFileType type, const gchar* filename, const gchar* content, gboolean cmdline);
void vala_source_file_set_context (ValaSourceFile* self, ValaCodeContext* value);
void vala_source_file_set_file_type (ValaSourceFile* self, ValaSourceFileType value);
void vala_source_file_set_filename (ValaSourceFile* self, const gchar* value);
void vala_source_file_set_content (ValaSourceFile* self, const gchar* value);
void vala_source_file_set_from_commandline (ValaSourceFile* self, gboolean value);
void vala_source_file_add_comment (ValaSourceFile* self, ValaComment* comment);
ValaList* vala_source_file_get_comments (ValaSourceFile* self);
void vala_source_file_add_using_directive (ValaSourceFile* self, ValaUsingDirective* ns);
ValaList* vala_source_file_get_current_using_directives (ValaSourceFile* self);
void vala_source_file_set_current_using_directives (ValaSourceFile* self, ValaList* value);
void vala_source_file_add_node (ValaSourceFile* self, ValaCodeNode* node);
void vala_source_file_remove_node (ValaSourceFile* self, ValaCodeNode* node);
ValaList* vala_source_file_get_nodes (ValaSourceFile* self);
gpointer vala_code_visitor_ref (gpointer instance);
void vala_code_visitor_unref (gpointer instance);
GParamSpec* vala_param_spec_code_visitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_visitor (GValue* value, gpointer v_object);
void vala_value_take_code_visitor (GValue* value, gpointer v_object);
gpointer vala_value_get_code_visitor (const GValue* value);
GType vala_code_visitor_get_type (void) G_GNUC_CONST;
void vala_source_file_accept (ValaSourceFile* self, ValaCodeVisitor* visitor);
void vala_code_visitor_visit_source_file (ValaCodeVisitor* self, ValaSourceFile* source_file);
void vala_source_file_accept_children (ValaSourceFile* self, ValaCodeVisitor* visitor);
void vala_code_node_accept (ValaCodeNode* self, ValaCodeVisitor* visitor);
static gchar* vala_source_file_get_subdir (ValaSourceFile* self);
ValaCodeContext* vala_source_file_get_context (ValaSourceFile* self);
const gchar* vala_code_context_get_basedir (ValaCodeContext* self);
const gchar* vala_source_file_get_filename (ValaSourceFile* self);
static gchar* vala_source_file_get_destination_directory (ValaSourceFile* self);
const gchar* vala_code_context_get_directory (ValaCodeContext* self);
static gchar* vala_source_file_get_basename (ValaSourceFile* self);
gchar* vala_source_file_get_relative_filename (ValaSourceFile* self);
gchar* vala_source_file_get_csource_filename (ValaSourceFile* self);
gboolean vala_code_context_get_run_output (ValaCodeContext* self);
const gchar* vala_code_context_get_output (ValaCodeContext* self);
gboolean vala_code_context_get_ccode_only (ValaCodeContext* self);
gboolean vala_code_context_get_save_csources (ValaCodeContext* self);
gchar* vala_source_file_get_cinclude_filename (ValaSourceFile* self);
const gchar* vala_code_context_get_header_filename (ValaCodeContext* self);
const gchar* vala_code_context_get_includedir (ValaCodeContext* self);
gchar* vala_source_file_get_source_line (ValaSourceFile* self, gint lineno);
const gchar* vala_source_file_get_content (ValaSourceFile* self);
static void vala_source_file_read_source_lines (ValaSourceFile* self, const gchar* cont);
static void vala_source_file_read_source_file (ValaSourceFile* self);
gchar* vala_source_file_get_mapped_contents (ValaSourceFile* self);
gpointer vala_source_reference_ref (gpointer instance);
void vala_source_reference_unref (gpointer instance);
GParamSpec* vala_param_spec_source_reference (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_reference (GValue* value, gpointer v_object);
void vala_value_take_source_reference (GValue* value, gpointer v_object);
gpointer vala_value_get_source_reference (const GValue* value);
GType vala_source_reference_get_type (void) G_GNUC_CONST;
void vala_report_error (ValaSourceReference* source, const gchar* message);
gsize vala_source_file_get_mapped_length (ValaSourceFile* self);
gboolean vala_source_file_check (ValaSourceFile* self, ValaCodeContext* context);
gboolean vala_code_node_check (ValaCodeNode* self, ValaCodeContext* context);
void vala_source_file_set_relative_filename (ValaSourceFile* self, const gchar* value);
ValaSourceFileType vala_source_file_get_file_type (ValaSourceFile* self);
gboolean vala_source_file_get_from_commandline (ValaSourceFile* self);
const gchar* vala_source_file_get_gir_namespace (ValaSourceFile* self);
void vala_source_file_set_gir_namespace (ValaSourceFile* self, const gchar* value);
const gchar* vala_source_file_get_gir_version (ValaSourceFile* self);
void vala_source_file_set_gir_version (ValaSourceFile* self, const gchar* value);
gboolean vala_source_file_get_used (ValaSourceFile* self);
void vala_source_file_set_used (ValaSourceFile* self, gboolean value);
static void vala_source_file_finalize (ValaSourceFile* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


/**
 * Creates a new source file.
 *
 * @param filename source file name
 * @param pkg      true if this is a VAPI package file
 * @return         newly created source file
 */
ValaSourceFile* vala_source_file_construct (GType object_type, ValaCodeContext* context, ValaSourceFileType type, const gchar* filename, const gchar* content, gboolean cmdline) {
	ValaSourceFile* self = NULL;
	ValaCodeContext* _tmp0_ = NULL;
	ValaSourceFileType _tmp1_ = 0;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (context != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	self = (ValaSourceFile*) g_type_create_instance (object_type);
	_tmp0_ = context;
	vala_source_file_set_context (self, _tmp0_);
	_tmp1_ = type;
	vala_source_file_set_file_type (self, _tmp1_);
	_tmp2_ = filename;
	vala_source_file_set_filename (self, _tmp2_);
	_tmp3_ = content;
	vala_source_file_set_content (self, _tmp3_);
	_tmp4_ = cmdline;
	vala_source_file_set_from_commandline (self, _tmp4_);
	return self;
}


ValaSourceFile* vala_source_file_new (ValaCodeContext* context, ValaSourceFileType type, const gchar* filename, const gchar* content, gboolean cmdline) {
	return vala_source_file_construct (VALA_TYPE_SOURCE_FILE, context, type, filename, content, cmdline);
}


/**
 * Adds a header comment to this source file.
 */
void vala_source_file_add_comment (ValaSourceFile* self, ValaComment* comment) {
	ValaArrayList* _tmp0_ = NULL;
	ValaComment* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (comment != NULL);
	_tmp0_ = self->priv->comments;
	_tmp1_ = comment;
	vala_collection_add ((ValaCollection*) _tmp0_, _tmp1_);
}


/**
 * Returns a copy of the list of header comments.
 *
 * @return list of comments
 */
static gpointer _vala_iterable_ref0 (gpointer self) {
	return self ? vala_iterable_ref (self) : NULL;
}


ValaList* vala_source_file_get_comments (ValaSourceFile* self) {
	ValaList* result = NULL;
	ValaArrayList* _tmp0_ = NULL;
	ValaList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->comments;
	_tmp1_ = _vala_iterable_ref0 ((ValaList*) _tmp0_);
	result = _tmp1_;
	return result;
}


/**
 * Adds a new using directive with the specified namespace.
 *
 * @param ns reference to namespace
 */
void vala_source_file_add_using_directive (ValaSourceFile* self, ValaUsingDirective* ns) {
	ValaList* old_using_directives = NULL;
	ValaList* _tmp0_ = NULL;
	ValaList* _tmp1_ = NULL;
	GEqualFunc _tmp2_ = NULL;
	ValaArrayList* _tmp3_ = NULL;
	ValaArrayList* _tmp4_ = NULL;
	ValaList* _tmp18_ = NULL;
	ValaUsingDirective* _tmp19_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	_tmp0_ = self->priv->_current_using_directives;
	_tmp1_ = _vala_iterable_ref0 (_tmp0_);
	old_using_directives = _tmp1_;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_array_list_new (VALA_TYPE_USING_DIRECTIVE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp2_);
	_tmp4_ = _tmp3_;
	vala_source_file_set_current_using_directives (self, (ValaList*) _tmp4_);
	_vala_iterable_unref0 (_tmp4_);
	{
		ValaList* _using_directive_list = NULL;
		ValaList* _tmp5_ = NULL;
		ValaList* _tmp6_ = NULL;
		gint _using_directive_size = 0;
		ValaList* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gint _using_directive_index = 0;
		_tmp5_ = old_using_directives;
		_tmp6_ = _vala_iterable_ref0 (_tmp5_);
		_using_directive_list = _tmp6_;
		_tmp7_ = _using_directive_list;
		_tmp8_ = vala_collection_get_size ((ValaCollection*) _tmp7_);
		_tmp9_ = _tmp8_;
		_using_directive_size = _tmp9_;
		_using_directive_index = -1;
		while (TRUE) {
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			gint _tmp12_ = 0;
			ValaUsingDirective* using_directive = NULL;
			ValaList* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gpointer _tmp15_ = NULL;
			ValaList* _tmp16_ = NULL;
			ValaUsingDirective* _tmp17_ = NULL;
			_tmp10_ = _using_directive_index;
			_using_directive_index = _tmp10_ + 1;
			_tmp11_ = _using_directive_index;
			_tmp12_ = _using_directive_size;
			if (!(_tmp11_ < _tmp12_)) {
				break;
			}
			_tmp13_ = _using_directive_list;
			_tmp14_ = _using_directive_index;
			_tmp15_ = vala_list_get (_tmp13_, _tmp14_);
			using_directive = (ValaUsingDirective*) _tmp15_;
			_tmp16_ = self->priv->_current_using_directives;
			_tmp17_ = using_directive;
			vala_collection_add ((ValaCollection*) _tmp16_, _tmp17_);
			_vala_code_node_unref0 (using_directive);
		}
		_vala_iterable_unref0 (_using_directive_list);
	}
	_tmp18_ = self->priv->_current_using_directives;
	_tmp19_ = ns;
	vala_collection_add ((ValaCollection*) _tmp18_, _tmp19_);
	_vala_iterable_unref0 (old_using_directives);
}


/**
 * Adds the specified code node to this source file.
 *
 * @param node a code node
 */
void vala_source_file_add_node (ValaSourceFile* self, ValaCodeNode* node) {
	ValaList* _tmp0_ = NULL;
	ValaCodeNode* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = self->priv->nodes;
	_tmp1_ = node;
	vala_collection_add ((ValaCollection*) _tmp0_, _tmp1_);
}


void vala_source_file_remove_node (ValaSourceFile* self, ValaCodeNode* node) {
	ValaList* _tmp0_ = NULL;
	ValaCodeNode* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = self->priv->nodes;
	_tmp1_ = node;
	vala_collection_remove ((ValaCollection*) _tmp0_, _tmp1_);
}


/**
 * Returns a copy of the list of code nodes.
 *
 * @return code node list
 */
ValaList* vala_source_file_get_nodes (ValaSourceFile* self) {
	ValaList* result = NULL;
	ValaList* _tmp0_ = NULL;
	ValaList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->nodes;
	_tmp1_ = _vala_iterable_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


void vala_source_file_accept (ValaSourceFile* self, ValaCodeVisitor* visitor) {
	ValaCodeVisitor* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (visitor != NULL);
	_tmp0_ = visitor;
	vala_code_visitor_visit_source_file (_tmp0_, self);
}


void vala_source_file_accept_children (ValaSourceFile* self, ValaCodeVisitor* visitor) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (visitor != NULL);
	{
		ValaList* _node_list = NULL;
		ValaList* _tmp0_ = NULL;
		ValaList* _tmp1_ = NULL;
		gint _node_size = 0;
		ValaList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _node_index = 0;
		_tmp0_ = self->priv->nodes;
		_tmp1_ = _vala_iterable_ref0 (_tmp0_);
		_node_list = _tmp1_;
		_tmp2_ = _node_list;
		_tmp3_ = vala_collection_get_size ((ValaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_node_size = _tmp4_;
		_node_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ValaCodeNode* node = NULL;
			ValaList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			ValaCodeNode* _tmp11_ = NULL;
			ValaCodeVisitor* _tmp12_ = NULL;
			_tmp5_ = _node_index;
			_node_index = _tmp5_ + 1;
			_tmp6_ = _node_index;
			_tmp7_ = _node_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _node_list;
			_tmp9_ = _node_index;
			_tmp10_ = vala_list_get (_tmp8_, _tmp9_);
			node = (ValaCodeNode*) _tmp10_;
			_tmp11_ = node;
			_tmp12_ = visitor;
			vala_code_node_accept (_tmp11_, _tmp12_);
			_vala_code_node_unref0 (node);
		}
		_vala_iterable_unref0 (_node_list);
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	gboolean _tmp3_ = FALSE;
	glong _tmp9_ = 0L;
	glong _tmp15_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	glong _tmp22_ = 0L;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		glong _tmp12_ = 0L;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_ = 0L;
		glong _tmp14_ = 0L;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_ = 0L;
		glong _tmp17_ = 0L;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gchar* vala_source_file_get_subdir (ValaSourceFile* self) {
	gchar* result = NULL;
	ValaCodeContext* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp4_ = NULL;
	ValaCodeContext* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_ = FALSE;
	gchar* _tmp36_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_context;
	_tmp1_ = vala_code_context_get_basedir (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == NULL) {
		gchar* _tmp3_ = NULL;
		_tmp3_ = g_strdup ("");
		result = _tmp3_;
		return result;
	}
	_tmp4_ = self->priv->_filename;
	_tmp5_ = self->priv->_context;
	_tmp6_ = vala_code_context_get_basedir (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat (_tmp7_, "/", NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_str_has_prefix (_tmp4_, _tmp9_);
	_tmp11_ = _tmp10_;
	_g_free0 (_tmp9_);
	if (_tmp11_) {
		gchar* basename = NULL;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* subdir = NULL;
		const gchar* _tmp14_ = NULL;
		ValaCodeContext* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		const gchar* _tmp20_ = NULL;
		gint _tmp21_ = 0;
		gint _tmp22_ = 0;
		ValaCodeContext* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		gint _tmp26_ = 0;
		gint _tmp27_ = 0;
		const gchar* _tmp28_ = NULL;
		gint _tmp29_ = 0;
		gint _tmp30_ = 0;
		gchar* _tmp31_ = NULL;
		_tmp12_ = self->priv->_filename;
		_tmp13_ = g_path_get_basename (_tmp12_);
		basename = _tmp13_;
		_tmp14_ = self->priv->_filename;
		_tmp15_ = self->priv->_context;
		_tmp16_ = vala_code_context_get_basedir (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = strlen (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = self->priv->_filename;
		_tmp21_ = strlen (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = self->priv->_context;
		_tmp24_ = vala_code_context_get_basedir (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = strlen (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = basename;
		_tmp29_ = strlen (_tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = string_substring (_tmp14_, (glong) _tmp19_, (glong) ((_tmp22_ - _tmp27_) - _tmp30_));
		subdir = _tmp31_;
		while (TRUE) {
			const gchar* _tmp32_ = NULL;
			gchar _tmp33_ = '\0';
			const gchar* _tmp34_ = NULL;
			gchar* _tmp35_ = NULL;
			_tmp32_ = subdir;
			_tmp33_ = string_get (_tmp32_, (glong) 0);
			if (!(_tmp33_ == '/')) {
				break;
			}
			_tmp34_ = subdir;
			_tmp35_ = string_substring (_tmp34_, (glong) 1, (glong) (-1));
			_g_free0 (subdir);
			subdir = _tmp35_;
		}
		result = subdir;
		_g_free0 (basename);
		return result;
	}
	_tmp36_ = g_strdup ("");
	result = _tmp36_;
	return result;
}


static gchar* vala_source_file_get_destination_directory (ValaSourceFile* self) {
	gchar* result = NULL;
	ValaCodeContext* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	ValaCodeContext* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_context;
	_tmp1_ = vala_code_context_get_directory (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == NULL) {
		gchar* _tmp3_ = NULL;
		_tmp3_ = vala_source_file_get_subdir (self);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = self->priv->_context;
	_tmp5_ = vala_code_context_get_directory (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_source_file_get_subdir (self);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_build_path ("/", _tmp6_, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp8_);
	result = _tmp10_;
	return result;
}


static gint string_last_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strrchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* vala_source_file_get_basename (ValaSourceFile* self) {
	gchar* result = NULL;
	gint dot = 0;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filename;
	_tmp1_ = string_last_index_of_char (_tmp0_, (gunichar) '.', 0);
	dot = _tmp1_;
	_tmp2_ = self->priv->_filename;
	_tmp3_ = string_substring (_tmp2_, (glong) 0, (glong) dot);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_path_get_basename (_tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	result = _tmp6_;
	return result;
}


gchar* vala_source_file_get_relative_filename (ValaSourceFile* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_relative_filename;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		_tmp1_ = self->priv->_relative_filename;
		_tmp2_ = g_strdup (_tmp1_);
		result = _tmp2_;
		return result;
	} else {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->_filename;
		_tmp4_ = g_path_get_basename (_tmp3_);
		result = _tmp4_;
		return result;
	}
}


/**
 * Returns the filename to use when generating C source files.
 *
 * @return generated C source filename
 */
gchar* vala_source_file_get_csource_filename (ValaSourceFile* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp30_ = NULL;
	gchar* _tmp31_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->csource_filename;
	if (_tmp0_ == NULL) {
		ValaCodeContext* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		_tmp1_ = self->priv->_context;
		_tmp2_ = vala_code_context_get_run_output (_tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_) {
			ValaCodeContext* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			gchar* _tmp7_ = NULL;
			_tmp4_ = self->priv->_context;
			_tmp5_ = vala_code_context_get_output (_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = g_strconcat (_tmp6_, ".c", NULL);
			_g_free0 (self->priv->csource_filename);
			self->priv->csource_filename = _tmp7_;
		} else {
			gboolean _tmp8_ = FALSE;
			ValaCodeContext* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp15_ = FALSE;
			_tmp9_ = self->priv->_context;
			_tmp10_ = vala_code_context_get_ccode_only (_tmp9_);
			_tmp11_ = _tmp10_;
			if (_tmp11_) {
				_tmp8_ = TRUE;
			} else {
				ValaCodeContext* _tmp12_ = NULL;
				gboolean _tmp13_ = FALSE;
				gboolean _tmp14_ = FALSE;
				_tmp12_ = self->priv->_context;
				_tmp13_ = vala_code_context_get_save_csources (_tmp12_);
				_tmp14_ = _tmp13_;
				_tmp8_ = _tmp14_;
			}
			_tmp15_ = _tmp8_;
			if (_tmp15_) {
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_ = NULL;
				gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_ = NULL;
				gchar* _tmp22_ = NULL;
				_tmp16_ = vala_source_file_get_destination_directory (self);
				_tmp17_ = _tmp16_;
				_tmp18_ = vala_source_file_get_basename (self);
				_tmp19_ = _tmp18_;
				_tmp20_ = g_strconcat (_tmp19_, ".c", NULL);
				_tmp21_ = _tmp20_;
				_tmp22_ = g_build_path ("/", _tmp17_, _tmp21_, NULL);
				_g_free0 (self->priv->csource_filename);
				self->priv->csource_filename = _tmp22_;
				_g_free0 (_tmp21_);
				_g_free0 (_tmp19_);
				_g_free0 (_tmp17_);
			} else {
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				gchar* _tmp29_ = NULL;
				_tmp23_ = vala_source_file_get_destination_directory (self);
				_tmp24_ = _tmp23_;
				_tmp25_ = vala_source_file_get_basename (self);
				_tmp26_ = _tmp25_;
				_tmp27_ = g_strconcat (_tmp26_, ".vala.c", NULL);
				_tmp28_ = _tmp27_;
				_tmp29_ = g_build_path ("/", _tmp24_, _tmp28_, NULL);
				_g_free0 (self->priv->csource_filename);
				self->priv->csource_filename = _tmp29_;
				_g_free0 (_tmp28_);
				_g_free0 (_tmp26_);
				_g_free0 (_tmp24_);
			}
		}
	}
	_tmp30_ = self->priv->csource_filename;
	_tmp31_ = g_strdup (_tmp30_);
	result = _tmp31_;
	return result;
}


/**
 * Returns the filename to use when including the generated C header
 * file.
 *
 * @return C header filename to include
 */
gchar* vala_source_file_get_cinclude_filename (ValaSourceFile* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->cinclude_filename;
	if (_tmp0_ == NULL) {
		ValaCodeContext* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		_tmp1_ = self->priv->_context;
		_tmp2_ = vala_code_context_get_header_filename (_tmp1_);
		_tmp3_ = _tmp2_;
		if (_tmp3_ != NULL) {
			ValaCodeContext* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			gchar* _tmp7_ = NULL;
			ValaCodeContext* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			_tmp4_ = self->priv->_context;
			_tmp5_ = vala_code_context_get_header_filename (_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = g_path_get_basename (_tmp6_);
			_g_free0 (self->priv->cinclude_filename);
			self->priv->cinclude_filename = _tmp7_;
			_tmp8_ = self->priv->_context;
			_tmp9_ = vala_code_context_get_includedir (_tmp8_);
			_tmp10_ = _tmp9_;
			if (_tmp10_ != NULL) {
				ValaCodeContext* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				const gchar* _tmp14_ = NULL;
				gchar* _tmp15_ = NULL;
				_tmp11_ = self->priv->_context;
				_tmp12_ = vala_code_context_get_includedir (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = self->priv->cinclude_filename;
				_tmp15_ = g_build_path ("/", _tmp13_, _tmp14_, NULL);
				_g_free0 (self->priv->cinclude_filename);
				self->priv->cinclude_filename = _tmp15_;
			}
		} else {
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_ = NULL;
			gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			_tmp16_ = vala_source_file_get_subdir (self);
			_tmp17_ = _tmp16_;
			_tmp18_ = vala_source_file_get_basename (self);
			_tmp19_ = _tmp18_;
			_tmp20_ = g_strconcat (_tmp19_, ".h", NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_build_path ("/", _tmp17_, _tmp21_, NULL);
			_g_free0 (self->priv->cinclude_filename);
			self->priv->cinclude_filename = _tmp22_;
			_g_free0 (_tmp21_);
			_g_free0 (_tmp19_);
			_g_free0 (_tmp17_);
		}
	}
	_tmp23_ = self->priv->cinclude_filename;
	_tmp24_ = g_strdup (_tmp23_);
	result = _tmp24_;
	return result;
}


/**
 * Returns the requested line from this file, loading it if needed.
 *
 * @param lineno 1-based line number
 * @return       the specified source line
 */
gchar* vala_source_file_get_source_line (ValaSourceFile* self, gint lineno) {
	gchar* result = NULL;
	ValaArrayList* _tmp0_ = NULL;
	gboolean _tmp5_ = FALSE;
	gint _tmp6_ = 0;
	gboolean _tmp11_ = FALSE;
	ValaArrayList* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	gpointer _tmp14_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->source_array;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = vala_source_file_get_content (self);
		_tmp2_ = _tmp1_;
		if (_tmp2_ != NULL) {
			const gchar* _tmp3_ = NULL;
			const gchar* _tmp4_ = NULL;
			_tmp3_ = vala_source_file_get_content (self);
			_tmp4_ = _tmp3_;
			vala_source_file_read_source_lines (self, _tmp4_);
		} else {
			vala_source_file_read_source_file (self);
		}
	}
	_tmp6_ = lineno;
	if (_tmp6_ < 1) {
		_tmp5_ = TRUE;
	} else {
		gint _tmp7_ = 0;
		ValaArrayList* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		_tmp7_ = lineno;
		_tmp8_ = self->priv->source_array;
		_tmp9_ = vala_collection_get_size ((ValaCollection*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp5_ = _tmp7_ > _tmp10_;
	}
	_tmp11_ = _tmp5_;
	if (_tmp11_) {
		result = NULL;
		return result;
	}
	_tmp12_ = self->priv->source_array;
	_tmp13_ = lineno;
	_tmp14_ = vala_list_get ((ValaList*) _tmp12_, _tmp13_ - 1);
	result = (gchar*) _tmp14_;
	return result;
}


/**
 * Parses the input file into ::source_array.
 */
static void vala_source_file_read_source_file (ValaSourceFile* self) {
	gchar* cont = NULL;
	const gchar* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		_tmp0_ = self->priv->_filename;
		g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error_);
		_g_free0 (cont);
		cont = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch14_g_file_error;
			}
			_g_free0 (cont);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally14;
	__catch14_g_file_error:
	{
		GError* fe = NULL;
		fe = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (fe);
		_g_free0 (cont);
		return;
	}
	__finally14:
	if (_inner_error_ != NULL) {
		_g_free0 (cont);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = cont;
	vala_source_file_read_source_lines (self, _tmp2_);
	_g_free0 (cont);
}


static void vala_source_file_read_source_lines (ValaSourceFile* self, const gchar* cont) {
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	gchar** lines = NULL;
	const gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint lines_length1 = 0;
	gint _lines_size_ = 0;
	gint idx = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cont != NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, _tmp0_);
	_vala_iterable_unref0 (self->priv->source_array);
	self->priv->source_array = _tmp1_;
	_tmp2_ = cont;
	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, "\n", 0);
	lines = _tmp4_;
	lines_length1 = _vala_array_length (_tmp3_);
	_lines_size_ = lines_length1;
	{
		gboolean _tmp5_ = FALSE;
		idx = 0;
		_tmp5_ = TRUE;
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			gchar** _tmp8_ = NULL;
			gint _tmp8__length1 = 0;
			gint _tmp9_ = 0;
			const gchar* _tmp10_ = NULL;
			ValaArrayList* _tmp11_ = NULL;
			gchar** _tmp12_ = NULL;
			gint _tmp12__length1 = 0;
			gint _tmp13_ = 0;
			const gchar* _tmp14_ = NULL;
			_tmp6_ = _tmp5_;
			if (!_tmp6_) {
				gint _tmp7_ = 0;
				_tmp7_ = idx;
				idx = _tmp7_ + 1;
			}
			_tmp5_ = FALSE;
			_tmp8_ = lines;
			_tmp8__length1 = lines_length1;
			_tmp9_ = idx;
			_tmp10_ = _tmp8_[_tmp9_];
			if (!(_tmp10_ != NULL)) {
				break;
			}
			_tmp11_ = self->priv->source_array;
			_tmp12_ = lines;
			_tmp12__length1 = lines_length1;
			_tmp13_ = idx;
			_tmp14_ = _tmp12_[_tmp13_];
			vala_collection_add ((ValaCollection*) _tmp11_, _tmp14_);
		}
	}
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
}


gchar* vala_source_file_get_mapped_contents (ValaSourceFile* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GMappedFile* _tmp4_ = NULL;
	GMappedFile* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_source_file_get_content (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		_tmp2_ = vala_source_file_get_content (self);
		_tmp3_ = _tmp2_;
		result = (gchar*) _tmp3_;
		return result;
	}
	_tmp4_ = self->priv->mapped_file;
	if (_tmp4_ == NULL) {
		{
			GMappedFile* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			GMappedFile* _tmp7_ = NULL;
			_tmp6_ = self->priv->_filename;
			_tmp7_ = g_mapped_file_new (_tmp6_, FALSE, &_inner_error_);
			_tmp5_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch15_g_file_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_g_mapped_file_free0 (self->priv->mapped_file);
			self->priv->mapped_file = _tmp5_;
		}
		goto __finally15;
		__catch15_g_file_error:
		{
			GError* e = NULL;
			const gchar* _tmp8_ = NULL;
			GError* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = self->priv->_filename;
			_tmp9_ = e;
			_tmp10_ = _tmp9_->message;
			_tmp11_ = g_strdup_printf ("Unable to map file `%s': %s", _tmp8_, _tmp10_);
			_tmp12_ = _tmp11_;
			vala_report_error (NULL, _tmp12_);
			_g_free0 (_tmp12_);
			result = NULL;
			_g_error_free0 (e);
			return result;
		}
		__finally15:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = self->priv->mapped_file;
	_tmp14_ = g_mapped_file_get_contents (_tmp13_);
	result = _tmp14_;
	return result;
}


gsize vala_source_file_get_mapped_length (ValaSourceFile* self) {
	gsize result = 0UL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GMappedFile* _tmp6_ = NULL;
	gsize _tmp7_ = 0UL;
	g_return_val_if_fail (self != NULL, 0UL);
	_tmp0_ = vala_source_file_get_content (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		_tmp2_ = vala_source_file_get_content (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = strlen (_tmp3_);
		_tmp5_ = _tmp4_;
		result = (gsize) _tmp5_;
		return result;
	}
	_tmp6_ = self->priv->mapped_file;
	_tmp7_ = g_mapped_file_get_length (_tmp6_);
	result = _tmp7_;
	return result;
}


gboolean vala_source_file_check (ValaSourceFile* self, ValaCodeContext* context) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	{
		ValaList* _node_list = NULL;
		ValaList* _tmp0_ = NULL;
		ValaList* _tmp1_ = NULL;
		gint _node_size = 0;
		ValaList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _node_index = 0;
		_tmp0_ = self->priv->nodes;
		_tmp1_ = _vala_iterable_ref0 (_tmp0_);
		_node_list = _tmp1_;
		_tmp2_ = _node_list;
		_tmp3_ = vala_collection_get_size ((ValaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_node_size = _tmp4_;
		_node_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ValaCodeNode* node = NULL;
			ValaList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			ValaCodeNode* _tmp11_ = NULL;
			ValaCodeContext* _tmp12_ = NULL;
			_tmp5_ = _node_index;
			_node_index = _tmp5_ + 1;
			_tmp6_ = _node_index;
			_tmp7_ = _node_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _node_list;
			_tmp9_ = _node_index;
			_tmp10_ = vala_list_get (_tmp8_, _tmp9_);
			node = (ValaCodeNode*) _tmp10_;
			_tmp11_ = node;
			_tmp12_ = context;
			vala_code_node_check (_tmp11_, _tmp12_);
			_vala_code_node_unref0 (node);
		}
		_vala_iterable_unref0 (_node_list);
	}
	result = TRUE;
	return result;
}


const gchar* vala_source_file_get_filename (ValaSourceFile* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filename;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_filename (ValaSourceFile* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filename);
	self->priv->_filename = _tmp1_;
}


void vala_source_file_set_relative_filename (ValaSourceFile* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_relative_filename);
	self->priv->_relative_filename = _tmp1_;
}


ValaSourceFileType vala_source_file_get_file_type (ValaSourceFile* self) {
	ValaSourceFileType result;
	ValaSourceFileType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_file_type;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_file_type (ValaSourceFile* self, ValaSourceFileType value) {
	ValaSourceFileType _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_file_type = _tmp0_;
}


gboolean vala_source_file_get_from_commandline (ValaSourceFile* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_from_commandline;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_from_commandline (ValaSourceFile* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_from_commandline = _tmp0_;
}


const gchar* vala_source_file_get_gir_namespace (ValaSourceFile* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_gir_namespace;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_gir_namespace (ValaSourceFile* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_gir_namespace);
	self->priv->_gir_namespace = _tmp1_;
}


const gchar* vala_source_file_get_gir_version (ValaSourceFile* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_gir_version;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_gir_version (ValaSourceFile* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_gir_version);
	self->priv->_gir_version = _tmp1_;
}


ValaCodeContext* vala_source_file_get_context (ValaSourceFile* self) {
	ValaCodeContext* result;
	ValaCodeContext* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_context;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_context (ValaSourceFile* self, ValaCodeContext* value) {
	ValaCodeContext* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_context = _tmp0_;
}


const gchar* vala_source_file_get_content (ValaSourceFile* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_content;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_content (ValaSourceFile* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_content);
	self->priv->_content = _tmp1_;
	_vala_iterable_unref0 (self->priv->source_array);
	self->priv->source_array = NULL;
}


gboolean vala_source_file_get_used (ValaSourceFile* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_used;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_used (ValaSourceFile* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_used = _tmp0_;
}


ValaList* vala_source_file_get_current_using_directives (ValaSourceFile* self) {
	ValaList* result;
	ValaList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_using_directives;
	result = _tmp0_;
	return result;
}


void vala_source_file_set_current_using_directives (ValaSourceFile* self, ValaList* value) {
	ValaList* _tmp0_ = NULL;
	ValaList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _vala_iterable_ref0 (_tmp0_);
	_vala_iterable_unref0 (self->priv->_current_using_directives);
	self->priv->_current_using_directives = _tmp1_;
}


static void vala_value_source_file_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void vala_value_source_file_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		vala_source_file_unref (value->data[0].v_pointer);
	}
}


static void vala_value_source_file_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = vala_source_file_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer vala_value_source_file_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* vala_value_source_file_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ValaSourceFile* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = vala_source_file_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* vala_value_source_file_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ValaSourceFile** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = vala_source_file_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* vala_param_spec_source_file (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ValaParamSpecSourceFile* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALA_TYPE_SOURCE_FILE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer vala_value_get_source_file (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_SOURCE_FILE), NULL);
	return value->data[0].v_pointer;
}


void vala_value_set_source_file (GValue* value, gpointer v_object) {
	ValaSourceFile* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_SOURCE_FILE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_TYPE_SOURCE_FILE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		vala_source_file_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_source_file_unref (old);
	}
}


void vala_value_take_source_file (GValue* value, gpointer v_object) {
	ValaSourceFile* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_SOURCE_FILE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_TYPE_SOURCE_FILE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_source_file_unref (old);
	}
}


static void vala_source_file_class_init (ValaSourceFileClass * klass) {
	vala_source_file_parent_class = g_type_class_peek_parent (klass);
	VALA_SOURCE_FILE_CLASS (klass)->finalize = vala_source_file_finalize;
	g_type_class_add_private (klass, sizeof (ValaSourceFilePrivate));
}


static void vala_source_file_instance_init (ValaSourceFile * self) {
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	GEqualFunc _tmp2_ = NULL;
	ValaArrayList* _tmp3_ = NULL;
	GEqualFunc _tmp4_ = NULL;
	ValaArrayList* _tmp5_ = NULL;
	self->priv = VALA_SOURCE_FILE_GET_PRIVATE (self);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_COMMENT, (GBoxedCopyFunc) vala_comment_ref, vala_comment_unref, _tmp0_);
	self->priv->comments = _tmp1_;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_array_list_new (VALA_TYPE_USING_DIRECTIVE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp2_);
	self->priv->_current_using_directives = (ValaList*) _tmp3_;
	_tmp4_ = g_direct_equal;
	_tmp5_ = vala_array_list_new (VALA_TYPE_CODE_NODE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp4_);
	self->priv->nodes = (ValaList*) _tmp5_;
	self->priv->csource_filename = NULL;
	self->priv->cinclude_filename = NULL;
	self->priv->source_array = NULL;
	self->priv->mapped_file = NULL;
	self->priv->_content = NULL;
	self->ref_count = 1;
}


static void vala_source_file_finalize (ValaSourceFile* obj) {
	ValaSourceFile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_TYPE_SOURCE_FILE, ValaSourceFile);
	_g_free0 (self->priv->_filename);
	_g_free0 (self->priv->_gir_namespace);
	_g_free0 (self->priv->_gir_version);
	_vala_iterable_unref0 (self->priv->comments);
	_vala_iterable_unref0 (self->priv->_current_using_directives);
	_vala_iterable_unref0 (self->priv->nodes);
	_g_free0 (self->priv->_relative_filename);
	_g_free0 (self->priv->csource_filename);
	_g_free0 (self->priv->cinclude_filename);
	_vala_iterable_unref0 (self->priv->source_array);
	_g_mapped_file_free0 (self->priv->mapped_file);
	_g_free0 (self->priv->_content);
}


/**
 * Represents a Vala source or VAPI package file.
 */
GType vala_source_file_get_type (void) {
	static volatile gsize vala_source_file_type_id__volatile = 0;
	if (g_once_init_enter (&vala_source_file_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { vala_value_source_file_init, vala_value_source_file_free_value, vala_value_source_file_copy_value, vala_value_source_file_peek_pointer, "p", vala_value_source_file_collect_value, "p", vala_value_source_file_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ValaSourceFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_source_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaSourceFile), 0, (GInstanceInitFunc) vala_source_file_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType vala_source_file_type_id;
		vala_source_file_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ValaSourceFile", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&vala_source_file_type_id__volatile, vala_source_file_type_id);
	}
	return vala_source_file_type_id__volatile;
}


gpointer vala_source_file_ref (gpointer instance) {
	ValaSourceFile* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void vala_source_file_unref (gpointer instance) {
	ValaSourceFile* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALA_SOURCE_FILE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GType vala_source_file_type_get_type (void) {
	static volatile gsize vala_source_file_type_type_id__volatile = 0;
	if (g_once_init_enter (&vala_source_file_type_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_SOURCE_FILE_TYPE_NONE, "VALA_SOURCE_FILE_TYPE_NONE", "none"}, {VALA_SOURCE_FILE_TYPE_SOURCE, "VALA_SOURCE_FILE_TYPE_SOURCE", "source"}, {VALA_SOURCE_FILE_TYPE_PACKAGE, "VALA_SOURCE_FILE_TYPE_PACKAGE", "package"}, {VALA_SOURCE_FILE_TYPE_FAST, "VALA_SOURCE_FILE_TYPE_FAST", "fast"}, {0, NULL, NULL}};
		GType vala_source_file_type_type_id;
		vala_source_file_type_type_id = g_enum_register_static ("ValaSourceFileType", values);
		g_once_init_leave (&vala_source_file_type_type_id__volatile, vala_source_file_type_type_id);
	}
	return vala_source_file_type_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



