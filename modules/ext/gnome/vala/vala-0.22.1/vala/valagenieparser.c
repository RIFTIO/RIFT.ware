/* valagenieparser.c generated by valac, the Vala compiler
 * generated from valagenieparser.vala, do not modify */

/* valagenieparser.vala
 *
 * Copyright (C) 2008-2012  Jamie McCracken, Jürg Billeter
 * Based on code by Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jamie McCracken jamiemcc gnome org
 */

#include <glib.h>
#include <glib-object.h>
#include <valagee.h>
#include <stdlib.h>
#include <string.h>


#define VALA_TYPE_CODE_VISITOR (vala_code_visitor_get_type ())
#define VALA_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitor))
#define VALA_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))
#define VALA_IS_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_VISITOR))
#define VALA_IS_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_VISITOR))
#define VALA_CODE_VISITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))

typedef struct _ValaCodeVisitor ValaCodeVisitor;
typedef struct _ValaCodeVisitorClass ValaCodeVisitorClass;
typedef struct _ValaCodeVisitorPrivate ValaCodeVisitorPrivate;

#define VALA_TYPE_SOURCE_FILE (vala_source_file_get_type ())
#define VALA_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFile))
#define VALA_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))
#define VALA_IS_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_FILE))
#define VALA_IS_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_FILE))
#define VALA_SOURCE_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))

typedef struct _ValaSourceFile ValaSourceFile;
typedef struct _ValaSourceFileClass ValaSourceFileClass;

#define VALA_TYPE_CODE_NODE (vala_code_node_get_type ())
#define VALA_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_NODE, ValaCodeNode))
#define VALA_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))
#define VALA_IS_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_NODE))
#define VALA_IS_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_NODE))
#define VALA_CODE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))

typedef struct _ValaCodeNode ValaCodeNode;
typedef struct _ValaCodeNodeClass ValaCodeNodeClass;

#define VALA_TYPE_SYMBOL (vala_symbol_get_type ())
#define VALA_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SYMBOL, ValaSymbol))
#define VALA_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SYMBOL, ValaSymbolClass))
#define VALA_IS_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SYMBOL))
#define VALA_IS_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SYMBOL))
#define VALA_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SYMBOL, ValaSymbolClass))

typedef struct _ValaSymbol ValaSymbol;
typedef struct _ValaSymbolClass ValaSymbolClass;

#define VALA_TYPE_NAMESPACE (vala_namespace_get_type ())
#define VALA_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMESPACE, ValaNamespace))
#define VALA_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMESPACE, ValaNamespaceClass))
#define VALA_IS_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMESPACE))
#define VALA_IS_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMESPACE))
#define VALA_NAMESPACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMESPACE, ValaNamespaceClass))

typedef struct _ValaNamespace ValaNamespace;
typedef struct _ValaNamespaceClass ValaNamespaceClass;

#define VALA_TYPE_TYPESYMBOL (vala_typesymbol_get_type ())
#define VALA_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbol))
#define VALA_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))
#define VALA_IS_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPESYMBOL))
#define VALA_IS_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPESYMBOL))
#define VALA_TYPESYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))

typedef struct _ValaTypeSymbol ValaTypeSymbol;
typedef struct _ValaTypeSymbolClass ValaTypeSymbolClass;

#define VALA_TYPE_OBJECT_TYPE_SYMBOL (vala_object_type_symbol_get_type ())
#define VALA_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbol))
#define VALA_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))
#define VALA_IS_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_IS_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_OBJECT_TYPE_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))

typedef struct _ValaObjectTypeSymbol ValaObjectTypeSymbol;
typedef struct _ValaObjectTypeSymbolClass ValaObjectTypeSymbolClass;

#define VALA_TYPE_CLASS (vala_class_get_type ())
#define VALA_CLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CLASS, ValaClass))
#define VALA_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CLASS, ValaClassClass))
#define VALA_IS_CLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CLASS))
#define VALA_IS_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CLASS))
#define VALA_CLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CLASS, ValaClassClass))

typedef struct _ValaClass ValaClass;
typedef struct _ValaClassClass ValaClassClass;

#define VALA_TYPE_STRUCT (vala_struct_get_type ())
#define VALA_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRUCT, ValaStruct))
#define VALA_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRUCT, ValaStructClass))
#define VALA_IS_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRUCT))
#define VALA_IS_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRUCT))
#define VALA_STRUCT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRUCT, ValaStructClass))

typedef struct _ValaStruct ValaStruct;
typedef struct _ValaStructClass ValaStructClass;

#define VALA_TYPE_INTERFACE (vala_interface_get_type ())
#define VALA_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTERFACE, ValaInterface))
#define VALA_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTERFACE, ValaInterfaceClass))
#define VALA_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTERFACE))
#define VALA_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTERFACE))
#define VALA_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTERFACE, ValaInterfaceClass))

typedef struct _ValaInterface ValaInterface;
typedef struct _ValaInterfaceClass ValaInterfaceClass;

#define VALA_TYPE_ENUM (vala_enum_get_type ())
#define VALA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM, ValaEnum))
#define VALA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM, ValaEnumClass))
#define VALA_IS_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM))
#define VALA_IS_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM))
#define VALA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM, ValaEnumClass))

typedef struct _ValaEnum ValaEnum;
typedef struct _ValaEnumClass ValaEnumClass;

#define VALA_TYPE_CONSTANT (vala_constant_get_type ())
#define VALA_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTANT, ValaConstant))
#define VALA_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTANT, ValaConstantClass))
#define VALA_IS_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTANT))
#define VALA_IS_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTANT))
#define VALA_CONSTANT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTANT, ValaConstantClass))

typedef struct _ValaConstant ValaConstant;
typedef struct _ValaConstantClass ValaConstantClass;

#define VALA_TYPE_ENUM_VALUE (vala_enum_value_get_type ())
#define VALA_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValue))
#define VALA_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))
#define VALA_IS_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM_VALUE))
#define VALA_IS_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM_VALUE))
#define VALA_ENUM_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))

typedef struct _ValaEnumValue ValaEnumValue;
typedef struct _ValaEnumValueClass ValaEnumValueClass;

#define VALA_TYPE_ERROR_DOMAIN (vala_error_domain_get_type ())
#define VALA_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomain))
#define VALA_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))
#define VALA_IS_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_DOMAIN))
#define VALA_IS_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_DOMAIN))
#define VALA_ERROR_DOMAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))

typedef struct _ValaErrorDomain ValaErrorDomain;
typedef struct _ValaErrorDomainClass ValaErrorDomainClass;

#define VALA_TYPE_ERROR_CODE (vala_error_code_get_type ())
#define VALA_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCode))
#define VALA_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))
#define VALA_IS_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_CODE))
#define VALA_IS_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_CODE))
#define VALA_ERROR_CODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))

typedef struct _ValaErrorCode ValaErrorCode;
typedef struct _ValaErrorCodeClass ValaErrorCodeClass;

#define VALA_TYPE_DELEGATE (vala_delegate_get_type ())
#define VALA_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELEGATE, ValaDelegate))
#define VALA_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELEGATE, ValaDelegateClass))
#define VALA_IS_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELEGATE))
#define VALA_IS_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELEGATE))
#define VALA_DELEGATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELEGATE, ValaDelegateClass))

typedef struct _ValaDelegate ValaDelegate;
typedef struct _ValaDelegateClass ValaDelegateClass;

#define VALA_TYPE_VARIABLE (vala_variable_get_type ())
#define VALA_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VARIABLE, ValaVariable))
#define VALA_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VARIABLE, ValaVariableClass))
#define VALA_IS_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VARIABLE))
#define VALA_IS_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VARIABLE))
#define VALA_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VARIABLE, ValaVariableClass))

typedef struct _ValaVariable ValaVariable;
typedef struct _ValaVariableClass ValaVariableClass;

#define VALA_TYPE_FIELD (vala_field_get_type ())
#define VALA_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FIELD, ValaField))
#define VALA_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FIELD, ValaFieldClass))
#define VALA_IS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FIELD))
#define VALA_IS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FIELD))
#define VALA_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FIELD, ValaFieldClass))

typedef struct _ValaField ValaField;
typedef struct _ValaFieldClass ValaFieldClass;

#define VALA_TYPE_SUBROUTINE (vala_subroutine_get_type ())
#define VALA_SUBROUTINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SUBROUTINE, ValaSubroutine))
#define VALA_SUBROUTINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SUBROUTINE, ValaSubroutineClass))
#define VALA_IS_SUBROUTINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SUBROUTINE))
#define VALA_IS_SUBROUTINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SUBROUTINE))
#define VALA_SUBROUTINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SUBROUTINE, ValaSubroutineClass))

typedef struct _ValaSubroutine ValaSubroutine;
typedef struct _ValaSubroutineClass ValaSubroutineClass;

#define VALA_TYPE_METHOD (vala_method_get_type ())
#define VALA_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD, ValaMethod))
#define VALA_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD, ValaMethodClass))
#define VALA_IS_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD))
#define VALA_IS_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD))
#define VALA_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD, ValaMethodClass))

typedef struct _ValaMethod ValaMethod;
typedef struct _ValaMethodClass ValaMethodClass;

#define VALA_TYPE_CREATION_METHOD (vala_creation_method_get_type ())
#define VALA_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethod))
#define VALA_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))
#define VALA_IS_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CREATION_METHOD))
#define VALA_IS_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CREATION_METHOD))
#define VALA_CREATION_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))

typedef struct _ValaCreationMethod ValaCreationMethod;
typedef struct _ValaCreationMethodClass ValaCreationMethodClass;

#define VALA_TYPE_PARAMETER (vala_parameter_get_type ())
#define VALA_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PARAMETER, ValaParameter))
#define VALA_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PARAMETER, ValaParameterClass))
#define VALA_IS_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PARAMETER))
#define VALA_IS_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PARAMETER))
#define VALA_PARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PARAMETER, ValaParameterClass))

typedef struct _ValaParameter ValaParameter;
typedef struct _ValaParameterClass ValaParameterClass;

#define VALA_TYPE_PROPERTY (vala_property_get_type ())
#define VALA_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY, ValaProperty))
#define VALA_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY, ValaPropertyClass))
#define VALA_IS_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY))
#define VALA_IS_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY))
#define VALA_PROPERTY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY, ValaPropertyClass))

typedef struct _ValaProperty ValaProperty;
typedef struct _ValaPropertyClass ValaPropertyClass;

#define VALA_TYPE_PROPERTY_ACCESSOR (vala_property_accessor_get_type ())
#define VALA_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessor))
#define VALA_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))
#define VALA_IS_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_IS_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_PROPERTY_ACCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))

typedef struct _ValaPropertyAccessor ValaPropertyAccessor;
typedef struct _ValaPropertyAccessorClass ValaPropertyAccessorClass;

#define VALA_TYPE_SIGNAL (vala_signal_get_type ())
#define VALA_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIGNAL, ValaSignal))
#define VALA_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIGNAL, ValaSignalClass))
#define VALA_IS_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIGNAL))
#define VALA_IS_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIGNAL))
#define VALA_SIGNAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIGNAL, ValaSignalClass))

typedef struct _ValaSignal ValaSignal;
typedef struct _ValaSignalClass ValaSignalClass;

#define VALA_TYPE_CONSTRUCTOR (vala_constructor_get_type ())
#define VALA_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructor))
#define VALA_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))
#define VALA_IS_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTRUCTOR))
#define VALA_IS_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTRUCTOR))
#define VALA_CONSTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))

typedef struct _ValaConstructor ValaConstructor;
typedef struct _ValaConstructorClass ValaConstructorClass;

#define VALA_TYPE_DESTRUCTOR (vala_destructor_get_type ())
#define VALA_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructor))
#define VALA_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))
#define VALA_IS_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DESTRUCTOR))
#define VALA_IS_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DESTRUCTOR))
#define VALA_DESTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))

typedef struct _ValaDestructor ValaDestructor;
typedef struct _ValaDestructorClass ValaDestructorClass;

#define VALA_TYPE_TYPEPARAMETER (vala_typeparameter_get_type ())
#define VALA_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameter))
#define VALA_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))
#define VALA_IS_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEPARAMETER))
#define VALA_IS_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEPARAMETER))
#define VALA_TYPEPARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))

typedef struct _ValaTypeParameter ValaTypeParameter;
typedef struct _ValaTypeParameterClass ValaTypeParameterClass;

#define VALA_TYPE_USING_DIRECTIVE (vala_using_directive_get_type ())
#define VALA_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirective))
#define VALA_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))
#define VALA_IS_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_USING_DIRECTIVE))
#define VALA_IS_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_USING_DIRECTIVE))
#define VALA_USING_DIRECTIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))

typedef struct _ValaUsingDirective ValaUsingDirective;
typedef struct _ValaUsingDirectiveClass ValaUsingDirectiveClass;

#define VALA_TYPE_DATA_TYPE (vala_data_type_get_type ())
#define VALA_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DATA_TYPE, ValaDataType))
#define VALA_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))
#define VALA_IS_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DATA_TYPE))
#define VALA_IS_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DATA_TYPE))
#define VALA_DATA_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))

typedef struct _ValaDataType ValaDataType;
typedef struct _ValaDataTypeClass ValaDataTypeClass;

#define VALA_TYPE_BLOCK (vala_block_get_type ())
#define VALA_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BLOCK, ValaBlock))
#define VALA_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BLOCK, ValaBlockClass))
#define VALA_IS_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BLOCK))
#define VALA_IS_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BLOCK))
#define VALA_BLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BLOCK, ValaBlockClass))

typedef struct _ValaBlock ValaBlock;
typedef struct _ValaBlockClass ValaBlockClass;

#define VALA_TYPE_EMPTY_STATEMENT (vala_empty_statement_get_type ())
#define VALA_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatement))
#define VALA_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))
#define VALA_IS_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_IS_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_EMPTY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))

typedef struct _ValaEmptyStatement ValaEmptyStatement;
typedef struct _ValaEmptyStatementClass ValaEmptyStatementClass;

#define VALA_TYPE_DECLARATION_STATEMENT (vala_declaration_statement_get_type ())
#define VALA_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatement))
#define VALA_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))
#define VALA_IS_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_IS_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_DECLARATION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))

typedef struct _ValaDeclarationStatement ValaDeclarationStatement;
typedef struct _ValaDeclarationStatementClass ValaDeclarationStatementClass;

#define VALA_TYPE_LOCAL_VARIABLE (vala_local_variable_get_type ())
#define VALA_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariable))
#define VALA_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))
#define VALA_IS_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_IS_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_LOCAL_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))

typedef struct _ValaLocalVariable ValaLocalVariable;
typedef struct _ValaLocalVariableClass ValaLocalVariableClass;

#define VALA_TYPE_EXPRESSION (vala_expression_get_type ())
#define VALA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION, ValaExpression))
#define VALA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION, ValaExpressionClass))
#define VALA_IS_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION))
#define VALA_IS_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION))
#define VALA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION, ValaExpressionClass))

typedef struct _ValaExpression ValaExpression;
typedef struct _ValaExpressionClass ValaExpressionClass;

#define VALA_TYPE_INITIALIZER_LIST (vala_initializer_list_get_type ())
#define VALA_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerList))
#define VALA_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))
#define VALA_IS_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INITIALIZER_LIST))
#define VALA_IS_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INITIALIZER_LIST))
#define VALA_INITIALIZER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))

typedef struct _ValaInitializerList ValaInitializerList;
typedef struct _ValaInitializerListClass ValaInitializerListClass;

#define VALA_TYPE_EXPRESSION_STATEMENT (vala_expression_statement_get_type ())
#define VALA_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatement))
#define VALA_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))
#define VALA_IS_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_IS_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_EXPRESSION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))

typedef struct _ValaExpressionStatement ValaExpressionStatement;
typedef struct _ValaExpressionStatementClass ValaExpressionStatementClass;

#define VALA_TYPE_IF_STATEMENT (vala_if_statement_get_type ())
#define VALA_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatement))
#define VALA_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))
#define VALA_IS_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_IF_STATEMENT))
#define VALA_IS_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_IF_STATEMENT))
#define VALA_IF_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))

typedef struct _ValaIfStatement ValaIfStatement;
typedef struct _ValaIfStatementClass ValaIfStatementClass;

#define VALA_TYPE_SWITCH_STATEMENT (vala_switch_statement_get_type ())
#define VALA_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatement))
#define VALA_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))
#define VALA_IS_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_IS_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_SWITCH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))

typedef struct _ValaSwitchStatement ValaSwitchStatement;
typedef struct _ValaSwitchStatementClass ValaSwitchStatementClass;

#define VALA_TYPE_SWITCH_SECTION (vala_switch_section_get_type ())
#define VALA_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSection))
#define VALA_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))
#define VALA_IS_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_SECTION))
#define VALA_IS_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_SECTION))
#define VALA_SWITCH_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))

typedef struct _ValaSwitchSection ValaSwitchSection;
typedef struct _ValaSwitchSectionClass ValaSwitchSectionClass;

#define VALA_TYPE_SWITCH_LABEL (vala_switch_label_get_type ())
#define VALA_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabel))
#define VALA_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))
#define VALA_IS_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_LABEL))
#define VALA_IS_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_LABEL))
#define VALA_SWITCH_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))

typedef struct _ValaSwitchLabel ValaSwitchLabel;
typedef struct _ValaSwitchLabelClass ValaSwitchLabelClass;

#define VALA_TYPE_LOOP (vala_loop_get_type ())
#define VALA_LOOP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOOP, ValaLoop))
#define VALA_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOOP, ValaLoopClass))
#define VALA_IS_LOOP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOOP))
#define VALA_IS_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOOP))
#define VALA_LOOP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOOP, ValaLoopClass))

typedef struct _ValaLoop ValaLoop;
typedef struct _ValaLoopClass ValaLoopClass;

#define VALA_TYPE_WHILE_STATEMENT (vala_while_statement_get_type ())
#define VALA_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatement))
#define VALA_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))
#define VALA_IS_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_WHILE_STATEMENT))
#define VALA_IS_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_WHILE_STATEMENT))
#define VALA_WHILE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))

typedef struct _ValaWhileStatement ValaWhileStatement;
typedef struct _ValaWhileStatementClass ValaWhileStatementClass;

#define VALA_TYPE_DO_STATEMENT (vala_do_statement_get_type ())
#define VALA_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatement))
#define VALA_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))
#define VALA_IS_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DO_STATEMENT))
#define VALA_IS_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DO_STATEMENT))
#define VALA_DO_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))

typedef struct _ValaDoStatement ValaDoStatement;
typedef struct _ValaDoStatementClass ValaDoStatementClass;

#define VALA_TYPE_FOR_STATEMENT (vala_for_statement_get_type ())
#define VALA_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatement))
#define VALA_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))
#define VALA_IS_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOR_STATEMENT))
#define VALA_IS_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOR_STATEMENT))
#define VALA_FOR_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))

typedef struct _ValaForStatement ValaForStatement;
typedef struct _ValaForStatementClass ValaForStatementClass;

#define VALA_TYPE_FOREACH_STATEMENT (vala_foreach_statement_get_type ())
#define VALA_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatement))
#define VALA_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))
#define VALA_IS_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_IS_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_FOREACH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))

typedef struct _ValaForeachStatement ValaForeachStatement;
typedef struct _ValaForeachStatementClass ValaForeachStatementClass;

#define VALA_TYPE_BREAK_STATEMENT (vala_break_statement_get_type ())
#define VALA_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatement))
#define VALA_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))
#define VALA_IS_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BREAK_STATEMENT))
#define VALA_IS_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BREAK_STATEMENT))
#define VALA_BREAK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))

typedef struct _ValaBreakStatement ValaBreakStatement;
typedef struct _ValaBreakStatementClass ValaBreakStatementClass;

#define VALA_TYPE_CONTINUE_STATEMENT (vala_continue_statement_get_type ())
#define VALA_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatement))
#define VALA_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))
#define VALA_IS_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_IS_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_CONTINUE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))

typedef struct _ValaContinueStatement ValaContinueStatement;
typedef struct _ValaContinueStatementClass ValaContinueStatementClass;

#define VALA_TYPE_RETURN_STATEMENT (vala_return_statement_get_type ())
#define VALA_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatement))
#define VALA_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))
#define VALA_IS_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_RETURN_STATEMENT))
#define VALA_IS_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_RETURN_STATEMENT))
#define VALA_RETURN_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))

typedef struct _ValaReturnStatement ValaReturnStatement;
typedef struct _ValaReturnStatementClass ValaReturnStatementClass;

#define VALA_TYPE_YIELD_STATEMENT (vala_yield_statement_get_type ())
#define VALA_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatement))
#define VALA_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))
#define VALA_IS_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_YIELD_STATEMENT))
#define VALA_IS_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_YIELD_STATEMENT))
#define VALA_YIELD_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))

typedef struct _ValaYieldStatement ValaYieldStatement;
typedef struct _ValaYieldStatementClass ValaYieldStatementClass;

#define VALA_TYPE_THROW_STATEMENT (vala_throw_statement_get_type ())
#define VALA_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatement))
#define VALA_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))
#define VALA_IS_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_THROW_STATEMENT))
#define VALA_IS_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_THROW_STATEMENT))
#define VALA_THROW_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))

typedef struct _ValaThrowStatement ValaThrowStatement;
typedef struct _ValaThrowStatementClass ValaThrowStatementClass;

#define VALA_TYPE_TRY_STATEMENT (vala_try_statement_get_type ())
#define VALA_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatement))
#define VALA_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))
#define VALA_IS_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TRY_STATEMENT))
#define VALA_IS_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TRY_STATEMENT))
#define VALA_TRY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))

typedef struct _ValaTryStatement ValaTryStatement;
typedef struct _ValaTryStatementClass ValaTryStatementClass;

#define VALA_TYPE_CATCH_CLAUSE (vala_catch_clause_get_type ())
#define VALA_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClause))
#define VALA_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))
#define VALA_IS_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CATCH_CLAUSE))
#define VALA_IS_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CATCH_CLAUSE))
#define VALA_CATCH_CLAUSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))

typedef struct _ValaCatchClause ValaCatchClause;
typedef struct _ValaCatchClauseClass ValaCatchClauseClass;

#define VALA_TYPE_LOCK_STATEMENT (vala_lock_statement_get_type ())
#define VALA_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatement))
#define VALA_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))
#define VALA_IS_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCK_STATEMENT))
#define VALA_IS_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCK_STATEMENT))
#define VALA_LOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))

typedef struct _ValaLockStatement ValaLockStatement;
typedef struct _ValaLockStatementClass ValaLockStatementClass;

#define VALA_TYPE_UNLOCK_STATEMENT (vala_unlock_statement_get_type ())
#define VALA_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatement))
#define VALA_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))
#define VALA_IS_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_IS_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_UNLOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))

typedef struct _ValaUnlockStatement ValaUnlockStatement;
typedef struct _ValaUnlockStatementClass ValaUnlockStatementClass;

#define VALA_TYPE_DELETE_STATEMENT (vala_delete_statement_get_type ())
#define VALA_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatement))
#define VALA_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))
#define VALA_IS_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELETE_STATEMENT))
#define VALA_IS_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELETE_STATEMENT))
#define VALA_DELETE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))

typedef struct _ValaDeleteStatement ValaDeleteStatement;
typedef struct _ValaDeleteStatementClass ValaDeleteStatementClass;

#define VALA_TYPE_ARRAY_CREATION_EXPRESSION (vala_array_creation_expression_get_type ())
#define VALA_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpression))
#define VALA_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))
#define VALA_IS_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_IS_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_ARRAY_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))

typedef struct _ValaArrayCreationExpression ValaArrayCreationExpression;
typedef struct _ValaArrayCreationExpressionClass ValaArrayCreationExpressionClass;

#define VALA_TYPE_LITERAL (vala_literal_get_type ())
#define VALA_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LITERAL, ValaLiteral))
#define VALA_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LITERAL, ValaLiteralClass))
#define VALA_IS_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LITERAL))
#define VALA_IS_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LITERAL))
#define VALA_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LITERAL, ValaLiteralClass))

typedef struct _ValaLiteral ValaLiteral;
typedef struct _ValaLiteralClass ValaLiteralClass;

#define VALA_TYPE_BOOLEAN_LITERAL (vala_boolean_literal_get_type ())
#define VALA_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteral))
#define VALA_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))
#define VALA_IS_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_IS_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_BOOLEAN_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))

typedef struct _ValaBooleanLiteral ValaBooleanLiteral;
typedef struct _ValaBooleanLiteralClass ValaBooleanLiteralClass;

#define VALA_TYPE_CHARACTER_LITERAL (vala_character_literal_get_type ())
#define VALA_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteral))
#define VALA_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))
#define VALA_IS_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_IS_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_CHARACTER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))

typedef struct _ValaCharacterLiteral ValaCharacterLiteral;
typedef struct _ValaCharacterLiteralClass ValaCharacterLiteralClass;

#define VALA_TYPE_INTEGER_LITERAL (vala_integer_literal_get_type ())
#define VALA_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteral))
#define VALA_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))
#define VALA_IS_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTEGER_LITERAL))
#define VALA_IS_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTEGER_LITERAL))
#define VALA_INTEGER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))

typedef struct _ValaIntegerLiteral ValaIntegerLiteral;
typedef struct _ValaIntegerLiteralClass ValaIntegerLiteralClass;

#define VALA_TYPE_REAL_LITERAL (vala_real_literal_get_type ())
#define VALA_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteral))
#define VALA_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))
#define VALA_IS_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REAL_LITERAL))
#define VALA_IS_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REAL_LITERAL))
#define VALA_REAL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))

typedef struct _ValaRealLiteral ValaRealLiteral;
typedef struct _ValaRealLiteralClass ValaRealLiteralClass;

#define VALA_TYPE_REGEX_LITERAL (vala_regex_literal_get_type ())
#define VALA_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteral))
#define VALA_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))
#define VALA_IS_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REGEX_LITERAL))
#define VALA_IS_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REGEX_LITERAL))
#define VALA_REGEX_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))

typedef struct _ValaRegexLiteral ValaRegexLiteral;
typedef struct _ValaRegexLiteralClass ValaRegexLiteralClass;

#define VALA_TYPE_STRING_LITERAL (vala_string_literal_get_type ())
#define VALA_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteral))
#define VALA_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))
#define VALA_IS_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRING_LITERAL))
#define VALA_IS_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRING_LITERAL))
#define VALA_STRING_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))

typedef struct _ValaStringLiteral ValaStringLiteral;
typedef struct _ValaStringLiteralClass ValaStringLiteralClass;

#define VALA_TYPE_TEMPLATE (vala_template_get_type ())
#define VALA_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TEMPLATE, ValaTemplate))
#define VALA_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TEMPLATE, ValaTemplateClass))
#define VALA_IS_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TEMPLATE))
#define VALA_IS_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TEMPLATE))
#define VALA_TEMPLATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TEMPLATE, ValaTemplateClass))

typedef struct _ValaTemplate ValaTemplate;
typedef struct _ValaTemplateClass ValaTemplateClass;

#define VALA_TYPE_TUPLE (vala_tuple_get_type ())
#define VALA_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TUPLE, ValaTuple))
#define VALA_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TUPLE, ValaTupleClass))
#define VALA_IS_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TUPLE))
#define VALA_IS_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TUPLE))
#define VALA_TUPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TUPLE, ValaTupleClass))

typedef struct _ValaTuple ValaTuple;
typedef struct _ValaTupleClass ValaTupleClass;

#define VALA_TYPE_NULL_LITERAL (vala_null_literal_get_type ())
#define VALA_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteral))
#define VALA_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))
#define VALA_IS_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NULL_LITERAL))
#define VALA_IS_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NULL_LITERAL))
#define VALA_NULL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))

typedef struct _ValaNullLiteral ValaNullLiteral;
typedef struct _ValaNullLiteralClass ValaNullLiteralClass;

#define VALA_TYPE_MEMBER_ACCESS (vala_member_access_get_type ())
#define VALA_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccess))
#define VALA_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))
#define VALA_IS_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_ACCESS))
#define VALA_IS_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_ACCESS))
#define VALA_MEMBER_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))

typedef struct _ValaMemberAccess ValaMemberAccess;
typedef struct _ValaMemberAccessClass ValaMemberAccessClass;

#define VALA_TYPE_METHOD_CALL (vala_method_call_get_type ())
#define VALA_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCall))
#define VALA_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))
#define VALA_IS_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD_CALL))
#define VALA_IS_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD_CALL))
#define VALA_METHOD_CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))

typedef struct _ValaMethodCall ValaMethodCall;
typedef struct _ValaMethodCallClass ValaMethodCallClass;

#define VALA_TYPE_ELEMENT_ACCESS (vala_element_access_get_type ())
#define VALA_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccess))
#define VALA_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))
#define VALA_IS_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_IS_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_ELEMENT_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))

typedef struct _ValaElementAccess ValaElementAccess;
typedef struct _ValaElementAccessClass ValaElementAccessClass;

#define VALA_TYPE_SLICE_EXPRESSION (vala_slice_expression_get_type ())
#define VALA_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpression))
#define VALA_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))
#define VALA_IS_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_IS_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_SLICE_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))

typedef struct _ValaSliceExpression ValaSliceExpression;
typedef struct _ValaSliceExpressionClass ValaSliceExpressionClass;

#define VALA_TYPE_BASE_ACCESS (vala_base_access_get_type ())
#define VALA_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccess))
#define VALA_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))
#define VALA_IS_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BASE_ACCESS))
#define VALA_IS_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BASE_ACCESS))
#define VALA_BASE_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))

typedef struct _ValaBaseAccess ValaBaseAccess;
typedef struct _ValaBaseAccessClass ValaBaseAccessClass;

#define VALA_TYPE_POSTFIX_EXPRESSION (vala_postfix_expression_get_type ())
#define VALA_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpression))
#define VALA_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))
#define VALA_IS_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_IS_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_POSTFIX_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))

typedef struct _ValaPostfixExpression ValaPostfixExpression;
typedef struct _ValaPostfixExpressionClass ValaPostfixExpressionClass;

#define VALA_TYPE_OBJECT_CREATION_EXPRESSION (vala_object_creation_expression_get_type ())
#define VALA_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpression))
#define VALA_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))
#define VALA_IS_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_IS_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_OBJECT_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))

typedef struct _ValaObjectCreationExpression ValaObjectCreationExpression;
typedef struct _ValaObjectCreationExpressionClass ValaObjectCreationExpressionClass;

#define VALA_TYPE_SIZEOF_EXPRESSION (vala_sizeof_expression_get_type ())
#define VALA_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpression))
#define VALA_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))
#define VALA_IS_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_IS_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_SIZEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))

typedef struct _ValaSizeofExpression ValaSizeofExpression;
typedef struct _ValaSizeofExpressionClass ValaSizeofExpressionClass;

#define VALA_TYPE_TYPEOF_EXPRESSION (vala_typeof_expression_get_type ())
#define VALA_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpression))
#define VALA_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))
#define VALA_IS_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_IS_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_TYPEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))

typedef struct _ValaTypeofExpression ValaTypeofExpression;
typedef struct _ValaTypeofExpressionClass ValaTypeofExpressionClass;

#define VALA_TYPE_UNARY_EXPRESSION (vala_unary_expression_get_type ())
#define VALA_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpression))
#define VALA_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))
#define VALA_IS_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_IS_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_UNARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))

typedef struct _ValaUnaryExpression ValaUnaryExpression;
typedef struct _ValaUnaryExpressionClass ValaUnaryExpressionClass;

#define VALA_TYPE_CAST_EXPRESSION (vala_cast_expression_get_type ())
#define VALA_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpression))
#define VALA_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))
#define VALA_IS_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CAST_EXPRESSION))
#define VALA_IS_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CAST_EXPRESSION))
#define VALA_CAST_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))

typedef struct _ValaCastExpression ValaCastExpression;
typedef struct _ValaCastExpressionClass ValaCastExpressionClass;

#define VALA_TYPE_NAMED_ARGUMENT (vala_named_argument_get_type ())
#define VALA_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgument))
#define VALA_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))
#define VALA_IS_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_IS_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_NAMED_ARGUMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))

typedef struct _ValaNamedArgument ValaNamedArgument;
typedef struct _ValaNamedArgumentClass ValaNamedArgumentClass;

#define VALA_TYPE_POINTER_INDIRECTION (vala_pointer_indirection_get_type ())
#define VALA_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirection))
#define VALA_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))
#define VALA_IS_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_IS_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_POINTER_INDIRECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))

typedef struct _ValaPointerIndirection ValaPointerIndirection;
typedef struct _ValaPointerIndirectionClass ValaPointerIndirectionClass;

#define VALA_TYPE_ADDRESSOF_EXPRESSION (vala_addressof_expression_get_type ())
#define VALA_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpression))
#define VALA_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))
#define VALA_IS_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_IS_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_ADDRESSOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))

typedef struct _ValaAddressofExpression ValaAddressofExpression;
typedef struct _ValaAddressofExpressionClass ValaAddressofExpressionClass;

#define VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION (vala_reference_transfer_expression_get_type ())
#define VALA_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpression))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))

typedef struct _ValaReferenceTransferExpression ValaReferenceTransferExpression;
typedef struct _ValaReferenceTransferExpressionClass ValaReferenceTransferExpressionClass;

#define VALA_TYPE_BINARY_EXPRESSION (vala_binary_expression_get_type ())
#define VALA_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpression))
#define VALA_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))
#define VALA_IS_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_IS_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_BINARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))

typedef struct _ValaBinaryExpression ValaBinaryExpression;
typedef struct _ValaBinaryExpressionClass ValaBinaryExpressionClass;

#define VALA_TYPE_TYPECHECK (vala_typecheck_get_type ())
#define VALA_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheck))
#define VALA_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))
#define VALA_IS_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPECHECK))
#define VALA_IS_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPECHECK))
#define VALA_TYPECHECK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))

typedef struct _ValaTypeCheck ValaTypeCheck;
typedef struct _ValaTypeCheckClass ValaTypeCheckClass;

#define VALA_TYPE_CONDITIONAL_EXPRESSION (vala_conditional_expression_get_type ())
#define VALA_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpression))
#define VALA_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))
#define VALA_IS_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_IS_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_CONDITIONAL_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))

typedef struct _ValaConditionalExpression ValaConditionalExpression;
typedef struct _ValaConditionalExpressionClass ValaConditionalExpressionClass;

#define VALA_TYPE_LAMBDA_EXPRESSION (vala_lambda_expression_get_type ())
#define VALA_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpression))
#define VALA_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))
#define VALA_IS_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_IS_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_LAMBDA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))

typedef struct _ValaLambdaExpression ValaLambdaExpression;
typedef struct _ValaLambdaExpressionClass ValaLambdaExpressionClass;

#define VALA_TYPE_ASSIGNMENT (vala_assignment_get_type ())
#define VALA_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignment))
#define VALA_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))
#define VALA_IS_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ASSIGNMENT))
#define VALA_IS_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ASSIGNMENT))
#define VALA_ASSIGNMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))

typedef struct _ValaAssignment ValaAssignment;
typedef struct _ValaAssignmentClass ValaAssignmentClass;

#define VALA_GENIE_TYPE_PARSER (vala_genie_parser_get_type ())
#define VALA_GENIE_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_GENIE_TYPE_PARSER, ValaGenieParser))
#define VALA_GENIE_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_GENIE_TYPE_PARSER, ValaGenieParserClass))
#define VALA_GENIE_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_GENIE_TYPE_PARSER))
#define VALA_GENIE_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_GENIE_TYPE_PARSER))
#define VALA_GENIE_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_GENIE_TYPE_PARSER, ValaGenieParserClass))

typedef struct _ValaGenieParser ValaGenieParser;
typedef struct _ValaGenieParserClass ValaGenieParserClass;
typedef struct _ValaGenieParserPrivate ValaGenieParserPrivate;

#define VALA_GENIE_TYPE_SCANNER (vala_genie_scanner_get_type ())
#define VALA_GENIE_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_GENIE_TYPE_SCANNER, ValaGenieScanner))
#define VALA_GENIE_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_GENIE_TYPE_SCANNER, ValaGenieScannerClass))
#define VALA_GENIE_IS_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_GENIE_TYPE_SCANNER))
#define VALA_GENIE_IS_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_GENIE_TYPE_SCANNER))
#define VALA_GENIE_SCANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_GENIE_TYPE_SCANNER, ValaGenieScannerClass))

typedef struct _ValaGenieScanner ValaGenieScanner;
typedef struct _ValaGenieScannerClass ValaGenieScannerClass;

#define VALA_TYPE_CODE_CONTEXT (vala_code_context_get_type ())
#define VALA_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContext))
#define VALA_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))
#define VALA_IS_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_CONTEXT))
#define VALA_IS_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_CONTEXT))
#define VALA_CODE_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))

typedef struct _ValaCodeContext ValaCodeContext;
typedef struct _ValaCodeContextClass ValaCodeContextClass;

#define VALA_GENIE_PARSER_TYPE_TOKEN_INFO (vala_genie_parser_token_info_get_type ())

#define VALA_GENIE_TYPE_TOKEN_TYPE (vala_genie_token_type_get_type ())

#define VALA_TYPE_SOURCE_LOCATION (vala_source_location_get_type ())
typedef struct _ValaSourceLocation ValaSourceLocation;
typedef struct _ValaGenieParserTokenInfo ValaGenieParserTokenInfo;

#define VALA_TYPE_COMMENT (vala_comment_get_type ())
#define VALA_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_COMMENT, ValaComment))
#define VALA_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_COMMENT, ValaCommentClass))
#define VALA_IS_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_COMMENT))
#define VALA_IS_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_COMMENT))
#define VALA_COMMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_COMMENT, ValaCommentClass))

typedef struct _ValaComment ValaComment;
typedef struct _ValaCommentClass ValaCommentClass;

#define VALA_GENIE_PARSER_TYPE_MODIFIER_FLAGS (vala_genie_parser_modifier_flags_get_type ())

#define VALA_GENIE_PARSER_TYPE_RECOVERY_STATE (vala_genie_parser_recovery_state_get_type ())
#define _vala_genie_scanner_unref0(var) ((var == NULL) ? NULL : (var = (vala_genie_scanner_unref (var), NULL)))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_comment_unref0(var) ((var == NULL) ? NULL : (var = (vala_comment_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define VALA_TYPE_SOURCE_REFERENCE (vala_source_reference_get_type ())
#define VALA_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReference))
#define VALA_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))
#define VALA_IS_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_IS_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_SOURCE_REFERENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))

typedef struct _ValaSourceReference ValaSourceReference;
typedef struct _ValaSourceReferenceClass ValaSourceReferenceClass;
#define _vala_source_reference_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_reference_unref (var), NULL)))

#define VALA_TYPE_SYMBOL_ACCESSIBILITY (vala_symbol_accessibility_get_type ())
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define VALA_TYPE_UNRESOLVED_SYMBOL (vala_unresolved_symbol_get_type ())
#define VALA_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbol))
#define VALA_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))
#define VALA_IS_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_IS_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_UNRESOLVED_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))

typedef struct _ValaUnresolvedSymbol ValaUnresolvedSymbol;
typedef struct _ValaUnresolvedSymbolClass ValaUnresolvedSymbolClass;
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))

#define VALA_TYPE_VOID_TYPE (vala_void_type_get_type ())
#define VALA_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VOID_TYPE, ValaVoidType))
#define VALA_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))
#define VALA_IS_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VOID_TYPE))
#define VALA_IS_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VOID_TYPE))
#define VALA_VOID_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))

typedef struct _ValaVoidType ValaVoidType;
typedef struct _ValaVoidTypeClass ValaVoidTypeClass;

#define VALA_TYPE_UNRESOLVED_TYPE (vala_unresolved_type_get_type ())
#define VALA_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedType))
#define VALA_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))
#define VALA_IS_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_IS_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_UNRESOLVED_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))

typedef struct _ValaUnresolvedType ValaUnresolvedType;
typedef struct _ValaUnresolvedTypeClass ValaUnresolvedTypeClass;

#define VALA_TYPE_POINTER_TYPE (vala_pointer_type_get_type ())
#define VALA_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerType))
#define VALA_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))
#define VALA_IS_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_TYPE))
#define VALA_IS_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_TYPE))
#define VALA_POINTER_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))

typedef struct _ValaPointerType ValaPointerType;
typedef struct _ValaPointerTypeClass ValaPointerTypeClass;

#define VALA_TYPE_REFERENCE_TYPE (vala_reference_type_get_type ())
#define VALA_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceType))
#define VALA_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))
#define VALA_IS_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TYPE))
#define VALA_IS_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TYPE))
#define VALA_REFERENCE_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))

typedef struct _ValaReferenceType ValaReferenceType;
typedef struct _ValaReferenceTypeClass ValaReferenceTypeClass;

#define VALA_TYPE_ARRAY_TYPE (vala_array_type_get_type ())
#define VALA_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayType))
#define VALA_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))
#define VALA_IS_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_TYPE))
#define VALA_IS_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_TYPE))
#define VALA_ARRAY_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))

typedef struct _ValaArrayType ValaArrayType;
typedef struct _ValaArrayTypeClass ValaArrayTypeClass;

#define VALA_TYPE_UNARY_OPERATOR (vala_unary_operator_get_type ())

#define VALA_TYPE_MEMBER_INITIALIZER (vala_member_initializer_get_type ())
#define VALA_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializer))
#define VALA_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))
#define VALA_IS_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_IS_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_MEMBER_INITIALIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))

typedef struct _ValaMemberInitializer ValaMemberInitializer;
typedef struct _ValaMemberInitializerClass ValaMemberInitializerClass;

#define VALA_TYPE_BINARY_OPERATOR (vala_binary_operator_get_type ())

#define VALA_TYPE_PARAMETER_DIRECTION (vala_parameter_direction_get_type ())

#define VALA_TYPE_ASSIGNMENT_OPERATOR (vala_assignment_operator_get_type ())

#define VALA_TYPE_STATEMENT (vala_statement_get_type ())
#define VALA_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STATEMENT, ValaStatement))
#define VALA_IS_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STATEMENT))
#define VALA_STATEMENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALA_TYPE_STATEMENT, ValaStatementIface))

typedef struct _ValaStatement ValaStatement;
typedef struct _ValaStatementIface ValaStatementIface;

#define VALA_TYPE_REPORT (vala_report_get_type ())
#define VALA_REPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REPORT, ValaReport))
#define VALA_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REPORT, ValaReportClass))
#define VALA_IS_REPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REPORT))
#define VALA_IS_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REPORT))
#define VALA_REPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REPORT, ValaReportClass))

typedef struct _ValaReport ValaReport;
typedef struct _ValaReportClass ValaReportClass;

#define VALA_TYPE_ATTRIBUTE (vala_attribute_get_type ())
#define VALA_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ATTRIBUTE, ValaAttribute))
#define VALA_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))
#define VALA_IS_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ATTRIBUTE))
#define VALA_IS_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ATTRIBUTE))
#define VALA_ATTRIBUTE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))

typedef struct _ValaAttribute ValaAttribute;
typedef struct _ValaAttributeClass ValaAttributeClass;
typedef struct _ValaCodeNodePrivate ValaCodeNodePrivate;

#define VALA_TYPE_CODE_GENERATOR (vala_code_generator_get_type ())
#define VALA_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGenerator))
#define VALA_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))
#define VALA_IS_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_GENERATOR))
#define VALA_IS_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_GENERATOR))
#define VALA_CODE_GENERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))

typedef struct _ValaCodeGenerator ValaCodeGenerator;
typedef struct _ValaCodeGeneratorClass ValaCodeGeneratorClass;

#define VALA_TYPE_MEMBER_BINDING (vala_member_binding_get_type ())

#define VALA_TYPE_SOURCE_FILE_TYPE (vala_source_file_type_get_type ())
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _ValaCodeVisitor {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeVisitorPrivate * priv;
};

struct _ValaCodeVisitorClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeVisitor *self);
	void (*visit_source_file) (ValaCodeVisitor* self, ValaSourceFile* source_file);
	void (*visit_namespace) (ValaCodeVisitor* self, ValaNamespace* ns);
	void (*visit_class) (ValaCodeVisitor* self, ValaClass* cl);
	void (*visit_struct) (ValaCodeVisitor* self, ValaStruct* st);
	void (*visit_interface) (ValaCodeVisitor* self, ValaInterface* iface);
	void (*visit_enum) (ValaCodeVisitor* self, ValaEnum* en);
	void (*visit_enum_value) (ValaCodeVisitor* self, ValaEnumValue* ev);
	void (*visit_error_domain) (ValaCodeVisitor* self, ValaErrorDomain* edomain);
	void (*visit_error_code) (ValaCodeVisitor* self, ValaErrorCode* ecode);
	void (*visit_delegate) (ValaCodeVisitor* self, ValaDelegate* d);
	void (*visit_constant) (ValaCodeVisitor* self, ValaConstant* c);
	void (*visit_field) (ValaCodeVisitor* self, ValaField* f);
	void (*visit_method) (ValaCodeVisitor* self, ValaMethod* m);
	void (*visit_creation_method) (ValaCodeVisitor* self, ValaCreationMethod* m);
	void (*visit_formal_parameter) (ValaCodeVisitor* self, ValaParameter* p);
	void (*visit_property) (ValaCodeVisitor* self, ValaProperty* prop);
	void (*visit_property_accessor) (ValaCodeVisitor* self, ValaPropertyAccessor* acc);
	void (*visit_signal) (ValaCodeVisitor* self, ValaSignal* sig);
	void (*visit_constructor) (ValaCodeVisitor* self, ValaConstructor* c);
	void (*visit_destructor) (ValaCodeVisitor* self, ValaDestructor* d);
	void (*visit_type_parameter) (ValaCodeVisitor* self, ValaTypeParameter* p);
	void (*visit_using_directive) (ValaCodeVisitor* self, ValaUsingDirective* ns);
	void (*visit_data_type) (ValaCodeVisitor* self, ValaDataType* type);
	void (*visit_block) (ValaCodeVisitor* self, ValaBlock* b);
	void (*visit_empty_statement) (ValaCodeVisitor* self, ValaEmptyStatement* stmt);
	void (*visit_declaration_statement) (ValaCodeVisitor* self, ValaDeclarationStatement* stmt);
	void (*visit_local_variable) (ValaCodeVisitor* self, ValaLocalVariable* local);
	void (*visit_initializer_list) (ValaCodeVisitor* self, ValaInitializerList* list);
	void (*visit_expression_statement) (ValaCodeVisitor* self, ValaExpressionStatement* stmt);
	void (*visit_if_statement) (ValaCodeVisitor* self, ValaIfStatement* stmt);
	void (*visit_switch_statement) (ValaCodeVisitor* self, ValaSwitchStatement* stmt);
	void (*visit_switch_section) (ValaCodeVisitor* self, ValaSwitchSection* section);
	void (*visit_switch_label) (ValaCodeVisitor* self, ValaSwitchLabel* label);
	void (*visit_loop) (ValaCodeVisitor* self, ValaLoop* stmt);
	void (*visit_while_statement) (ValaCodeVisitor* self, ValaWhileStatement* stmt);
	void (*visit_do_statement) (ValaCodeVisitor* self, ValaDoStatement* stmt);
	void (*visit_for_statement) (ValaCodeVisitor* self, ValaForStatement* stmt);
	void (*visit_foreach_statement) (ValaCodeVisitor* self, ValaForeachStatement* stmt);
	void (*visit_break_statement) (ValaCodeVisitor* self, ValaBreakStatement* stmt);
	void (*visit_continue_statement) (ValaCodeVisitor* self, ValaContinueStatement* stmt);
	void (*visit_return_statement) (ValaCodeVisitor* self, ValaReturnStatement* stmt);
	void (*visit_yield_statement) (ValaCodeVisitor* self, ValaYieldStatement* y);
	void (*visit_throw_statement) (ValaCodeVisitor* self, ValaThrowStatement* stmt);
	void (*visit_try_statement) (ValaCodeVisitor* self, ValaTryStatement* stmt);
	void (*visit_catch_clause) (ValaCodeVisitor* self, ValaCatchClause* clause);
	void (*visit_lock_statement) (ValaCodeVisitor* self, ValaLockStatement* stmt);
	void (*visit_unlock_statement) (ValaCodeVisitor* self, ValaUnlockStatement* stmt);
	void (*visit_delete_statement) (ValaCodeVisitor* self, ValaDeleteStatement* stmt);
	void (*visit_expression) (ValaCodeVisitor* self, ValaExpression* expr);
	void (*visit_array_creation_expression) (ValaCodeVisitor* self, ValaArrayCreationExpression* expr);
	void (*visit_boolean_literal) (ValaCodeVisitor* self, ValaBooleanLiteral* lit);
	void (*visit_character_literal) (ValaCodeVisitor* self, ValaCharacterLiteral* lit);
	void (*visit_integer_literal) (ValaCodeVisitor* self, ValaIntegerLiteral* lit);
	void (*visit_real_literal) (ValaCodeVisitor* self, ValaRealLiteral* lit);
	void (*visit_regex_literal) (ValaCodeVisitor* self, ValaRegexLiteral* lit);
	void (*visit_string_literal) (ValaCodeVisitor* self, ValaStringLiteral* lit);
	void (*visit_template) (ValaCodeVisitor* self, ValaTemplate* tmpl);
	void (*visit_tuple) (ValaCodeVisitor* self, ValaTuple* tuple);
	void (*visit_null_literal) (ValaCodeVisitor* self, ValaNullLiteral* lit);
	void (*visit_member_access) (ValaCodeVisitor* self, ValaMemberAccess* expr);
	void (*visit_method_call) (ValaCodeVisitor* self, ValaMethodCall* expr);
	void (*visit_element_access) (ValaCodeVisitor* self, ValaElementAccess* expr);
	void (*visit_slice_expression) (ValaCodeVisitor* self, ValaSliceExpression* expr);
	void (*visit_base_access) (ValaCodeVisitor* self, ValaBaseAccess* expr);
	void (*visit_postfix_expression) (ValaCodeVisitor* self, ValaPostfixExpression* expr);
	void (*visit_object_creation_expression) (ValaCodeVisitor* self, ValaObjectCreationExpression* expr);
	void (*visit_sizeof_expression) (ValaCodeVisitor* self, ValaSizeofExpression* expr);
	void (*visit_typeof_expression) (ValaCodeVisitor* self, ValaTypeofExpression* expr);
	void (*visit_unary_expression) (ValaCodeVisitor* self, ValaUnaryExpression* expr);
	void (*visit_cast_expression) (ValaCodeVisitor* self, ValaCastExpression* expr);
	void (*visit_named_argument) (ValaCodeVisitor* self, ValaNamedArgument* expr);
	void (*visit_pointer_indirection) (ValaCodeVisitor* self, ValaPointerIndirection* expr);
	void (*visit_addressof_expression) (ValaCodeVisitor* self, ValaAddressofExpression* expr);
	void (*visit_reference_transfer_expression) (ValaCodeVisitor* self, ValaReferenceTransferExpression* expr);
	void (*visit_binary_expression) (ValaCodeVisitor* self, ValaBinaryExpression* expr);
	void (*visit_type_check) (ValaCodeVisitor* self, ValaTypeCheck* expr);
	void (*visit_conditional_expression) (ValaCodeVisitor* self, ValaConditionalExpression* expr);
	void (*visit_lambda_expression) (ValaCodeVisitor* self, ValaLambdaExpression* expr);
	void (*visit_assignment) (ValaCodeVisitor* self, ValaAssignment* a);
	void (*visit_end_full_expression) (ValaCodeVisitor* self, ValaExpression* expr);
};

struct _ValaGenieParser {
	ValaCodeVisitor parent_instance;
	ValaGenieParserPrivate * priv;
};

struct _ValaGenieParserClass {
	ValaCodeVisitorClass parent_class;
};

typedef enum  {
	VALA_GENIE_TOKEN_TYPE_NONE,
	VALA_GENIE_TOKEN_TYPE_ABSTRACT,
	VALA_GENIE_TOKEN_TYPE_ARRAY,
	VALA_GENIE_TOKEN_TYPE_AS,
	VALA_GENIE_TOKEN_TYPE_ASSERT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB,
	VALA_GENIE_TOKEN_TYPE_ASYNC,
	VALA_GENIE_TOKEN_TYPE_BITWISE_AND,
	VALA_GENIE_TOKEN_TYPE_BITWISE_OR,
	VALA_GENIE_TOKEN_TYPE_BREAK,
	VALA_GENIE_TOKEN_TYPE_CARRET,
	VALA_GENIE_TOKEN_TYPE_CASE,
	VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL,
	VALA_GENIE_TOKEN_TYPE_CLASS,
	VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE,
	VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET,
	VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS,
	VALA_GENIE_TOKEN_TYPE_CLOSE_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE,
	VALA_GENIE_TOKEN_TYPE_COLON,
	VALA_GENIE_TOKEN_TYPE_COMMA,
	VALA_GENIE_TOKEN_TYPE_CONST,
	VALA_GENIE_TOKEN_TYPE_CONSTRUCT,
	VALA_GENIE_TOKEN_TYPE_CONTINUE,
	VALA_GENIE_TOKEN_TYPE_DEDENT,
	VALA_GENIE_TOKEN_TYPE_DEF,
	VALA_GENIE_TOKEN_TYPE_DEFAULT,
	VALA_GENIE_TOKEN_TYPE_DELEGATE,
	VALA_GENIE_TOKEN_TYPE_DELETE,
	VALA_GENIE_TOKEN_TYPE_DICT,
	VALA_GENIE_TOKEN_TYPE_DIV,
	VALA_GENIE_TOKEN_TYPE_DO,
	VALA_GENIE_TOKEN_TYPE_DOT,
	VALA_GENIE_TOKEN_TYPE_DOWNTO,
	VALA_GENIE_TOKEN_TYPE_DYNAMIC,
	VALA_GENIE_TOKEN_TYPE_ELLIPSIS,
	VALA_GENIE_TOKEN_TYPE_ELSE,
	VALA_GENIE_TOKEN_TYPE_ENUM,
	VALA_GENIE_TOKEN_TYPE_ENSURES,
	VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN,
	VALA_GENIE_TOKEN_TYPE_EOF,
	VALA_GENIE_TOKEN_TYPE_EOL,
	VALA_GENIE_TOKEN_TYPE_EVENT,
	VALA_GENIE_TOKEN_TYPE_EXCEPT,
	VALA_GENIE_TOKEN_TYPE_EXTERN,
	VALA_GENIE_TOKEN_TYPE_FALSE,
	VALA_GENIE_TOKEN_TYPE_FINAL,
	VALA_GENIE_TOKEN_TYPE_FINALLY,
	VALA_GENIE_TOKEN_TYPE_FOR,
	VALA_GENIE_TOKEN_TYPE_GET,
	VALA_GENIE_TOKEN_TYPE_HASH,
	VALA_GENIE_TOKEN_TYPE_IDENTIFIER,
	VALA_GENIE_TOKEN_TYPE_IF,
	VALA_GENIE_TOKEN_TYPE_IMPLEMENTS,
	VALA_GENIE_TOKEN_TYPE_IN,
	VALA_GENIE_TOKEN_TYPE_INDENT,
	VALA_GENIE_TOKEN_TYPE_INIT,
	VALA_GENIE_TOKEN_TYPE_INLINE,
	VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL,
	VALA_GENIE_TOKEN_TYPE_INTERFACE,
	VALA_GENIE_TOKEN_TYPE_INTERNAL,
	VALA_GENIE_TOKEN_TYPE_INTERR,
	VALA_GENIE_TOKEN_TYPE_IS,
	VALA_GENIE_TOKEN_TYPE_ISA,
	VALA_GENIE_TOKEN_TYPE_LAMBDA,
	VALA_GENIE_TOKEN_TYPE_LIST,
	VALA_GENIE_TOKEN_TYPE_LOCK,
	VALA_GENIE_TOKEN_TYPE_MINUS,
	VALA_GENIE_TOKEN_TYPE_NAMESPACE,
	VALA_GENIE_TOKEN_TYPE_NEW,
	VALA_GENIE_TOKEN_TYPE_NULL,
	VALA_GENIE_TOKEN_TYPE_OF,
	VALA_GENIE_TOKEN_TYPE_OUT,
	VALA_GENIE_TOKEN_TYPE_OP_AND,
	VALA_GENIE_TOKEN_TYPE_OP_DEC,
	VALA_GENIE_TOKEN_TYPE_OP_EQ,
	VALA_GENIE_TOKEN_TYPE_OP_GE,
	VALA_GENIE_TOKEN_TYPE_OP_GT,
	VALA_GENIE_TOKEN_TYPE_OP_INC,
	VALA_GENIE_TOKEN_TYPE_OP_LE,
	VALA_GENIE_TOKEN_TYPE_OP_LT,
	VALA_GENIE_TOKEN_TYPE_OP_NE,
	VALA_GENIE_TOKEN_TYPE_OP_NEG,
	VALA_GENIE_TOKEN_TYPE_OP_OR,
	VALA_GENIE_TOKEN_TYPE_OP_PTR,
	VALA_GENIE_TOKEN_TYPE_OP_SHIFT_LEFT,
	VALA_GENIE_TOKEN_TYPE_OPEN_BRACE,
	VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET,
	VALA_GENIE_TOKEN_TYPE_OPEN_PARENS,
	VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE,
	VALA_GENIE_TOKEN_TYPE_OVERRIDE,
	VALA_GENIE_TOKEN_TYPE_OWNED,
	VALA_GENIE_TOKEN_TYPE_PARAMS,
	VALA_GENIE_TOKEN_TYPE_PASS,
	VALA_GENIE_TOKEN_TYPE_PERCENT,
	VALA_GENIE_TOKEN_TYPE_PLUS,
	VALA_GENIE_TOKEN_TYPE_PRINT,
	VALA_GENIE_TOKEN_TYPE_PRIVATE,
	VALA_GENIE_TOKEN_TYPE_PROP,
	VALA_GENIE_TOKEN_TYPE_PROTECTED,
	VALA_GENIE_TOKEN_TYPE_PUBLIC,
	VALA_GENIE_TOKEN_TYPE_RAISE,
	VALA_GENIE_TOKEN_TYPE_RAISES,
	VALA_GENIE_TOKEN_TYPE_READONLY,
	VALA_GENIE_TOKEN_TYPE_REAL_LITERAL,
	VALA_GENIE_TOKEN_TYPE_REF,
	VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_REQUIRES,
	VALA_GENIE_TOKEN_TYPE_RETURN,
	VALA_GENIE_TOKEN_TYPE_SEALED,
	VALA_GENIE_TOKEN_TYPE_SEMICOLON,
	VALA_GENIE_TOKEN_TYPE_SET,
	VALA_GENIE_TOKEN_TYPE_SIZEOF,
	VALA_GENIE_TOKEN_TYPE_STAR,
	VALA_GENIE_TOKEN_TYPE_STATIC,
	VALA_GENIE_TOKEN_TYPE_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_STRUCT,
	VALA_GENIE_TOKEN_TYPE_SUPER,
	VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_THIS,
	VALA_GENIE_TOKEN_TYPE_TILDE,
	VALA_GENIE_TOKEN_TYPE_TO,
	VALA_GENIE_TOKEN_TYPE_TRUE,
	VALA_GENIE_TOKEN_TYPE_TRY,
	VALA_GENIE_TOKEN_TYPE_TYPEOF,
	VALA_GENIE_TOKEN_TYPE_UNOWNED,
	VALA_GENIE_TOKEN_TYPE_USES,
	VALA_GENIE_TOKEN_TYPE_VAR,
	VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_VIRTUAL,
	VALA_GENIE_TOKEN_TYPE_VOID,
	VALA_GENIE_TOKEN_TYPE_VOLATILE,
	VALA_GENIE_TOKEN_TYPE_WEAK,
	VALA_GENIE_TOKEN_TYPE_WHEN,
	VALA_GENIE_TOKEN_TYPE_WHILE,
	VALA_GENIE_TOKEN_TYPE_WRITEONLY,
	VALA_GENIE_TOKEN_TYPE_YIELD
} ValaGenieTokenType;

struct _ValaSourceLocation {
	gchar* pos;
	gint line;
	gint column;
};

struct _ValaGenieParserTokenInfo {
	ValaGenieTokenType type;
	ValaSourceLocation begin;
	ValaSourceLocation end;
};

struct _ValaGenieParserPrivate {
	ValaGenieScanner* scanner;
	ValaCodeContext* context;
	ValaGenieParserTokenInfo* tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gint index;
	gint size;
	ValaComment* comment;
	gchar* class_name;
	gboolean current_expr_is_lambda;
};

typedef enum  {
	VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT = 1 << 0,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS = 1 << 1,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN = 1 << 2,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE = 1 << 3,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW = 1 << 4,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE = 1 << 5,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC = 1 << 6,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL = 1 << 7,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE = 1 << 8,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC = 1 << 9,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_SEALED = 1 << 10
} ValaGenieParserModifierFlags;

typedef enum  {
	VALA_GENIE_PARSER_RECOVERY_STATE_EOF,
	VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN,
	VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN
} ValaGenieParserRecoveryState;

typedef enum  {
	VALA_PARSE_ERROR_FAILED,
	VALA_PARSE_ERROR_SYNTAX
} ValaParseError;
#define VALA_PARSE_ERROR vala_parse_error_quark ()
typedef enum  {
	VALA_SYMBOL_ACCESSIBILITY_PRIVATE,
	VALA_SYMBOL_ACCESSIBILITY_INTERNAL,
	VALA_SYMBOL_ACCESSIBILITY_PROTECTED,
	VALA_SYMBOL_ACCESSIBILITY_PUBLIC
} ValaSymbolAccessibility;

typedef enum  {
	VALA_UNARY_OPERATOR_NONE,
	VALA_UNARY_OPERATOR_PLUS,
	VALA_UNARY_OPERATOR_MINUS,
	VALA_UNARY_OPERATOR_LOGICAL_NEGATION,
	VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT,
	VALA_UNARY_OPERATOR_INCREMENT,
	VALA_UNARY_OPERATOR_DECREMENT,
	VALA_UNARY_OPERATOR_REF,
	VALA_UNARY_OPERATOR_OUT
} ValaUnaryOperator;

typedef enum  {
	VALA_BINARY_OPERATOR_NONE,
	VALA_BINARY_OPERATOR_PLUS,
	VALA_BINARY_OPERATOR_MINUS,
	VALA_BINARY_OPERATOR_MUL,
	VALA_BINARY_OPERATOR_DIV,
	VALA_BINARY_OPERATOR_MOD,
	VALA_BINARY_OPERATOR_SHIFT_LEFT,
	VALA_BINARY_OPERATOR_SHIFT_RIGHT,
	VALA_BINARY_OPERATOR_LESS_THAN,
	VALA_BINARY_OPERATOR_GREATER_THAN,
	VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_EQUALITY,
	VALA_BINARY_OPERATOR_INEQUALITY,
	VALA_BINARY_OPERATOR_BITWISE_AND,
	VALA_BINARY_OPERATOR_BITWISE_OR,
	VALA_BINARY_OPERATOR_BITWISE_XOR,
	VALA_BINARY_OPERATOR_AND,
	VALA_BINARY_OPERATOR_OR,
	VALA_BINARY_OPERATOR_IN,
	VALA_BINARY_OPERATOR_COALESCE
} ValaBinaryOperator;

typedef enum  {
	VALA_PARAMETER_DIRECTION_IN,
	VALA_PARAMETER_DIRECTION_OUT,
	VALA_PARAMETER_DIRECTION_REF
} ValaParameterDirection;

typedef enum  {
	VALA_ASSIGNMENT_OPERATOR_NONE,
	VALA_ASSIGNMENT_OPERATOR_SIMPLE,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_OR,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_AND,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR,
	VALA_ASSIGNMENT_OPERATOR_ADD,
	VALA_ASSIGNMENT_OPERATOR_SUB,
	VALA_ASSIGNMENT_OPERATOR_MUL,
	VALA_ASSIGNMENT_OPERATOR_DIV,
	VALA_ASSIGNMENT_OPERATOR_PERCENT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT
} ValaAssignmentOperator;

struct _ValaStatementIface {
	GTypeInterface parent_iface;
};

struct _ValaCodeNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeNodePrivate * priv;
	GList* attributes;
};

struct _ValaCodeNodeClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeNode *self);
	void (*accept) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	void (*accept_children) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	gboolean (*check) (ValaCodeNode* self, ValaCodeContext* context);
	void (*emit) (ValaCodeNode* self, ValaCodeGenerator* codegen);
	void (*replace_type) (ValaCodeNode* self, ValaDataType* old_type, ValaDataType* new_type);
	void (*replace_expression) (ValaCodeNode* self, ValaExpression* old_node, ValaExpression* new_node);
	gchar* (*to_string) (ValaCodeNode* self);
	void (*get_defined_variables) (ValaCodeNode* self, ValaCollection* collection);
	void (*get_used_variables) (ValaCodeNode* self, ValaCollection* collection);
};

typedef enum  {
	VALA_MEMBER_BINDING_INSTANCE,
	VALA_MEMBER_BINDING_CLASS,
	VALA_MEMBER_BINDING_STATIC
} ValaMemberBinding;

typedef enum  {
	VALA_SOURCE_FILE_TYPE_NONE,
	VALA_SOURCE_FILE_TYPE_SOURCE,
	VALA_SOURCE_FILE_TYPE_PACKAGE,
	VALA_SOURCE_FILE_TYPE_FAST
} ValaSourceFileType;


static gpointer vala_genie_parser_parent_class = NULL;
static ValaList* vala_genie_parser__empty_type_parameter_list;
static ValaList* vala_genie_parser__empty_type_parameter_list = NULL;

gpointer vala_code_visitor_ref (gpointer instance);
void vala_code_visitor_unref (gpointer instance);
GParamSpec* vala_param_spec_code_visitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_visitor (GValue* value, gpointer v_object);
void vala_value_take_code_visitor (GValue* value, gpointer v_object);
gpointer vala_value_get_code_visitor (const GValue* value);
GType vala_code_visitor_get_type (void) G_GNUC_CONST;
gpointer vala_source_file_ref (gpointer instance);
void vala_source_file_unref (gpointer instance);
GParamSpec* vala_param_spec_source_file (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_file (GValue* value, gpointer v_object);
void vala_value_take_source_file (GValue* value, gpointer v_object);
gpointer vala_value_get_source_file (const GValue* value);
GType vala_source_file_get_type (void) G_GNUC_CONST;
gpointer vala_code_node_ref (gpointer instance);
void vala_code_node_unref (gpointer instance);
GParamSpec* vala_param_spec_code_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_node (GValue* value, gpointer v_object);
void vala_value_take_code_node (GValue* value, gpointer v_object);
gpointer vala_value_get_code_node (const GValue* value);
GType vala_code_node_get_type (void) G_GNUC_CONST;
GType vala_symbol_get_type (void) G_GNUC_CONST;
GType vala_namespace_get_type (void) G_GNUC_CONST;
GType vala_typesymbol_get_type (void) G_GNUC_CONST;
GType vala_object_type_symbol_get_type (void) G_GNUC_CONST;
GType vala_class_get_type (void) G_GNUC_CONST;
GType vala_struct_get_type (void) G_GNUC_CONST;
GType vala_interface_get_type (void) G_GNUC_CONST;
GType vala_enum_get_type (void) G_GNUC_CONST;
GType vala_constant_get_type (void) G_GNUC_CONST;
GType vala_enum_value_get_type (void) G_GNUC_CONST;
GType vala_error_domain_get_type (void) G_GNUC_CONST;
GType vala_error_code_get_type (void) G_GNUC_CONST;
GType vala_delegate_get_type (void) G_GNUC_CONST;
GType vala_variable_get_type (void) G_GNUC_CONST;
GType vala_field_get_type (void) G_GNUC_CONST;
GType vala_subroutine_get_type (void) G_GNUC_CONST;
GType vala_method_get_type (void) G_GNUC_CONST;
GType vala_creation_method_get_type (void) G_GNUC_CONST;
GType vala_parameter_get_type (void) G_GNUC_CONST;
GType vala_property_get_type (void) G_GNUC_CONST;
GType vala_property_accessor_get_type (void) G_GNUC_CONST;
GType vala_signal_get_type (void) G_GNUC_CONST;
GType vala_constructor_get_type (void) G_GNUC_CONST;
GType vala_destructor_get_type (void) G_GNUC_CONST;
GType vala_typeparameter_get_type (void) G_GNUC_CONST;
GType vala_using_directive_get_type (void) G_GNUC_CONST;
GType vala_data_type_get_type (void) G_GNUC_CONST;
GType vala_block_get_type (void) G_GNUC_CONST;
GType vala_empty_statement_get_type (void) G_GNUC_CONST;
GType vala_declaration_statement_get_type (void) G_GNUC_CONST;
GType vala_local_variable_get_type (void) G_GNUC_CONST;
GType vala_expression_get_type (void) G_GNUC_CONST;
GType vala_initializer_list_get_type (void) G_GNUC_CONST;
GType vala_expression_statement_get_type (void) G_GNUC_CONST;
GType vala_if_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_section_get_type (void) G_GNUC_CONST;
GType vala_switch_label_get_type (void) G_GNUC_CONST;
GType vala_loop_get_type (void) G_GNUC_CONST;
GType vala_while_statement_get_type (void) G_GNUC_CONST;
GType vala_do_statement_get_type (void) G_GNUC_CONST;
GType vala_for_statement_get_type (void) G_GNUC_CONST;
GType vala_foreach_statement_get_type (void) G_GNUC_CONST;
GType vala_break_statement_get_type (void) G_GNUC_CONST;
GType vala_continue_statement_get_type (void) G_GNUC_CONST;
GType vala_return_statement_get_type (void) G_GNUC_CONST;
GType vala_yield_statement_get_type (void) G_GNUC_CONST;
GType vala_throw_statement_get_type (void) G_GNUC_CONST;
GType vala_try_statement_get_type (void) G_GNUC_CONST;
GType vala_catch_clause_get_type (void) G_GNUC_CONST;
GType vala_lock_statement_get_type (void) G_GNUC_CONST;
GType vala_unlock_statement_get_type (void) G_GNUC_CONST;
GType vala_delete_statement_get_type (void) G_GNUC_CONST;
GType vala_array_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_literal_get_type (void) G_GNUC_CONST;
GType vala_boolean_literal_get_type (void) G_GNUC_CONST;
GType vala_character_literal_get_type (void) G_GNUC_CONST;
GType vala_integer_literal_get_type (void) G_GNUC_CONST;
GType vala_real_literal_get_type (void) G_GNUC_CONST;
GType vala_regex_literal_get_type (void) G_GNUC_CONST;
GType vala_string_literal_get_type (void) G_GNUC_CONST;
GType vala_template_get_type (void) G_GNUC_CONST;
GType vala_tuple_get_type (void) G_GNUC_CONST;
GType vala_null_literal_get_type (void) G_GNUC_CONST;
GType vala_member_access_get_type (void) G_GNUC_CONST;
GType vala_method_call_get_type (void) G_GNUC_CONST;
GType vala_element_access_get_type (void) G_GNUC_CONST;
GType vala_slice_expression_get_type (void) G_GNUC_CONST;
GType vala_base_access_get_type (void) G_GNUC_CONST;
GType vala_postfix_expression_get_type (void) G_GNUC_CONST;
GType vala_object_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_sizeof_expression_get_type (void) G_GNUC_CONST;
GType vala_typeof_expression_get_type (void) G_GNUC_CONST;
GType vala_unary_expression_get_type (void) G_GNUC_CONST;
GType vala_cast_expression_get_type (void) G_GNUC_CONST;
GType vala_named_argument_get_type (void) G_GNUC_CONST;
GType vala_pointer_indirection_get_type (void) G_GNUC_CONST;
GType vala_addressof_expression_get_type (void) G_GNUC_CONST;
GType vala_reference_transfer_expression_get_type (void) G_GNUC_CONST;
GType vala_binary_expression_get_type (void) G_GNUC_CONST;
GType vala_typecheck_get_type (void) G_GNUC_CONST;
GType vala_conditional_expression_get_type (void) G_GNUC_CONST;
GType vala_lambda_expression_get_type (void) G_GNUC_CONST;
GType vala_assignment_get_type (void) G_GNUC_CONST;
GType vala_genie_parser_get_type (void) G_GNUC_CONST;
gpointer vala_genie_scanner_ref (gpointer instance);
void vala_genie_scanner_unref (gpointer instance);
GParamSpec* vala_genie_param_spec_scanner (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_genie_value_set_scanner (GValue* value, gpointer v_object);
void vala_genie_value_take_scanner (GValue* value, gpointer v_object);
gpointer vala_genie_value_get_scanner (const GValue* value);
GType vala_genie_scanner_get_type (void) G_GNUC_CONST;
gpointer vala_code_context_ref (gpointer instance);
void vala_code_context_unref (gpointer instance);
GParamSpec* vala_param_spec_code_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_context (GValue* value, gpointer v_object);
void vala_value_take_code_context (GValue* value, gpointer v_object);
gpointer vala_value_get_code_context (const GValue* value);
GType vala_code_context_get_type (void) G_GNUC_CONST;
static GType vala_genie_parser_token_info_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
GType vala_genie_token_type_get_type (void) G_GNUC_CONST;
GType vala_source_location_get_type (void) G_GNUC_CONST;
ValaSourceLocation* vala_source_location_dup (const ValaSourceLocation* self);
void vala_source_location_free (ValaSourceLocation* self);
static ValaGenieParserTokenInfo* vala_genie_parser_token_info_dup (const ValaGenieParserTokenInfo* self);
static void vala_genie_parser_token_info_free (ValaGenieParserTokenInfo* self);
gpointer vala_comment_ref (gpointer instance);
void vala_comment_unref (gpointer instance);
GParamSpec* vala_param_spec_comment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_comment (GValue* value, gpointer v_object);
void vala_value_take_comment (GValue* value, gpointer v_object);
gpointer vala_value_get_comment (const GValue* value);
GType vala_comment_get_type (void) G_GNUC_CONST;
#define VALA_GENIE_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALA_GENIE_TYPE_PARSER, ValaGenieParserPrivate))
enum  {
	VALA_GENIE_PARSER_DUMMY_PROPERTY
};
static GType vala_genie_parser_modifier_flags_get_type (void) G_GNUC_UNUSED;
static GType vala_genie_parser_recovery_state_get_type (void) G_GNUC_UNUSED;
#define VALA_GENIE_PARSER_BUFFER_SIZE 32
ValaGenieParser* vala_genie_parser_new (void);
ValaGenieParser* vala_genie_parser_construct (GType object_type);
ValaCodeVisitor* vala_code_visitor_construct (GType object_type);
void vala_genie_parser_parse (ValaGenieParser* self, ValaCodeContext* context);
void vala_code_context_accept (ValaCodeContext* self, ValaCodeVisitor* visitor);
static void vala_genie_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file);
const gchar* vala_source_file_get_filename (ValaSourceFile* self);
void vala_genie_parser_parse_file (ValaGenieParser* self, ValaSourceFile* source_file);
static inline gboolean vala_genie_parser_next (ValaGenieParser* self);
ValaGenieTokenType vala_genie_scanner_read_token (ValaGenieScanner* self, ValaSourceLocation* token_begin, ValaSourceLocation* token_end);
static inline void vala_genie_parser_prev (ValaGenieParser* self);
static inline ValaGenieTokenType vala_genie_parser_current (ValaGenieParser* self);
static inline gboolean vala_genie_parser_accept (ValaGenieParser* self, ValaGenieTokenType type);
static inline gboolean vala_genie_parser_accept_terminator (ValaGenieParser* self);
static inline gboolean vala_genie_parser_accept_block (ValaGenieParser* self);
static gchar* vala_genie_parser_get_error (ValaGenieParser* self, const gchar* msg);
static inline void vala_genie_parser_get_location (ValaGenieParser* self, ValaSourceLocation* result);
gpointer vala_source_reference_ref (gpointer instance);
void vala_source_reference_unref (gpointer instance);
GParamSpec* vala_param_spec_source_reference (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_reference (GValue* value, gpointer v_object);
void vala_value_take_source_reference (GValue* value, gpointer v_object);
gpointer vala_value_get_source_reference (const GValue* value);
GType vala_source_reference_get_type (void) G_GNUC_CONST;
void vala_report_error (ValaSourceReference* source, const gchar* message);
static ValaSourceReference* vala_genie_parser_get_src (ValaGenieParser* self, ValaSourceLocation* begin);
GQuark vala_parse_error_quark (void);
static inline gboolean vala_genie_parser_expect (ValaGenieParser* self, ValaGenieTokenType type, GError** error);
const gchar* vala_genie_token_type_to_string (ValaGenieTokenType self);
static inline gboolean vala_genie_parser_expect_terminator (ValaGenieParser* self, GError** error);
static gchar* vala_genie_parser_get_current_string (ValaGenieParser* self);
static gchar* vala_genie_parser_get_last_string (ValaGenieParser* self);
ValaSourceFile* vala_genie_scanner_get_source_file (ValaGenieScanner* self);
ValaSourceReference* vala_source_reference_new (ValaSourceFile* _file, ValaSourceLocation* begin, ValaSourceLocation* end);
ValaSourceReference* vala_source_reference_construct (GType object_type, ValaSourceFile* _file, ValaSourceLocation* begin, ValaSourceLocation* end);
static ValaSourceReference* vala_genie_parser_get_current_src (ValaGenieParser* self);
static void vala_genie_parser_rollback (ValaGenieParser* self, ValaSourceLocation* location);
void vala_genie_scanner_seek (ValaGenieScanner* self, ValaSourceLocation* location);
GType vala_symbol_accessibility_get_type (void) G_GNUC_CONST;
static inline ValaSymbolAccessibility vala_genie_parser_get_access (ValaGenieParser* self, const gchar* s);
static void vala_genie_parser_skip_identifier (ValaGenieParser* self, GError** error);
static gchar* vala_genie_parser_parse_identifier (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_literal (ValaGenieParser* self, GError** error);
ValaBooleanLiteral* vala_boolean_literal_new (gboolean b, ValaSourceReference* source);
ValaBooleanLiteral* vala_boolean_literal_construct (GType object_type, gboolean b, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_new (const gchar* i, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_construct (GType object_type, const gchar* i, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_new (const gchar* r, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_construct (GType object_type, const gchar* r, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_new (const gchar* c, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_construct (GType object_type, const gchar* c, ValaSourceReference* source);
gboolean vala_code_node_get_error (ValaCodeNode* self);
ValaSourceReference* vala_code_node_get_source_reference (ValaCodeNode* self);
ValaRegexLiteral* vala_regex_literal_new (const gchar* value, ValaSourceReference* source_reference);
ValaRegexLiteral* vala_regex_literal_construct (GType object_type, const gchar* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_new (const gchar* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_construct (GType object_type, const gchar* value, ValaSourceReference* source_reference);
ValaNullLiteral* vala_null_literal_new (ValaSourceReference* source);
ValaNullLiteral* vala_null_literal_construct (GType object_type, ValaSourceReference* source);
ValaGenieScanner* vala_genie_scanner_new (ValaSourceFile* source_file);
ValaGenieScanner* vala_genie_scanner_construct (GType object_type, ValaSourceFile* source_file);
void vala_genie_scanner_parse_file_comments (ValaGenieScanner* self);
void vala_genie_scanner_set_indent_spaces (ValaGenieScanner* self, gint value);
static void vala_genie_parser_parse_using_directives (ValaGenieParser* self, ValaNamespace* ns, GError** error);
ValaNamespace* vala_code_context_get_root (ValaCodeContext* self);
static void vala_genie_parser_parse_declarations (ValaGenieParser* self, ValaSymbol* parent, gboolean root, GError** error);
static void vala_genie_parser_skip_symbol_name (ValaGenieParser* self, GError** error);
GType vala_unresolved_symbol_get_type (void) G_GNUC_CONST;
static ValaUnresolvedSymbol* vala_genie_parser_parse_symbol_name (ValaGenieParser* self, GError** error);
ValaUnresolvedSymbol* vala_unresolved_symbol_new (ValaUnresolvedSymbol* inner, const gchar* name, ValaSourceReference* source_reference);
ValaUnresolvedSymbol* vala_unresolved_symbol_construct (GType object_type, ValaUnresolvedSymbol* inner, const gchar* name, ValaSourceReference* source_reference);
static void vala_genie_parser_skip_type (ValaGenieParser* self, GError** error);
static void vala_genie_parser_skip_type_argument_list (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_regex_literal (ValaGenieParser* self, GError** error);
static ValaDataType* vala_genie_parser_parse_type (ValaGenieParser* self, gboolean owned_by_default, gboolean can_weak_ref, GError** error);
gboolean vala_code_context_get_deprecated (ValaCodeContext* self);
void vala_report_warning (ValaSourceReference* source, const gchar* message);
ValaVoidType* vala_void_type_new (ValaSourceReference* source_reference);
ValaVoidType* vala_void_type_construct (GType object_type, ValaSourceReference* source_reference);
GType vala_void_type_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_type_argument_list (ValaGenieParser* self, gboolean maybe_expression, GError** error);
ValaUnresolvedType* vala_unresolved_type_new_from_symbol (ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
ValaUnresolvedType* vala_unresolved_type_construct_from_symbol (GType object_type, ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
GType vala_unresolved_type_get_type (void) G_GNUC_CONST;
void vala_data_type_add_type_argument (ValaDataType* self, ValaDataType* arg);
ValaPointerType* vala_pointer_type_new (ValaDataType* base_type, ValaSourceReference* source_reference);
ValaPointerType* vala_pointer_type_construct (GType object_type, ValaDataType* base_type, ValaSourceReference* source_reference);
GType vala_pointer_type_get_type (void) G_GNUC_CONST;
void vala_data_type_set_nullable (ValaDataType* self, gboolean value);
void vala_data_type_set_value_owned (ValaDataType* self, gboolean value);
ValaArrayType* vala_array_type_new (ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
ValaArrayType* vala_array_type_construct (GType object_type, ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
GType vala_reference_type_get_type (void) G_GNUC_CONST;
GType vala_array_type_get_type (void) G_GNUC_CONST;
void vala_array_type_set_invalid_syntax (ValaArrayType* self, gboolean value);
void vala_data_type_set_is_dynamic (ValaDataType* self, gboolean value);
static ValaDataType* vala_genie_parser_parse_inline_array_type (ValaGenieParser* self, ValaDataType* type, GError** error);
const gchar* vala_integer_literal_get_value (ValaIntegerLiteral* self);
void vala_array_type_set_inline_allocated (ValaArrayType* self, gboolean value);
void vala_array_type_set_fixed_length (ValaArrayType* self, gboolean value);
void vala_array_type_set_length (ValaArrayType* self, gint value);
gboolean vala_data_type_get_value_owned (ValaDataType* self);
static ValaList* vala_genie_parser_parse_argument_list (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_argument (ValaGenieParser* self, GError** error);
GType vala_unary_operator_get_type (void) G_GNUC_CONST;
ValaUnaryExpression* vala_unary_expression_new (ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaUnaryExpression* vala_unary_expression_construct (GType object_type, ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaExpression* vala_member_access_get_inner (ValaMemberAccess* self);
const gchar* vala_member_access_get_member_name (ValaMemberAccess* self);
ValaNamedArgument* vala_named_argument_new (const gchar* name, ValaExpression* inner, ValaSourceReference* source_reference);
ValaNamedArgument* vala_named_argument_construct (GType object_type, const gchar* name, ValaExpression* inner, ValaSourceReference* source_reference);
static ValaExpression* vala_genie_parser_parse_primary_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_assert_expression (ValaGenieParser* self, GError** error);
static ValaInitializerList* vala_genie_parser_parse_initializer (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_tuple (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_template (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_this_access (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_base_access (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_object_or_array_creation_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_print_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_sizeof_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_typeof_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_yield_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_simple_name (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_pointer_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_method_call (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_element_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_post_increment_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_post_decrement_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
ValaMemberAccess* vala_member_access_new (ValaExpression* inner, const gchar* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct (GType object_type, ValaExpression* inner, const gchar* member_name, ValaSourceReference* source_reference);
void vala_member_access_add_type_argument (ValaMemberAccess* self, ValaDataType* arg);
ValaTemplate* vala_template_new (ValaSourceReference* source_reference);
ValaTemplate* vala_template_construct (GType object_type, ValaSourceReference* source_reference);
void vala_template_add_expression (ValaTemplate* self, ValaExpression* expr);
void vala_code_node_set_source_reference (ValaCodeNode* self, ValaSourceReference* value);
ValaTuple* vala_tuple_new (ValaSourceReference* source_reference);
ValaTuple* vala_tuple_construct (GType object_type, ValaSourceReference* source_reference);
void vala_tuple_add_expression (ValaTuple* self, ValaExpression* expr);
ValaMemberAccess* vala_member_access_new_pointer (ValaExpression* inner, const gchar* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct_pointer (GType object_type, ValaExpression* inner, const gchar* member_name, ValaSourceReference* source_reference);
static ValaList* vala_genie_parser_parse_print_argument_list (ValaGenieParser* self, GError** error);
const gchar* vala_string_literal_get_value (ValaStringLiteral* self);
void vala_string_literal_set_value (ValaStringLiteral* self, const gchar* value);
ValaMethodCall* vala_method_call_new (ValaExpression* call, ValaSourceReference* source_reference);
ValaMethodCall* vala_method_call_construct (GType object_type, ValaExpression* call, ValaSourceReference* source_reference);
void vala_method_call_add_argument (ValaMethodCall* self, ValaExpression* arg);
GType vala_member_initializer_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_object_initializer (ValaGenieParser* self, GError** error);
void vala_member_access_set_creation_member (ValaMemberAccess* self, gboolean value);
ValaObjectCreationExpression* vala_object_creation_expression_new (ValaMemberAccess* member_name, ValaSourceReference* source_reference);
ValaObjectCreationExpression* vala_object_creation_expression_construct (GType object_type, ValaMemberAccess* member_name, ValaSourceReference* source_reference);
void vala_object_creation_expression_set_struct_creation (ValaObjectCreationExpression* self, gboolean value);
void vala_object_creation_expression_add_argument (ValaObjectCreationExpression* self, ValaExpression* arg);
void vala_object_creation_expression_add_member_initializer (ValaObjectCreationExpression* self, ValaMemberInitializer* init);
static ValaList* vala_genie_parser_parse_expression_list (ValaGenieParser* self, GError** error);
ValaElementAccess* vala_element_access_new (ValaExpression* container, ValaSourceReference* source_reference);
ValaElementAccess* vala_element_access_construct (GType object_type, ValaExpression* container, ValaSourceReference* source_reference);
void vala_element_access_append_index (ValaElementAccess* self, ValaExpression* index);
ValaSliceExpression* vala_slice_expression_new (ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaSliceExpression* vala_slice_expression_construct (GType object_type, ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaBaseAccess* vala_base_access_new (ValaSourceReference* source);
ValaBaseAccess* vala_base_access_construct (GType object_type, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_new (ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_construct (GType object_type, ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_array_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error);
static ValaExpression* vala_genie_parser_parse_list_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error);
static ValaExpression* vala_genie_parser_parse_dict_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* key_type, ValaDataType* value_type, GError** error);
static ValaMemberAccess* vala_genie_parser_parse_member_name (ValaGenieParser* self, ValaExpression* base_expr, GError** error);
static ValaExpression* vala_genie_parser_parse_object_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error);
ValaDataType* vala_data_type_copy (ValaDataType* self);
ValaArrayCreationExpression* vala_array_creation_expression_new (ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
ValaArrayCreationExpression* vala_array_creation_expression_construct (GType object_type, ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
void vala_array_creation_expression_append_size (ValaArrayCreationExpression* self, ValaExpression* size);
static ValaMemberInitializer* vala_genie_parser_parse_member_initializer (ValaGenieParser* self, GError** error);
ValaMemberInitializer* vala_member_initializer_new (const gchar* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaMemberInitializer* vala_member_initializer_construct (GType object_type, const gchar* name, ValaExpression* initializer, ValaSourceReference* source_reference);
void vala_method_call_set_is_yield_expression (ValaMethodCall* self, gboolean value);
void vala_object_creation_expression_set_is_yield_expression (ValaObjectCreationExpression* self, gboolean value);
ValaSizeofExpression* vala_sizeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaSizeofExpression* vala_sizeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
static ValaUnaryOperator vala_genie_parser_get_unary_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
static ValaExpression* vala_genie_parser_parse_unary_expression (ValaGenieParser* self, GError** error);
ValaReferenceTransferExpression* vala_reference_transfer_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaReferenceTransferExpression* vala_reference_transfer_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_new (ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_construct (GType object_type, ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_new_non_null (ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_construct_non_null (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
GType vala_binary_operator_get_type (void) G_GNUC_CONST;
static ValaBinaryOperator vala_genie_parser_get_binary_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
static ValaExpression* vala_genie_parser_parse_multiplicative_expression (ValaGenieParser* self, GError** error);
ValaBinaryExpression* vala_binary_expression_new (ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
ValaBinaryExpression* vala_binary_expression_construct (GType object_type, ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_additive_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_shift_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_relational_expression (ValaGenieParser* self, GError** error);
ValaTypeCheck* vala_typecheck_new (ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
ValaTypeCheck* vala_typecheck_construct (GType object_type, ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_equality_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_and_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_exclusive_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_inclusive_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_in_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_and_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_expression (ValaGenieParser* self, GError** error);
ValaConditionalExpression* vala_conditional_expression_new (ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
ValaConditionalExpression* vala_conditional_expression_construct (GType object_type, ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
static ValaParameter* vala_genie_parser_parse_lambda_parameter (ValaGenieParser* self, GError** error);
GType vala_parameter_direction_get_type (void) G_GNUC_CONST;
ValaParameter* vala_parameter_new (const gchar* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
ValaParameter* vala_parameter_construct (GType object_type, const gchar* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
void vala_parameter_set_direction (ValaParameter* self, ValaParameterDirection value);
static ValaExpression* vala_genie_parser_parse_lambda_expression (ValaGenieParser* self, GError** error);
static ValaBlock* vala_genie_parser_parse_block (ValaGenieParser* self, GError** error);
ValaLambdaExpression* vala_lambda_expression_new_with_statement_body (ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct_with_statement_body (GType object_type, ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_new (ValaExpression* expression_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct (GType object_type, ValaExpression* expression_body, ValaSourceReference* source_reference);
void vala_lambda_expression_add_parameter (ValaLambdaExpression* self, ValaParameter* param);
GType vala_assignment_operator_get_type (void) G_GNUC_CONST;
static ValaAssignmentOperator vala_genie_parser_get_assignment_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
ValaAssignment* vala_assignment_new (ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
ValaAssignment* vala_assignment_construct (GType object_type, ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
GType vala_statement_get_type (void) G_GNUC_CONST;
static ValaStatement* vala_genie_parser_get_for_statement_type (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_foreach_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_for_statement (ValaGenieParser* self, GError** error);
static void vala_genie_parser_parse_statements (ValaGenieParser* self, ValaBlock* block, GError** error);
ValaComment* vala_genie_scanner_pop_comment (ValaGenieScanner* self);
ValaEmptyStatement* vala_empty_statement_new (ValaSourceReference* source);
ValaEmptyStatement* vala_empty_statement_construct (GType object_type, ValaSourceReference* source);
static ValaStatement* vala_genie_parser_parse_empty_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_expression_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_if_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_switch_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_while_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_do_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_break_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_continue_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_return_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_throw_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_try_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_lock_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_delete_statement (ValaGenieParser* self, GError** error);
static void vala_genie_parser_parse_local_variable_declarations (ValaGenieParser* self, ValaBlock* block, GError** error);
static ValaStatement* vala_genie_parser_parse_yield_statement (ValaGenieParser* self, GError** error);
static gboolean vala_genie_parser_is_expression (ValaGenieParser* self, GError** error);
void vala_block_add_statement (ValaBlock* self, ValaStatement* stmt);
static ValaGenieParserRecoveryState vala_genie_parser_recover (ValaGenieParser* self);
static ValaBlock* vala_genie_parser_parse_embedded_statement (ValaGenieParser* self, GError** error);
ValaBlock* vala_block_new (ValaSourceReference* source_reference);
ValaBlock* vala_block_construct (GType object_type, ValaSourceReference* source_reference);
static ValaStatement* vala_genie_parser_parse_embedded_statement_without_block (ValaGenieParser* self, GError** error);
GType vala_report_get_type (void) G_GNUC_CONST;
ValaReport* vala_code_context_get_report (ValaCodeContext* self);
gint vala_report_get_errors (ValaReport* self);
void vala_source_reference_get_end (ValaSourceReference* self, ValaSourceLocation* result);
void vala_source_reference_set_end (ValaSourceReference* self, ValaSourceLocation* value);
static void vala_genie_parser_add_local_var_variable (ValaGenieParser* self, ValaBlock* block, const gchar* id, GError** error);
static ValaLocalVariable* vala_genie_parser_parse_local_variable (ValaGenieParser* self, ValaDataType* variable_type, const gchar* id, GError** error);
ValaDeclarationStatement* vala_declaration_statement_new (ValaSymbol* declaration, ValaSourceReference* source_reference);
ValaDeclarationStatement* vala_declaration_statement_construct (GType object_type, ValaSymbol* declaration, ValaSourceReference* source_reference);
ValaLocalVariable* vala_local_variable_new (ValaDataType* variable_type, const gchar* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaLocalVariable* vala_local_variable_construct (GType object_type, ValaDataType* variable_type, const gchar* name, ValaExpression* initializer, ValaSourceReference* source_reference);
static ValaExpression* vala_genie_parser_parse_statement_expression (ValaGenieParser* self, GError** error);
ValaExpressionStatement* vala_expression_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaExpressionStatement* vala_expression_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
ValaIfStatement* vala_if_statement_new (ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaIfStatement* vala_if_statement_construct (GType object_type, ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaSwitchStatement* vala_switch_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchStatement* vala_switch_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_new (ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_construct (GType object_type, ValaSourceReference* source_reference);
void vala_switch_section_add_label (ValaSwitchSection* self, ValaSwitchLabel* label);
ValaSwitchLabel* vala_switch_label_new (ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct (GType object_type, ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_new_with_default (ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct_with_default (GType object_type, ValaSourceReference* source);
ValaBreakStatement* vala_break_statement_new (ValaSourceReference* source);
ValaBreakStatement* vala_break_statement_construct (GType object_type, ValaSourceReference* source);
void vala_switch_statement_add_section (ValaSwitchStatement* self, ValaSwitchSection* section);
ValaWhileStatement* vala_while_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaWhileStatement* vala_while_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_new (ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_construct (GType object_type, ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
void vala_for_statement_add_initializer (ValaForStatement* self, ValaExpression* init);
void vala_for_statement_add_iterator (ValaForStatement* self, ValaExpression* iter);
ValaForeachStatement* vala_foreach_statement_new (ValaDataType* type_reference, const gchar* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaForeachStatement* vala_foreach_statement_construct (GType object_type, ValaDataType* type_reference, const gchar* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaContinueStatement* vala_continue_statement_new (ValaSourceReference* source);
ValaContinueStatement* vala_continue_statement_construct (GType object_type, ValaSourceReference* source);
ValaReturnStatement* vala_return_statement_new (ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaReturnStatement* vala_return_statement_construct (GType object_type, ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_new (ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_construct (GType object_type, ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_new (ValaExpression* error_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_construct (GType object_type, ValaExpression* error_expression, ValaSourceReference* source_reference);
static void vala_genie_parser_parse_catch_clauses (ValaGenieParser* self, ValaList* catch_clauses, GError** error);
static ValaBlock* vala_genie_parser_parse_finally_clause (ValaGenieParser* self, GError** error);
ValaTryStatement* vala_try_statement_new (ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
ValaTryStatement* vala_try_statement_construct (GType object_type, ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
void vala_try_statement_add_catch_clause (ValaTryStatement* self, ValaCatchClause* clause);
ValaCatchClause* vala_catch_clause_new (ValaDataType* error_type, const gchar* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaCatchClause* vala_catch_clause_construct (GType object_type, ValaDataType* error_type, const gchar* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_new (ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_construct (GType object_type, ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
static gchar* vala_genie_parser_parse_attribute_value (ValaGenieParser* self, GError** error);
GType vala_attribute_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_attributes (ValaGenieParser* self, gboolean parameter, GError** error);
ValaAttribute* vala_attribute_new (const gchar* name, ValaSourceReference* source_reference);
ValaAttribute* vala_attribute_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference);
void vala_attribute_add_argument (ValaAttribute* self, const gchar* key, const gchar* value);
static void vala_genie_parser_set_attributes (ValaGenieParser* self, ValaCodeNode* node, ValaList* attributes);
ValaAttribute* vala_code_node_get_attribute (ValaCodeNode* self, const gchar* name);
const gchar* vala_attribute_get_name (ValaAttribute* self);
GType vala_code_generator_get_type (void) G_GNUC_CONST;
static ValaSymbol* vala_genie_parser_parse_declaration (ValaGenieParser* self, gboolean is_root, GError** error);
static ValaConstant* vala_genie_parser_parse_constant_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaCreationMethod* vala_genie_parser_parse_creation_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_class_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaMethod* vala_genie_parser_parse_main_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaConstructor* vala_genie_parser_parse_constructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_delegate_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaMethod* vala_genie_parser_parse_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_enum_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_errordomain_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaDestructor* vala_genie_parser_parse_destructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_interface_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaNamespace* vala_genie_parser_parse_namespace_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaProperty* vala_genie_parser_parse_property_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSignal* vala_genie_parser_parse_signal_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_struct_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaField* vala_genie_parser_parse_field_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static void vala_genie_parser_parse_namespace_member (ValaGenieParser* self, ValaNamespace* ns, GError** error);
static void vala_genie_parser_parse_class_member (ValaGenieParser* self, ValaClass* cl, GError** error);
static void vala_genie_parser_parse_struct_member (ValaGenieParser* self, ValaStruct* st, GError** error);
static void vala_genie_parser_parse_interface_member (ValaGenieParser* self, ValaInterface* iface, GError** error);
const gchar* vala_symbol_get_name (ValaSymbol* self);
ValaNamespace* vala_namespace_new (const gchar* name, ValaSourceReference* source_reference);
ValaNamespace* vala_namespace_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference);
void vala_namespace_add_comment (ValaNamespace* self, ValaComment* comment);
ValaUnresolvedSymbol* vala_unresolved_symbol_get_inner (ValaUnresolvedSymbol* self);
void vala_symbol_add_namespace (ValaSymbol* self, ValaNamespace* ns);
void vala_symbol_add_class (ValaSymbol* self, ValaClass* cl);
void vala_symbol_add_interface (ValaSymbol* self, ValaInterface* iface);
void vala_symbol_add_struct (ValaSymbol* self, ValaStruct* st);
void vala_symbol_add_enum (ValaSymbol* self, ValaEnum* en);
void vala_symbol_add_error_domain (ValaSymbol* self, ValaErrorDomain* edomain);
void vala_symbol_add_delegate (ValaSymbol* self, ValaDelegate* d);
GType vala_member_binding_get_type (void) G_GNUC_CONST;
ValaMemberBinding vala_method_get_binding (ValaMethod* self);
void vala_method_set_binding (ValaMethod* self, ValaMemberBinding value);
void vala_symbol_add_method (ValaSymbol* self, ValaMethod* m);
ValaMemberBinding vala_field_get_binding (ValaField* self);
void vala_field_set_binding (ValaField* self, ValaMemberBinding value);
void vala_symbol_add_field (ValaSymbol* self, ValaField* f);
void vala_symbol_add_constant (ValaSymbol* self, ValaConstant* constant);
static void vala_genie_parser_add_uses_clause (ValaGenieParser* self, ValaNamespace* ns, GError** error);
ValaUsingDirective* vala_using_directive_new (ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
ValaUsingDirective* vala_using_directive_construct (GType object_type, ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
void vala_source_file_add_using_directive (ValaSourceFile* self, ValaUsingDirective* ns);
void vala_namespace_add_using_directive (ValaNamespace* self, ValaUsingDirective* ns);
static ValaGenieParserModifierFlags vala_genie_parser_parse_type_declaration_modifiers (ValaGenieParser* self);
static ValaList* vala_genie_parser_parse_type_parameter_list (ValaGenieParser* self, GError** error);
ValaClass* vala_class_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaClass* vala_class_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_access (ValaSymbol* self, ValaSymbolAccessibility value);
void vala_class_set_is_abstract (ValaClass* self, gboolean value);
void vala_object_type_symbol_add_type_parameter (ValaObjectTypeSymbol* self, ValaTypeParameter* p);
void vala_class_add_base_type (ValaClass* self, ValaDataType* type);
GType vala_source_file_type_get_type (void) G_GNUC_CONST;
ValaSourceFileType vala_source_file_get_file_type (ValaSourceFile* self);
ValaCreationMethod* vala_class_get_default_construction_method (ValaClass* self);
ValaCreationMethod* vala_creation_method_new (const gchar* class_name, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaCreationMethod* vala_creation_method_construct (GType object_type, const gchar* class_name, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_subroutine_set_body (ValaSubroutine* self, ValaBlock* value);
void vala_symbol_add_signal (ValaSymbol* self, ValaSignal* sig);
void vala_symbol_add_property (ValaSymbol* self, ValaProperty* prop);
ValaMemberBinding vala_constructor_get_binding (ValaConstructor* self);
ValaConstructor* vala_class_get_constructor (ValaClass* self);
void vala_class_set_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_class_constructor (ValaClass* self);
void vala_class_set_class_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_static_constructor (ValaClass* self);
void vala_class_set_static_constructor (ValaClass* self, ValaConstructor* value);
ValaMemberBinding vala_destructor_get_binding (ValaDestructor* self);
ValaDestructor* vala_class_get_static_destructor (ValaClass* self);
void vala_class_set_static_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_class_destructor (ValaClass* self);
void vala_class_set_class_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_destructor (ValaClass* self);
void vala_class_set_destructor (ValaClass* self, ValaDestructor* value);
static ValaGenieParserModifierFlags vala_genie_parser_parse_member_declaration_modifiers (ValaGenieParser* self);
ValaDataType* vala_array_type_get_element_type (ValaArrayType* self);
ValaConstant* vala_constant_new (const gchar* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaConstant* vala_constant_construct (GType object_type, const gchar* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_external (ValaSymbol* self, gboolean value);
void vala_symbol_set_hides (ValaSymbol* self, gboolean value);
ValaField* vala_field_new (const gchar* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
ValaField* vala_field_construct (GType object_type, const gchar* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
void vala_variable_set_initializer (ValaVariable* self, ValaExpression* value);
ValaInitializerList* vala_initializer_list_new (ValaSourceReference* source_reference);
ValaInitializerList* vala_initializer_list_construct (GType object_type, ValaSourceReference* source_reference);
void vala_initializer_list_append (ValaInitializerList* self, ValaExpression* expr);
ValaMethod* vala_method_new (const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaMethod* vala_method_construct (GType object_type, const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_method_add_parameter (ValaMethod* self, ValaParameter* param);
static ValaParameter* vala_genie_parser_parse_parameter (ValaGenieParser* self, GError** error);
void vala_method_add_type_parameter (ValaMethod* self, ValaTypeParameter* p);
void vala_code_node_add_error_type (ValaCodeNode* self, ValaDataType* error_type);
void vala_method_set_coroutine (ValaMethod* self, gboolean value);
void vala_method_set_is_abstract (ValaMethod* self, gboolean value);
void vala_method_set_is_virtual (ValaMethod* self, gboolean value);
void vala_method_set_overrides (ValaMethod* self, gboolean value);
gboolean vala_method_get_is_abstract (ValaMethod* self);
gboolean vala_method_get_is_virtual (ValaMethod* self);
gboolean vala_method_get_overrides (ValaMethod* self);
void vala_method_set_is_inline (ValaMethod* self, gboolean value);
void vala_method_add_precondition (ValaMethod* self, ValaExpression* precondition);
void vala_method_add_postcondition (ValaMethod* self, ValaExpression* postcondition);
ValaProperty* vala_property_new (const gchar* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
ValaProperty* vala_property_construct (GType object_type, const gchar* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_binding (ValaProperty* self, ValaMemberBinding value);
void vala_property_set_is_abstract (ValaProperty* self, gboolean value);
void vala_property_set_is_virtual (ValaProperty* self, gboolean value);
void vala_property_set_overrides (ValaProperty* self, gboolean value);
void vala_property_set_initializer (ValaProperty* self, ValaExpression* value);
ValaPropertyAccessor* vala_property_get_get_accessor (ValaProperty* self);
ValaPropertyAccessor* vala_property_accessor_new (gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
ValaPropertyAccessor* vala_property_accessor_construct (GType object_type, gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_get_accessor (ValaProperty* self, ValaPropertyAccessor* value);
ValaPropertyAccessor* vala_property_get_set_accessor (ValaProperty* self);
void vala_property_set_set_accessor (ValaProperty* self, ValaPropertyAccessor* value);
gboolean vala_property_get_is_abstract (ValaProperty* self);
ValaBlock* vala_subroutine_get_body (ValaSubroutine* self);
ValaDataType* vala_property_get_property_type (ValaProperty* self);
ValaExpression* vala_property_get_initializer (ValaProperty* self);
void vala_property_set_field (ValaProperty* self, ValaField* value);
ValaField* vala_property_get_field (ValaProperty* self);
ValaMemberBinding vala_property_get_binding (ValaProperty* self);
ValaSignal* vala_signal_new (const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaSignal* vala_signal_construct (GType object_type, const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_signal_set_is_virtual (ValaSignal* self, gboolean value);
void vala_signal_add_parameter (ValaSignal* self, ValaParameter* param);
void vala_signal_set_body (ValaSignal* self, ValaBlock* value);
ValaConstructor* vala_constructor_new (ValaSourceReference* source);
ValaConstructor* vala_constructor_construct (GType object_type, ValaSourceReference* source);
void vala_constructor_set_binding (ValaConstructor* self, ValaMemberBinding value);
ValaDestructor* vala_destructor_new (ValaSourceReference* source_reference);
ValaDestructor* vala_destructor_construct (GType object_type, ValaSourceReference* source_reference);
ValaStruct* vala_struct_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaStruct* vala_struct_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_struct_add_type_parameter (ValaStruct* self, ValaTypeParameter* p);
void vala_struct_set_base_type (ValaStruct* self, ValaDataType* value);
ValaInterface* vala_interface_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaInterface* vala_interface_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_interface_add_prerequisite (ValaInterface* self, ValaDataType* type);
ValaEnum* vala_enum_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnum* vala_enum_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaList* vala_enum_get_values (ValaEnum* self);
ValaEnumValue* vala_enum_value_new (const gchar* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnumValue* vala_enum_value_construct (GType object_type, const gchar* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_enum_add_value (ValaEnum* self, ValaEnumValue* value);
ValaErrorDomain* vala_error_domain_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorDomain* vala_error_domain_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaList* vala_error_domain_get_codes (ValaErrorDomain* self);
ValaErrorCode* vala_error_code_new (const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorCode* vala_error_code_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_error_code_set_value (ValaErrorCode* self, ValaExpression* value);
void vala_error_domain_add_code (ValaErrorDomain* self, ValaErrorCode* ecode);
ValaParameter* vala_parameter_new_with_ellipsis (ValaSourceReference* source_reference);
ValaParameter* vala_parameter_construct_with_ellipsis (GType object_type, ValaSourceReference* source_reference);
void vala_parameter_set_params_array (ValaParameter* self, gboolean value);
ValaDelegate* vala_delegate_new (const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaDelegate* vala_delegate_construct (GType object_type, const gchar* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_delegate_set_has_target (ValaDelegate* self, gboolean value);
void vala_delegate_add_type_parameter (ValaDelegate* self, ValaTypeParameter* p);
void vala_delegate_add_parameter (ValaDelegate* self, ValaParameter* param);
ValaTypeParameter* vala_typeparameter_new (const gchar* name, ValaSourceReference* source_reference);
ValaTypeParameter* vala_typeparameter_construct (GType object_type, const gchar* name, ValaSourceReference* source_reference);
static void vala_genie_parser_finalize (ValaCodeVisitor* obj);


static GType vala_genie_parser_modifier_flags_get_type (void) {
	static volatile gsize vala_genie_parser_modifier_flags_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_modifier_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE", "none"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT, "VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT", "abstract"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS, "VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS", "class"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN, "VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN", "extern"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE", "inline"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW, "VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW", "new"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE", "override"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC, "VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC", "static"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL, "VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL", "virtual"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE", "private"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC, "VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC", "async"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_SEALED, "VALA_GENIE_PARSER_MODIFIER_FLAGS_SEALED", "sealed"}, {0, NULL, NULL}};
		GType vala_genie_parser_modifier_flags_type_id;
		vala_genie_parser_modifier_flags_type_id = g_enum_register_static ("ValaGenieParserModifierFlags", values);
		g_once_init_leave (&vala_genie_parser_modifier_flags_type_id__volatile, vala_genie_parser_modifier_flags_type_id);
	}
	return vala_genie_parser_modifier_flags_type_id__volatile;
}


static GType vala_genie_parser_recovery_state_get_type (void) {
	static volatile gsize vala_genie_parser_recovery_state_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_recovery_state_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_GENIE_PARSER_RECOVERY_STATE_EOF, "VALA_GENIE_PARSER_RECOVERY_STATE_EOF", "eof"}, {VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN, "VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN", "declaration-begin"}, {VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN, "VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN", "statement-begin"}, {0, NULL, NULL}};
		GType vala_genie_parser_recovery_state_type_id;
		vala_genie_parser_recovery_state_type_id = g_enum_register_static ("ValaGenieParserRecoveryState", values);
		g_once_init_leave (&vala_genie_parser_recovery_state_type_id__volatile, vala_genie_parser_recovery_state_type_id);
	}
	return vala_genie_parser_recovery_state_type_id__volatile;
}


ValaGenieParser* vala_genie_parser_construct (GType object_type) {
	ValaGenieParser* self = NULL;
	ValaGenieParserTokenInfo* _tmp0_ = NULL;
	self = (ValaGenieParser*) vala_code_visitor_construct (object_type);
	_tmp0_ = g_new0 (ValaGenieParserTokenInfo, VALA_GENIE_PARSER_BUFFER_SIZE);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	self->priv->tokens = _tmp0_;
	self->priv->tokens_length1 = VALA_GENIE_PARSER_BUFFER_SIZE;
	self->priv->_tokens_size_ = self->priv->tokens_length1;
	_g_free0 (self->priv->class_name);
	self->priv->class_name = NULL;
	self->priv->current_expr_is_lambda = FALSE;
	return self;
}


ValaGenieParser* vala_genie_parser_new (void) {
	return vala_genie_parser_construct (VALA_GENIE_TYPE_PARSER);
}


/**
 * Parses all .gs source files in the specified code context and
 * builds a code tree.
 *
 * @param context a code context
 */
static gpointer _vala_code_context_ref0 (gpointer self) {
	return self ? vala_code_context_ref (self) : NULL;
}


void vala_genie_parser_parse (ValaGenieParser* self, ValaCodeContext* context) {
	ValaCodeContext* _tmp0_ = NULL;
	ValaCodeContext* _tmp1_ = NULL;
	ValaCodeContext* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = context;
	_tmp1_ = _vala_code_context_ref0 (_tmp0_);
	_vala_code_context_unref0 (self->priv->context);
	self->priv->context = _tmp1_;
	_tmp2_ = context;
	vala_code_context_accept (_tmp2_, (ValaCodeVisitor*) self);
}


static void vala_genie_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file) {
	ValaGenieParser * self;
	ValaSourceFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	self = (ValaGenieParser*) base;
	g_return_if_fail (source_file != NULL);
	_tmp0_ = source_file;
	_tmp1_ = vala_source_file_get_filename (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_str_has_suffix (_tmp2_, ".gs");
	if (_tmp3_) {
		ValaSourceFile* _tmp4_ = NULL;
		_tmp4_ = source_file;
		vala_genie_parser_parse_file (self, _tmp4_);
	}
}


static inline gboolean vala_genie_parser_next (ValaGenieParser* self) {
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	ValaGenieParserTokenInfo* _tmp16_ = NULL;
	gint _tmp16__length1 = 0;
	gint _tmp17_ = 0;
	ValaGenieParserTokenInfo _tmp18_ = {0};
	ValaGenieTokenType _tmp19_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->index;
	self->priv->index = (_tmp0_ + 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	_tmp1_ = self->priv->size;
	self->priv->size = _tmp1_ - 1;
	_tmp2_ = self->priv->size;
	if (_tmp2_ <= 0) {
		ValaSourceLocation begin = {0};
		ValaSourceLocation end = {0};
		ValaGenieTokenType type = 0;
		ValaGenieScanner* _tmp3_ = NULL;
		ValaSourceLocation _tmp4_ = {0};
		ValaSourceLocation _tmp5_ = {0};
		ValaGenieTokenType _tmp6_ = 0;
		ValaGenieParserTokenInfo* _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		gint _tmp8_ = 0;
		ValaGenieTokenType _tmp9_ = 0;
		ValaGenieParserTokenInfo* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gint _tmp11_ = 0;
		ValaSourceLocation _tmp12_ = {0};
		ValaGenieParserTokenInfo* _tmp13_ = NULL;
		gint _tmp13__length1 = 0;
		gint _tmp14_ = 0;
		ValaSourceLocation _tmp15_ = {0};
		_tmp3_ = self->priv->scanner;
		_tmp6_ = vala_genie_scanner_read_token (_tmp3_, &_tmp4_, &_tmp5_);
		begin = _tmp4_;
		end = _tmp5_;
		type = _tmp6_;
		_tmp7_ = self->priv->tokens;
		_tmp7__length1 = self->priv->tokens_length1;
		_tmp8_ = self->priv->index;
		_tmp9_ = type;
		_tmp7_[_tmp8_].type = _tmp9_;
		_tmp10_ = self->priv->tokens;
		_tmp10__length1 = self->priv->tokens_length1;
		_tmp11_ = self->priv->index;
		_tmp12_ = begin;
		_tmp10_[_tmp11_].begin = _tmp12_;
		_tmp13_ = self->priv->tokens;
		_tmp13__length1 = self->priv->tokens_length1;
		_tmp14_ = self->priv->index;
		_tmp15_ = end;
		_tmp13_[_tmp14_].end = _tmp15_;
		self->priv->size = 1;
	}
	_tmp16_ = self->priv->tokens;
	_tmp16__length1 = self->priv->tokens_length1;
	_tmp17_ = self->priv->index;
	_tmp18_ = _tmp16_[_tmp17_];
	_tmp19_ = _tmp18_.type;
	result = _tmp19_ != VALA_GENIE_TOKEN_TYPE_EOF;
	return result;
}


static inline void vala_genie_parser_prev (ValaGenieParser* self) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->index;
	self->priv->index = ((_tmp0_ - 1) + VALA_GENIE_PARSER_BUFFER_SIZE) % VALA_GENIE_PARSER_BUFFER_SIZE;
	_tmp1_ = self->priv->size;
	self->priv->size = _tmp1_ + 1;
	_tmp2_ = self->priv->size;
	_vala_assert (_tmp2_ <= VALA_GENIE_PARSER_BUFFER_SIZE, "size <= BUFFER_SIZE");
}


static inline ValaGenieTokenType vala_genie_parser_current (ValaGenieParser* self) {
	ValaGenieTokenType result = 0;
	ValaGenieParserTokenInfo* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	ValaGenieParserTokenInfo _tmp2_ = {0};
	ValaGenieTokenType _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->tokens;
	_tmp0__length1 = self->priv->tokens_length1;
	_tmp1_ = self->priv->index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = _tmp2_.type;
	result = _tmp3_;
	return result;
}


static inline gboolean vala_genie_parser_accept (ValaGenieParser* self, ValaGenieTokenType type) {
	gboolean result = FALSE;
	ValaGenieTokenType _tmp0_ = 0;
	ValaGenieTokenType _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = vala_genie_parser_current (self);
	_tmp1_ = type;
	if (_tmp0_ == _tmp1_) {
		vala_genie_parser_next (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static inline gboolean vala_genie_parser_accept_terminator (ValaGenieParser* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	ValaGenieTokenType _tmp1_ = 0;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = vala_genie_parser_current (self);
	if (_tmp1_ == VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		_tmp0_ = TRUE;
	} else {
		ValaGenieTokenType _tmp2_ = 0;
		_tmp2_ = vala_genie_parser_current (self);
		_tmp0_ = _tmp2_ == VALA_GENIE_TOKEN_TYPE_EOL;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		vala_genie_parser_next (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static inline gboolean vala_genie_parser_accept_block (ValaGenieParser* self) {
	gboolean result = FALSE;
	gboolean has_term = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = vala_genie_parser_accept_terminator (self);
	has_term = _tmp0_;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
	if (_tmp1_) {
		vala_genie_parser_prev (self);
		result = TRUE;
		return result;
	}
	_tmp2_ = has_term;
	if (_tmp2_) {
		vala_genie_parser_prev (self);
	}
	result = FALSE;
	return result;
}


static gchar* vala_genie_parser_get_error (ValaGenieParser* self, const gchar* msg) {
	gchar* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (msg != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_next (self);
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = msg;
	_tmp5_ = g_strconcat ("syntax error, ", _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	vala_report_error (_tmp3_, _tmp6_);
	_g_free0 (_tmp6_);
	_vala_source_reference_unref0 (_tmp3_);
	_tmp7_ = msg;
	_tmp8_ = g_strdup (_tmp7_);
	result = _tmp8_;
	return result;
}


static inline gboolean vala_genie_parser_expect (ValaGenieParser* self, ValaGenieTokenType type, GError** error) {
	gboolean result = FALSE;
	ValaGenieTokenType _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	ValaGenieTokenType cur = 0;
	ValaGenieTokenType _tmp2_ = 0;
	ValaGenieTokenType pre = 0;
	ValaGenieParserTokenInfo* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gint _tmp4_ = 0;
	ValaGenieParserTokenInfo _tmp5_ = {0};
	ValaGenieTokenType _tmp6_ = 0;
	ValaGenieTokenType _tmp7_ = 0;
	const gchar* _tmp8_ = NULL;
	ValaGenieTokenType _tmp9_ = 0;
	const gchar* _tmp10_ = NULL;
	ValaGenieTokenType _tmp11_ = 0;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	GError* _tmp17_ = NULL;
	GError* _tmp18_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = type;
	_tmp1_ = vala_genie_parser_accept (self, _tmp0_);
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = vala_genie_parser_current (self);
	cur = _tmp2_;
	_tmp3_ = self->priv->tokens;
	_tmp3__length1 = self->priv->tokens_length1;
	_tmp4_ = self->priv->index;
	_tmp5_ = _tmp3_[_tmp4_ - 1];
	_tmp6_ = _tmp5_.type;
	pre = _tmp6_;
	_tmp7_ = type;
	_tmp8_ = vala_genie_token_type_to_string (_tmp7_);
	_tmp9_ = cur;
	_tmp10_ = vala_genie_token_type_to_string (_tmp9_);
	_tmp11_ = pre;
	_tmp12_ = vala_genie_token_type_to_string (_tmp11_);
	_tmp13_ = g_strdup_printf ("expected %s but got %s with previous %s", _tmp8_, _tmp10_, _tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = vala_genie_parser_get_error (self, _tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp16_);
	_tmp18_ = _tmp17_;
	_g_free0 (_tmp16_);
	_g_free0 (_tmp14_);
	_inner_error_ = _tmp18_;
	if (_inner_error_->domain == VALA_PARSE_ERROR) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static inline gboolean vala_genie_parser_expect_terminator (ValaGenieParser* self, GError** error) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	ValaGenieTokenType cur = 0;
	ValaGenieTokenType _tmp1_ = 0;
	ValaGenieTokenType _tmp2_ = 0;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GError* _tmp8_ = NULL;
	GError* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = vala_genie_parser_accept_terminator (self);
	if (_tmp0_) {
		result = TRUE;
		return result;
	}
	_tmp1_ = vala_genie_parser_current (self);
	cur = _tmp1_;
	_tmp2_ = cur;
	_tmp3_ = vala_genie_token_type_to_string (_tmp2_);
	_tmp4_ = g_strdup_printf ("expected line end or semicolon but got %s", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_genie_parser_get_error (self, _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp7_);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_inner_error_ = _tmp9_;
	if (_inner_error_->domain == VALA_PARSE_ERROR) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static inline void vala_genie_parser_get_location (ValaGenieParser* self, ValaSourceLocation* result) {
	ValaGenieParserTokenInfo* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	ValaGenieParserTokenInfo _tmp2_ = {0};
	ValaSourceLocation _tmp3_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->tokens;
	_tmp0__length1 = self->priv->tokens_length1;
	_tmp1_ = self->priv->index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = _tmp2_.begin;
	*result = _tmp3_;
	return;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	gboolean _tmp3_ = FALSE;
	glong _tmp9_ = 0L;
	glong _tmp15_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	glong _tmp22_ = 0L;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		glong _tmp12_ = 0L;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_ = 0L;
		glong _tmp14_ = 0L;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_ = 0L;
		glong _tmp17_ = 0L;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gchar* vala_genie_parser_get_current_string (ValaGenieParser* self) {
	gchar* result = NULL;
	ValaGenieParserTokenInfo* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	ValaGenieParserTokenInfo _tmp2_ = {0};
	ValaSourceLocation _tmp3_ = {0};
	gchar* _tmp4_ = NULL;
	ValaGenieParserTokenInfo* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint _tmp6_ = 0;
	ValaGenieParserTokenInfo _tmp7_ = {0};
	ValaSourceLocation _tmp8_ = {0};
	gchar* _tmp9_ = NULL;
	ValaGenieParserTokenInfo* _tmp10_ = NULL;
	gint _tmp10__length1 = 0;
	gint _tmp11_ = 0;
	ValaGenieParserTokenInfo _tmp12_ = {0};
	ValaSourceLocation _tmp13_ = {0};
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->tokens;
	_tmp0__length1 = self->priv->tokens_length1;
	_tmp1_ = self->priv->index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = _tmp2_.begin;
	_tmp4_ = _tmp3_.pos;
	_tmp5_ = self->priv->tokens;
	_tmp5__length1 = self->priv->tokens_length1;
	_tmp6_ = self->priv->index;
	_tmp7_ = _tmp5_[_tmp6_];
	_tmp8_ = _tmp7_.end;
	_tmp9_ = _tmp8_.pos;
	_tmp10_ = self->priv->tokens;
	_tmp10__length1 = self->priv->tokens_length1;
	_tmp11_ = self->priv->index;
	_tmp12_ = _tmp10_[_tmp11_];
	_tmp13_ = _tmp12_.begin;
	_tmp14_ = _tmp13_.pos;
	_tmp15_ = string_substring ((const gchar*) _tmp4_, (glong) 0, (glong) ((gint) (_tmp9_ - _tmp14_)));
	result = _tmp15_;
	return result;
}


static gchar* vala_genie_parser_get_last_string (ValaGenieParser* self) {
	gchar* result = NULL;
	gint last_index = 0;
	gint _tmp0_ = 0;
	ValaGenieParserTokenInfo* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	ValaGenieParserTokenInfo _tmp2_ = {0};
	ValaSourceLocation _tmp3_ = {0};
	gchar* _tmp4_ = NULL;
	ValaGenieParserTokenInfo* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	ValaGenieParserTokenInfo _tmp6_ = {0};
	ValaSourceLocation _tmp7_ = {0};
	gchar* _tmp8_ = NULL;
	ValaGenieParserTokenInfo* _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	ValaGenieParserTokenInfo _tmp10_ = {0};
	ValaSourceLocation _tmp11_ = {0};
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->index;
	last_index = ((_tmp0_ + VALA_GENIE_PARSER_BUFFER_SIZE) - 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	_tmp1_ = self->priv->tokens;
	_tmp1__length1 = self->priv->tokens_length1;
	_tmp2_ = _tmp1_[last_index];
	_tmp3_ = _tmp2_.begin;
	_tmp4_ = _tmp3_.pos;
	_tmp5_ = self->priv->tokens;
	_tmp5__length1 = self->priv->tokens_length1;
	_tmp6_ = _tmp5_[last_index];
	_tmp7_ = _tmp6_.end;
	_tmp8_ = _tmp7_.pos;
	_tmp9_ = self->priv->tokens;
	_tmp9__length1 = self->priv->tokens_length1;
	_tmp10_ = _tmp9_[last_index];
	_tmp11_ = _tmp10_.begin;
	_tmp12_ = _tmp11_.pos;
	_tmp13_ = string_substring ((const gchar*) _tmp4_, (glong) 0, (glong) ((gint) (_tmp8_ - _tmp12_)));
	result = _tmp13_;
	return result;
}


static ValaSourceReference* vala_genie_parser_get_src (ValaGenieParser* self, ValaSourceLocation* begin) {
	ValaSourceReference* result = NULL;
	gint last_index = 0;
	gint _tmp0_ = 0;
	ValaGenieScanner* _tmp1_ = NULL;
	ValaSourceFile* _tmp2_ = NULL;
	ValaSourceFile* _tmp3_ = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaGenieParserTokenInfo* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	ValaGenieParserTokenInfo _tmp6_ = {0};
	ValaSourceLocation _tmp7_ = {0};
	ValaSourceReference* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	_tmp0_ = self->priv->index;
	last_index = ((_tmp0_ + VALA_GENIE_PARSER_BUFFER_SIZE) - 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	_tmp1_ = self->priv->scanner;
	_tmp2_ = vala_genie_scanner_get_source_file (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = *begin;
	_tmp5_ = self->priv->tokens;
	_tmp5__length1 = self->priv->tokens_length1;
	_tmp6_ = _tmp5_[last_index];
	_tmp7_ = _tmp6_.end;
	_tmp8_ = vala_source_reference_new (_tmp3_, &_tmp4_, &_tmp7_);
	result = _tmp8_;
	return result;
}


static ValaSourceReference* vala_genie_parser_get_current_src (ValaGenieParser* self) {
	ValaSourceReference* result = NULL;
	ValaGenieScanner* _tmp0_ = NULL;
	ValaSourceFile* _tmp1_ = NULL;
	ValaSourceFile* _tmp2_ = NULL;
	ValaGenieParserTokenInfo* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gint _tmp4_ = 0;
	ValaGenieParserTokenInfo _tmp5_ = {0};
	ValaSourceLocation _tmp6_ = {0};
	ValaGenieParserTokenInfo* _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	gint _tmp8_ = 0;
	ValaGenieParserTokenInfo _tmp9_ = {0};
	ValaSourceLocation _tmp10_ = {0};
	ValaSourceReference* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->scanner;
	_tmp1_ = vala_genie_scanner_get_source_file (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->tokens;
	_tmp3__length1 = self->priv->tokens_length1;
	_tmp4_ = self->priv->index;
	_tmp5_ = _tmp3_[_tmp4_];
	_tmp6_ = _tmp5_.begin;
	_tmp7_ = self->priv->tokens;
	_tmp7__length1 = self->priv->tokens_length1;
	_tmp8_ = self->priv->index;
	_tmp9_ = _tmp7_[_tmp8_];
	_tmp10_ = _tmp9_.end;
	_tmp11_ = vala_source_reference_new (_tmp2_, &_tmp6_, &_tmp10_);
	result = _tmp11_;
	return result;
}


static void vala_genie_parser_rollback (ValaGenieParser* self, ValaSourceLocation* location) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (location != NULL);
	while (TRUE) {
		ValaGenieParserTokenInfo* _tmp0_ = NULL;
		gint _tmp0__length1 = 0;
		gint _tmp1_ = 0;
		ValaGenieParserTokenInfo _tmp2_ = {0};
		ValaSourceLocation _tmp3_ = {0};
		gchar* _tmp4_ = NULL;
		ValaSourceLocation _tmp5_ = {0};
		gchar* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		_tmp0_ = self->priv->tokens;
		_tmp0__length1 = self->priv->tokens_length1;
		_tmp1_ = self->priv->index;
		_tmp2_ = _tmp0_[_tmp1_];
		_tmp3_ = _tmp2_.begin;
		_tmp4_ = _tmp3_.pos;
		_tmp5_ = *location;
		_tmp6_ = _tmp5_.pos;
		if (!(_tmp4_ != _tmp6_)) {
			break;
		}
		_tmp7_ = self->priv->index;
		self->priv->index = ((_tmp7_ - 1) + VALA_GENIE_PARSER_BUFFER_SIZE) % VALA_GENIE_PARSER_BUFFER_SIZE;
		_tmp8_ = self->priv->size;
		self->priv->size = _tmp8_ + 1;
		_tmp9_ = self->priv->size;
		if (_tmp9_ > VALA_GENIE_PARSER_BUFFER_SIZE) {
			ValaGenieScanner* _tmp10_ = NULL;
			ValaSourceLocation _tmp11_ = {0};
			_tmp10_ = self->priv->scanner;
			_tmp11_ = *location;
			vala_genie_scanner_seek (_tmp10_, &_tmp11_);
			self->priv->size = 0;
			self->priv->index = 0;
			vala_genie_parser_next (self);
		}
	}
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static inline ValaSymbolAccessibility vala_genie_parser_get_access (ValaGenieParser* self, const gchar* s) {
	ValaSymbolAccessibility result = 0;
	const gchar* _tmp0_ = NULL;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (s != NULL, 0);
	_tmp0_ = s;
	_tmp1_ = string_get (_tmp0_, (glong) 0);
	if (_tmp1_ == '_') {
		result = VALA_SYMBOL_ACCESSIBILITY_PRIVATE;
		return result;
	}
	result = VALA_SYMBOL_ACCESSIBILITY_PUBLIC;
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static void vala_genie_parser_skip_identifier (ValaGenieParser* self, GError** error) {
	ValaGenieTokenType _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = vala_genie_parser_current (self);
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
		case VALA_GENIE_TOKEN_TYPE_AS:
		case VALA_GENIE_TOKEN_TYPE_ASSERT:
		case VALA_GENIE_TOKEN_TYPE_ASYNC:
		case VALA_GENIE_TOKEN_TYPE_BREAK:
		case VALA_GENIE_TOKEN_TYPE_CLASS:
		case VALA_GENIE_TOKEN_TYPE_CONST:
		case VALA_GENIE_TOKEN_TYPE_CONTINUE:
		case VALA_GENIE_TOKEN_TYPE_DEDENT:
		case VALA_GENIE_TOKEN_TYPE_DEF:
		case VALA_GENIE_TOKEN_TYPE_DEFAULT:
		case VALA_GENIE_TOKEN_TYPE_DELEGATE:
		case VALA_GENIE_TOKEN_TYPE_DELETE:
		case VALA_GENIE_TOKEN_TYPE_DO:
		case VALA_GENIE_TOKEN_TYPE_DOWNTO:
		case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
		case VALA_GENIE_TOKEN_TYPE_ELSE:
		case VALA_GENIE_TOKEN_TYPE_EOL:
		case VALA_GENIE_TOKEN_TYPE_ENUM:
		case VALA_GENIE_TOKEN_TYPE_ENSURES:
		case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
		case VALA_GENIE_TOKEN_TYPE_EVENT:
		case VALA_GENIE_TOKEN_TYPE_EXCEPT:
		case VALA_GENIE_TOKEN_TYPE_EXTERN:
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		case VALA_GENIE_TOKEN_TYPE_FINAL:
		case VALA_GENIE_TOKEN_TYPE_FINALLY:
		case VALA_GENIE_TOKEN_TYPE_FOR:
		case VALA_GENIE_TOKEN_TYPE_GET:
		case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
		case VALA_GENIE_TOKEN_TYPE_IF:
		case VALA_GENIE_TOKEN_TYPE_IN:
		case VALA_GENIE_TOKEN_TYPE_INDENT:
		case VALA_GENIE_TOKEN_TYPE_INIT:
		case VALA_GENIE_TOKEN_TYPE_INLINE:
		case VALA_GENIE_TOKEN_TYPE_INTERFACE:
		case VALA_GENIE_TOKEN_TYPE_INTERNAL:
		case VALA_GENIE_TOKEN_TYPE_IS:
		case VALA_GENIE_TOKEN_TYPE_ISA:
		case VALA_GENIE_TOKEN_TYPE_LOCK:
		case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
		case VALA_GENIE_TOKEN_TYPE_NEW:
		case VALA_GENIE_TOKEN_TYPE_NULL:
		case VALA_GENIE_TOKEN_TYPE_OF:
		case VALA_GENIE_TOKEN_TYPE_OUT:
		case VALA_GENIE_TOKEN_TYPE_OVERRIDE:
		case VALA_GENIE_TOKEN_TYPE_OWNED:
		case VALA_GENIE_TOKEN_TYPE_PASS:
		case VALA_GENIE_TOKEN_TYPE_PRINT:
		case VALA_GENIE_TOKEN_TYPE_PRIVATE:
		case VALA_GENIE_TOKEN_TYPE_PROP:
		case VALA_GENIE_TOKEN_TYPE_RAISE:
		case VALA_GENIE_TOKEN_TYPE_RAISES:
		case VALA_GENIE_TOKEN_TYPE_REF:
		case VALA_GENIE_TOKEN_TYPE_REQUIRES:
		case VALA_GENIE_TOKEN_TYPE_RETURN:
		case VALA_GENIE_TOKEN_TYPE_SEALED:
		case VALA_GENIE_TOKEN_TYPE_SET:
		case VALA_GENIE_TOKEN_TYPE_SIZEOF:
		case VALA_GENIE_TOKEN_TYPE_STATIC:
		case VALA_GENIE_TOKEN_TYPE_STRUCT:
		case VALA_GENIE_TOKEN_TYPE_SUPER:
		case VALA_GENIE_TOKEN_TYPE_THIS:
		case VALA_GENIE_TOKEN_TYPE_TO:
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		case VALA_GENIE_TOKEN_TYPE_TRY:
		case VALA_GENIE_TOKEN_TYPE_TYPEOF:
		case VALA_GENIE_TOKEN_TYPE_UNOWNED:
		case VALA_GENIE_TOKEN_TYPE_USES:
		case VALA_GENIE_TOKEN_TYPE_VAR:
		case VALA_GENIE_TOKEN_TYPE_VIRTUAL:
		case VALA_GENIE_TOKEN_TYPE_VOID:
		case VALA_GENIE_TOKEN_TYPE_VOLATILE:
		case VALA_GENIE_TOKEN_TYPE_WEAK:
		case VALA_GENIE_TOKEN_TYPE_WHEN:
		case VALA_GENIE_TOKEN_TYPE_WHILE:
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			vala_genie_parser_next (self);
			return;
		}
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		{
			gchar* id = NULL;
			gchar* _tmp1_ = NULL;
			gboolean _tmp2_ = FALSE;
			const gchar* _tmp3_ = NULL;
			const gchar* _tmp4_ = NULL;
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gchar _tmp7_ = '\0';
			gboolean _tmp8_ = FALSE;
			gboolean _tmp11_ = FALSE;
			_tmp1_ = vala_genie_parser_get_current_string (self);
			id = _tmp1_;
			_tmp3_ = id;
			_tmp4_ = id;
			_tmp5_ = strlen (_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = string_get (_tmp3_, (glong) (_tmp6_ - 1));
			_tmp8_ = g_ascii_isalpha (_tmp7_);
			if (_tmp8_) {
				const gchar* _tmp9_ = NULL;
				gboolean _tmp10_ = FALSE;
				_tmp9_ = id;
				_tmp10_ = string_contains (_tmp9_, ".");
				_tmp2_ = !_tmp10_;
			} else {
				_tmp2_ = FALSE;
			}
			_tmp11_ = _tmp2_;
			if (_tmp11_) {
				vala_genie_parser_next (self);
				_g_free0 (id);
				return;
			}
			_g_free0 (id);
			break;
		}
		default:
		{
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			GError* _tmp14_ = NULL;
			GError* _tmp15_ = NULL;
			_tmp12_ = vala_genie_parser_get_error (self, "expected identifier");
			_tmp13_ = _tmp12_;
			_tmp14_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp13_);
			_tmp15_ = _tmp14_;
			_g_free0 (_tmp13_);
			_inner_error_ = _tmp15_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static gchar* vala_genie_parser_parse_identifier (ValaGenieParser* self, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_skip_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_get_last_string (self);
	result = _tmp0_;
	return result;
}


static ValaExpression* vala_genie_parser_parse_literal (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieTokenType _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_current (self);
	switch (_tmp1_) {
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		{
			ValaSourceLocation _tmp2_ = {0};
			ValaSourceReference* _tmp3_ = NULL;
			ValaSourceReference* _tmp4_ = NULL;
			ValaBooleanLiteral* _tmp5_ = NULL;
			ValaExpression* _tmp6_ = NULL;
			vala_genie_parser_next (self);
			_tmp2_ = begin;
			_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
			_tmp4_ = _tmp3_;
			_tmp5_ = vala_boolean_literal_new (TRUE, _tmp4_);
			_tmp6_ = (ValaExpression*) _tmp5_;
			_vala_source_reference_unref0 (_tmp4_);
			result = _tmp6_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		{
			ValaSourceLocation _tmp7_ = {0};
			ValaSourceReference* _tmp8_ = NULL;
			ValaSourceReference* _tmp9_ = NULL;
			ValaBooleanLiteral* _tmp10_ = NULL;
			ValaExpression* _tmp11_ = NULL;
			vala_genie_parser_next (self);
			_tmp7_ = begin;
			_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = vala_boolean_literal_new (FALSE, _tmp9_);
			_tmp11_ = (ValaExpression*) _tmp10_;
			_vala_source_reference_unref0 (_tmp9_);
			result = _tmp11_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		{
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			ValaSourceLocation _tmp14_ = {0};
			ValaSourceReference* _tmp15_ = NULL;
			ValaSourceReference* _tmp16_ = NULL;
			ValaIntegerLiteral* _tmp17_ = NULL;
			ValaExpression* _tmp18_ = NULL;
			vala_genie_parser_next (self);
			_tmp12_ = vala_genie_parser_get_last_string (self);
			_tmp13_ = _tmp12_;
			_tmp14_ = begin;
			_tmp15_ = vala_genie_parser_get_src (self, &_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = vala_integer_literal_new (_tmp13_, _tmp16_);
			_tmp18_ = (ValaExpression*) _tmp17_;
			_vala_source_reference_unref0 (_tmp16_);
			_g_free0 (_tmp13_);
			result = _tmp18_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		{
			gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			ValaSourceLocation _tmp21_ = {0};
			ValaSourceReference* _tmp22_ = NULL;
			ValaSourceReference* _tmp23_ = NULL;
			ValaRealLiteral* _tmp24_ = NULL;
			ValaExpression* _tmp25_ = NULL;
			vala_genie_parser_next (self);
			_tmp19_ = vala_genie_parser_get_last_string (self);
			_tmp20_ = _tmp19_;
			_tmp21_ = begin;
			_tmp22_ = vala_genie_parser_get_src (self, &_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = vala_real_literal_new (_tmp20_, _tmp23_);
			_tmp25_ = (ValaExpression*) _tmp24_;
			_vala_source_reference_unref0 (_tmp23_);
			_g_free0 (_tmp20_);
			result = _tmp25_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
		{
			ValaCharacterLiteral* lit = NULL;
			gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			ValaSourceLocation _tmp28_ = {0};
			ValaSourceReference* _tmp29_ = NULL;
			ValaSourceReference* _tmp30_ = NULL;
			ValaCharacterLiteral* _tmp31_ = NULL;
			ValaCharacterLiteral* _tmp32_ = NULL;
			ValaCharacterLiteral* _tmp33_ = NULL;
			gboolean _tmp34_ = FALSE;
			gboolean _tmp35_ = FALSE;
			vala_genie_parser_next (self);
			_tmp26_ = vala_genie_parser_get_last_string (self);
			_tmp27_ = _tmp26_;
			_tmp28_ = begin;
			_tmp29_ = vala_genie_parser_get_src (self, &_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = vala_character_literal_new (_tmp27_, _tmp30_);
			_tmp32_ = _tmp31_;
			_vala_source_reference_unref0 (_tmp30_);
			_g_free0 (_tmp27_);
			lit = _tmp32_;
			_tmp33_ = lit;
			_tmp34_ = vala_code_node_get_error ((ValaCodeNode*) _tmp33_);
			_tmp35_ = _tmp34_;
			if (_tmp35_) {
				ValaCharacterLiteral* _tmp36_ = NULL;
				ValaSourceReference* _tmp37_ = NULL;
				ValaSourceReference* _tmp38_ = NULL;
				_tmp36_ = lit;
				_tmp37_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp36_);
				_tmp38_ = _tmp37_;
				vala_report_error (_tmp38_, "invalid character literal");
			}
			result = (ValaExpression*) lit;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
		{
			gchar* match_part = NULL;
			gchar* _tmp39_ = NULL;
			ValaSourceReference* src_begin = NULL;
			ValaSourceLocation _tmp40_ = {0};
			ValaSourceReference* _tmp41_ = NULL;
			gchar* close_token = NULL;
			gchar* _tmp42_ = NULL;
			const gchar* _tmp43_ = NULL;
			const gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			ValaSourceReference* _tmp47_ = NULL;
			ValaRegexLiteral* _tmp48_ = NULL;
			ValaExpression* _tmp49_ = NULL;
			vala_genie_parser_next (self);
			_tmp39_ = vala_genie_parser_get_last_string (self);
			match_part = _tmp39_;
			_tmp40_ = begin;
			_tmp41_ = vala_genie_parser_get_src (self, &_tmp40_);
			src_begin = _tmp41_;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_REGEX_LITERAL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					return NULL;
				} else {
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp42_ = vala_genie_parser_get_last_string (self);
			close_token = _tmp42_;
			_tmp43_ = close_token;
			_tmp44_ = match_part;
			_tmp45_ = g_strdup_printf ("%s/%s", _tmp43_, _tmp44_);
			_tmp46_ = _tmp45_;
			_tmp47_ = src_begin;
			_tmp48_ = vala_regex_literal_new (_tmp46_, _tmp47_);
			_tmp49_ = (ValaExpression*) _tmp48_;
			_g_free0 (_tmp46_);
			result = _tmp49_;
			_g_free0 (close_token);
			_vala_source_reference_unref0 (src_begin);
			_g_free0 (match_part);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
		{
			gchar* _tmp50_ = NULL;
			gchar* _tmp51_ = NULL;
			ValaSourceLocation _tmp52_ = {0};
			ValaSourceReference* _tmp53_ = NULL;
			ValaSourceReference* _tmp54_ = NULL;
			ValaStringLiteral* _tmp55_ = NULL;
			ValaExpression* _tmp56_ = NULL;
			vala_genie_parser_next (self);
			_tmp50_ = vala_genie_parser_get_last_string (self);
			_tmp51_ = _tmp50_;
			_tmp52_ = begin;
			_tmp53_ = vala_genie_parser_get_src (self, &_tmp52_);
			_tmp54_ = _tmp53_;
			_tmp55_ = vala_string_literal_new (_tmp51_, _tmp54_);
			_tmp56_ = (ValaExpression*) _tmp55_;
			_vala_source_reference_unref0 (_tmp54_);
			_g_free0 (_tmp51_);
			result = _tmp56_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		{
			gchar* _tmp57_ = NULL;
			gchar* _tmp58_ = NULL;
			gchar* _tmp59_ = NULL;
			gchar* _tmp60_ = NULL;
			ValaSourceLocation _tmp61_ = {0};
			ValaSourceReference* _tmp62_ = NULL;
			ValaSourceReference* _tmp63_ = NULL;
			ValaStringLiteral* _tmp64_ = NULL;
			ValaExpression* _tmp65_ = NULL;
			vala_genie_parser_next (self);
			_tmp57_ = vala_genie_parser_get_last_string (self);
			_tmp58_ = _tmp57_;
			_tmp59_ = g_strdup_printf ("\"%s\"", _tmp58_);
			_tmp60_ = _tmp59_;
			_tmp61_ = begin;
			_tmp62_ = vala_genie_parser_get_src (self, &_tmp61_);
			_tmp63_ = _tmp62_;
			_tmp64_ = vala_string_literal_new (_tmp60_, _tmp63_);
			_tmp65_ = (ValaExpression*) _tmp64_;
			_vala_source_reference_unref0 (_tmp63_);
			_g_free0 (_tmp60_);
			_g_free0 (_tmp58_);
			result = _tmp65_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		{
			gchar* raw_string = NULL;
			gchar* _tmp66_ = NULL;
			gchar* escaped_string = NULL;
			const gchar* _tmp67_ = NULL;
			const gchar* _tmp68_ = NULL;
			gint _tmp69_ = 0;
			gint _tmp70_ = 0;
			gchar* _tmp71_ = NULL;
			gchar* _tmp72_ = NULL;
			gchar* _tmp73_ = NULL;
			gchar* _tmp74_ = NULL;
			const gchar* _tmp75_ = NULL;
			gchar* _tmp76_ = NULL;
			gchar* _tmp77_ = NULL;
			ValaSourceLocation _tmp78_ = {0};
			ValaSourceReference* _tmp79_ = NULL;
			ValaSourceReference* _tmp80_ = NULL;
			ValaStringLiteral* _tmp81_ = NULL;
			ValaExpression* _tmp82_ = NULL;
			vala_genie_parser_next (self);
			_tmp66_ = vala_genie_parser_get_last_string (self);
			raw_string = _tmp66_;
			_tmp67_ = raw_string;
			_tmp68_ = raw_string;
			_tmp69_ = strlen (_tmp68_);
			_tmp70_ = _tmp69_;
			_tmp71_ = string_substring (_tmp67_, (glong) 3, (glong) (_tmp70_ - 6));
			_tmp72_ = _tmp71_;
			_tmp73_ = g_strescape (_tmp72_, "");
			_tmp74_ = _tmp73_;
			_g_free0 (_tmp72_);
			escaped_string = _tmp74_;
			_tmp75_ = escaped_string;
			_tmp76_ = g_strdup_printf ("\"%s\"", _tmp75_);
			_tmp77_ = _tmp76_;
			_tmp78_ = begin;
			_tmp79_ = vala_genie_parser_get_src (self, &_tmp78_);
			_tmp80_ = _tmp79_;
			_tmp81_ = vala_string_literal_new (_tmp77_, _tmp80_);
			_tmp82_ = (ValaExpression*) _tmp81_;
			_vala_source_reference_unref0 (_tmp80_);
			_g_free0 (_tmp77_);
			result = _tmp82_;
			_g_free0 (escaped_string);
			_g_free0 (raw_string);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_NULL:
		{
			ValaSourceLocation _tmp83_ = {0};
			ValaSourceReference* _tmp84_ = NULL;
			ValaSourceReference* _tmp85_ = NULL;
			ValaNullLiteral* _tmp86_ = NULL;
			ValaExpression* _tmp87_ = NULL;
			vala_genie_parser_next (self);
			_tmp83_ = begin;
			_tmp84_ = vala_genie_parser_get_src (self, &_tmp83_);
			_tmp85_ = _tmp84_;
			_tmp86_ = vala_null_literal_new (_tmp85_);
			_tmp87_ = (ValaExpression*) _tmp86_;
			_vala_source_reference_unref0 (_tmp85_);
			result = _tmp87_;
			return result;
		}
		default:
		{
			gchar* _tmp88_ = NULL;
			gchar* _tmp89_ = NULL;
			GError* _tmp90_ = NULL;
			GError* _tmp91_ = NULL;
			_tmp88_ = vala_genie_parser_get_error (self, "expected literal");
			_tmp89_ = _tmp88_;
			_tmp90_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp89_);
			_tmp91_ = _tmp90_;
			_g_free0 (_tmp89_);
			_inner_error_ = _tmp91_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
}


void vala_genie_parser_parse_file (ValaGenieParser* self, ValaSourceFile* source_file) {
	ValaSourceFile* _tmp0_ = NULL;
	ValaGenieScanner* _tmp1_ = NULL;
	ValaGenieScanner* _tmp2_ = NULL;
	ValaGenieScanner* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source_file != NULL);
	_tmp0_ = source_file;
	_tmp1_ = vala_genie_scanner_new (_tmp0_);
	_vala_genie_scanner_unref0 (self->priv->scanner);
	self->priv->scanner = _tmp1_;
	_tmp2_ = self->priv->scanner;
	vala_genie_scanner_parse_file_comments (_tmp2_);
	_tmp3_ = self->priv->scanner;
	vala_genie_scanner_set_indent_spaces (_tmp3_, 0);
	self->priv->index = -1;
	self->priv->size = 0;
	vala_genie_parser_next (self);
	{
		ValaSourceLocation begin = {0};
		ValaSourceLocation _tmp4_ = {0};
		gboolean _tmp5_ = FALSE;
		ValaCodeContext* _tmp13_ = NULL;
		ValaNamespace* _tmp14_ = NULL;
		ValaNamespace* _tmp15_ = NULL;
		ValaCodeContext* _tmp16_ = NULL;
		ValaNamespace* _tmp17_ = NULL;
		ValaNamespace* _tmp18_ = NULL;
		vala_genie_parser_get_location (self, &_tmp4_);
		begin = _tmp4_;
		_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
		if (_tmp5_) {
			gchar* id = NULL;
			gchar* _tmp6_ = NULL;
			const gchar* _tmp7_ = NULL;
			_tmp6_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			id = _tmp6_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					goto __catch6_vala_parse_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp7_ = id;
			if (g_strcmp0 (_tmp7_, "indent") == 0) {
				ValaGenieScanner* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_ = NULL;
				gint _tmp11_ = 0;
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch6_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch6_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_tmp8_ = self->priv->scanner;
				_tmp9_ = vala_genie_parser_get_last_string (self);
				_tmp10_ = _tmp9_;
				_tmp11_ = atoi (_tmp10_);
				vala_genie_scanner_set_indent_spaces (_tmp8_, _tmp11_);
				_g_free0 (_tmp10_);
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch6_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch6_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			} else {
				ValaSourceLocation _tmp12_ = {0};
				_tmp12_ = begin;
				vala_genie_parser_rollback (self, &_tmp12_);
			}
			_g_free0 (id);
		}
		_tmp13_ = self->priv->context;
		_tmp14_ = vala_code_context_get_root (_tmp13_);
		_tmp15_ = _tmp14_;
		vala_genie_parser_parse_using_directives (self, _tmp15_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch6_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp16_ = self->priv->context;
		_tmp17_ = vala_code_context_get_root (_tmp16_);
		_tmp18_ = _tmp17_;
		vala_genie_parser_parse_declarations (self, (ValaSymbol*) _tmp18_, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch6_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally6;
	__catch6_vala_parse_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_vala_genie_scanner_unref0 (self->priv->scanner);
	self->priv->scanner = NULL;
}


static void vala_genie_parser_skip_symbol_name (ValaGenieParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			_tmp1_ = _tmp0_;
			if (!_tmp1_) {
				gboolean _tmp2_ = FALSE;
				_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp0_ = FALSE;
			vala_genie_parser_skip_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static ValaUnresolvedSymbol* vala_genie_parser_parse_symbol_name (ValaGenieParser* self, GError** error) {
	ValaUnresolvedSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaUnresolvedSymbol* sym = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	sym = NULL;
	{
		gboolean _tmp1_ = FALSE;
		_tmp1_ = TRUE;
		while (TRUE) {
			gboolean _tmp2_ = FALSE;
			gchar* name = NULL;
			gchar* _tmp4_ = NULL;
			ValaUnresolvedSymbol* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			ValaSourceLocation _tmp7_ = {0};
			ValaSourceReference* _tmp8_ = NULL;
			ValaSourceReference* _tmp9_ = NULL;
			ValaUnresolvedSymbol* _tmp10_ = NULL;
			_tmp2_ = _tmp1_;
			if (!_tmp2_) {
				gboolean _tmp3_ = FALSE;
				_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			_tmp4_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			name = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp5_ = sym;
			_tmp6_ = name;
			_tmp7_ = begin;
			_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = vala_unresolved_symbol_new (_tmp5_, _tmp6_, _tmp9_);
			_vala_code_node_unref0 (sym);
			sym = _tmp10_;
			_vala_source_reference_unref0 (_tmp9_);
			_g_free0 (name);
		}
	}
	result = sym;
	return result;
}


static void vala_genie_parser_skip_type (ValaGenieParser* self, GError** error) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DYNAMIC);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_UNOWNED);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WEAK);
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY);
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST);
		_tmp1_ = _tmp3_;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT);
		_tmp0_ = _tmp5_;
	}
	_tmp6_ = _tmp0_;
	if (_tmp6_) {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF);
	}
	_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VOID);
	if (_tmp7_) {
	} else {
		vala_genie_parser_skip_symbol_name (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		vala_genie_parser_skip_type_argument_list (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	while (TRUE) {
		gboolean _tmp8_ = FALSE;
		_tmp8_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
		if (!_tmp8_) {
			break;
		}
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_ = FALSE;
				gboolean _tmp12_ = FALSE;
				ValaGenieTokenType _tmp13_ = 0;
				gboolean _tmp15_ = FALSE;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gboolean _tmp11_ = FALSE;
					_tmp11_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp11_) {
						break;
					}
				}
				_tmp9_ = FALSE;
				_tmp13_ = vala_genie_parser_current (self);
				if (_tmp13_ != VALA_GENIE_TOKEN_TYPE_COMMA) {
					ValaGenieTokenType _tmp14_ = 0;
					_tmp14_ = vala_genie_parser_current (self);
					_tmp12_ = _tmp14_ != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
				} else {
					_tmp12_ = FALSE;
				}
				_tmp15_ = _tmp12_;
				if (_tmp15_) {
					ValaExpression* _tmp16_ = NULL;
					ValaExpression* _tmp17_ = NULL;
					_tmp16_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					_tmp17_ = _tmp16_;
					_vala_code_node_unref0 (_tmp17_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_NEG);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_HASH);
}


static ValaExpression* vala_genie_parser_parse_regex_literal (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr = NULL;
	ValaExpression* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_literal (self, &_inner_error_);
	expr = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static gpointer _vala_iterable_ref0 (gpointer self) {
	return self ? vala_iterable_ref (self) : NULL;
}


static gpointer _vala_code_node_ref0 (gpointer self) {
	return self ? vala_code_node_ref (self) : NULL;
}


static ValaDataType* vala_genie_parser_parse_type (ValaGenieParser* self, gboolean owned_by_default, gboolean can_weak_ref, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaList* type_arg_list = NULL;
	ValaUnresolvedSymbol* sym = NULL;
	gboolean is_dynamic = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean value_owned = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean is_array = FALSE;
	gboolean _tmp16_ = FALSE;
	gboolean is_list = FALSE;
	gboolean _tmp17_ = FALSE;
	gboolean is_dict = FALSE;
	gboolean _tmp18_ = FALSE;
	ValaDataType* type = NULL;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_ = FALSE;
	gboolean _tmp21_ = FALSE;
	gboolean _tmp24_ = FALSE;
	gboolean _tmp26_ = FALSE;
	ValaDataType* _tmp82_ = NULL;
	gboolean _tmp85_ = FALSE;
	gboolean _tmp120_ = FALSE;
	ValaDataType* _tmp122_ = NULL;
	ValaDataType* _tmp123_ = NULL;
	gboolean _tmp124_ = FALSE;
	ValaDataType* _tmp125_ = NULL;
	gboolean _tmp126_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	type_arg_list = NULL;
	sym = NULL;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DYNAMIC);
	is_dynamic = _tmp1_;
	_tmp2_ = owned_by_default;
	value_owned = _tmp2_;
	_tmp3_ = owned_by_default;
	if (_tmp3_) {
		gboolean _tmp4_ = FALSE;
		_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_UNOWNED);
		if (_tmp4_) {
			value_owned = FALSE;
		} else {
			gboolean _tmp5_ = FALSE;
			_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WEAK);
			if (_tmp5_) {
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				gboolean _tmp11_ = FALSE;
				_tmp7_ = can_weak_ref;
				if (!_tmp7_) {
					ValaCodeContext* _tmp8_ = NULL;
					gboolean _tmp9_ = FALSE;
					gboolean _tmp10_ = FALSE;
					_tmp8_ = self->priv->context;
					_tmp9_ = vala_code_context_get_deprecated (_tmp8_);
					_tmp10_ = _tmp9_;
					_tmp6_ = !_tmp10_;
				} else {
					_tmp6_ = FALSE;
				}
				_tmp11_ = _tmp6_;
				if (_tmp11_) {
					ValaSourceLocation _tmp12_ = {0};
					ValaSourceReference* _tmp13_ = NULL;
					ValaSourceReference* _tmp14_ = NULL;
					_tmp12_ = begin;
					_tmp13_ = vala_genie_parser_get_src (self, &_tmp12_);
					_tmp14_ = _tmp13_;
					vala_report_warning (_tmp14_, "deprecated syntax, use `unowned` modifier");
					_vala_source_reference_unref0 (_tmp14_);
				}
				value_owned = FALSE;
			}
		}
	} else {
		gboolean _tmp15_ = FALSE;
		_tmp15_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED);
		value_owned = _tmp15_;
	}
	is_array = FALSE;
	_tmp16_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY);
	if (_tmp16_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		is_array = TRUE;
	}
	is_list = FALSE;
	_tmp17_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST);
	if (_tmp17_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_prev (self);
		is_list = TRUE;
	}
	is_dict = FALSE;
	_tmp18_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT);
	if (_tmp18_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_prev (self);
		is_dict = TRUE;
	}
	_tmp21_ = is_dynamic;
	if (!_tmp21_) {
		gboolean _tmp22_ = FALSE;
		gboolean _tmp23_ = FALSE;
		_tmp22_ = value_owned;
		_tmp23_ = owned_by_default;
		_tmp20_ = _tmp22_ == _tmp23_;
	} else {
		_tmp20_ = FALSE;
	}
	_tmp24_ = _tmp20_;
	if (_tmp24_) {
		gboolean _tmp25_ = FALSE;
		_tmp25_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VOID);
		_tmp19_ = _tmp25_;
	} else {
		_tmp19_ = FALSE;
	}
	_tmp26_ = _tmp19_;
	if (_tmp26_) {
		ValaSourceLocation _tmp27_ = {0};
		ValaSourceReference* _tmp28_ = NULL;
		ValaSourceReference* _tmp29_ = NULL;
		ValaVoidType* _tmp30_ = NULL;
		_tmp27_ = begin;
		_tmp28_ = vala_genie_parser_get_src (self, &_tmp27_);
		_tmp29_ = _tmp28_;
		_tmp30_ = vala_void_type_new (_tmp29_);
		_vala_code_node_unref0 (type);
		type = (ValaDataType*) _tmp30_;
		_vala_source_reference_unref0 (_tmp29_);
	} else {
		gboolean _tmp31_ = FALSE;
		ValaList* _tmp55_ = NULL;
		ValaList* _tmp56_ = NULL;
		ValaUnresolvedSymbol* _tmp57_ = NULL;
		ValaSourceLocation _tmp58_ = {0};
		ValaSourceReference* _tmp59_ = NULL;
		ValaSourceReference* _tmp60_ = NULL;
		ValaUnresolvedType* _tmp61_ = NULL;
		ValaList* _tmp62_ = NULL;
		_tmp31_ = is_list;
		if (_tmp31_) {
			ValaUnresolvedSymbol* sym_parent = NULL;
			ValaSourceLocation _tmp32_ = {0};
			ValaSourceReference* _tmp33_ = NULL;
			ValaSourceReference* _tmp34_ = NULL;
			ValaUnresolvedSymbol* _tmp35_ = NULL;
			ValaUnresolvedSymbol* _tmp36_ = NULL;
			ValaUnresolvedSymbol* _tmp37_ = NULL;
			ValaSourceLocation _tmp38_ = {0};
			ValaSourceReference* _tmp39_ = NULL;
			ValaSourceReference* _tmp40_ = NULL;
			ValaUnresolvedSymbol* _tmp41_ = NULL;
			_tmp32_ = begin;
			_tmp33_ = vala_genie_parser_get_src (self, &_tmp32_);
			_tmp34_ = _tmp33_;
			_tmp35_ = vala_unresolved_symbol_new (NULL, "Gee", _tmp34_);
			_tmp36_ = _tmp35_;
			_vala_source_reference_unref0 (_tmp34_);
			sym_parent = _tmp36_;
			_tmp37_ = sym_parent;
			_tmp38_ = begin;
			_tmp39_ = vala_genie_parser_get_src (self, &_tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = vala_unresolved_symbol_new (_tmp37_, "ArrayList", _tmp40_);
			_vala_code_node_unref0 (sym);
			sym = _tmp41_;
			_vala_source_reference_unref0 (_tmp40_);
			_vala_code_node_unref0 (sym_parent);
		} else {
			gboolean _tmp42_ = FALSE;
			_tmp42_ = is_dict;
			if (_tmp42_) {
				ValaUnresolvedSymbol* sym_parent = NULL;
				ValaSourceLocation _tmp43_ = {0};
				ValaSourceReference* _tmp44_ = NULL;
				ValaSourceReference* _tmp45_ = NULL;
				ValaUnresolvedSymbol* _tmp46_ = NULL;
				ValaUnresolvedSymbol* _tmp47_ = NULL;
				ValaUnresolvedSymbol* _tmp48_ = NULL;
				ValaSourceLocation _tmp49_ = {0};
				ValaSourceReference* _tmp50_ = NULL;
				ValaSourceReference* _tmp51_ = NULL;
				ValaUnresolvedSymbol* _tmp52_ = NULL;
				_tmp43_ = begin;
				_tmp44_ = vala_genie_parser_get_src (self, &_tmp43_);
				_tmp45_ = _tmp44_;
				_tmp46_ = vala_unresolved_symbol_new (NULL, "Gee", _tmp45_);
				_tmp47_ = _tmp46_;
				_vala_source_reference_unref0 (_tmp45_);
				sym_parent = _tmp47_;
				_tmp48_ = sym_parent;
				_tmp49_ = begin;
				_tmp50_ = vala_genie_parser_get_src (self, &_tmp49_);
				_tmp51_ = _tmp50_;
				_tmp52_ = vala_unresolved_symbol_new (_tmp48_, "HashMap", _tmp51_);
				_vala_code_node_unref0 (sym);
				sym = _tmp52_;
				_vala_source_reference_unref0 (_tmp51_);
				_vala_code_node_unref0 (sym_parent);
			} else {
				ValaUnresolvedSymbol* _tmp53_ = NULL;
				ValaUnresolvedSymbol* _tmp54_ = NULL;
				_tmp54_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
				_tmp53_ = _tmp54_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_iterable_unref0 (type_arg_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_iterable_unref0 (type_arg_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (sym);
				sym = _tmp53_;
			}
		}
		_tmp56_ = vala_genie_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
		_tmp55_ = _tmp56_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_vala_code_node_unref0 (sym);
				_vala_iterable_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_iterable_unref0 (type_arg_list);
		type_arg_list = _tmp55_;
		_tmp57_ = sym;
		_tmp58_ = begin;
		_tmp59_ = vala_genie_parser_get_src (self, &_tmp58_);
		_tmp60_ = _tmp59_;
		_tmp61_ = vala_unresolved_type_new_from_symbol (_tmp57_, _tmp60_);
		_vala_code_node_unref0 (type);
		type = (ValaDataType*) _tmp61_;
		_vala_source_reference_unref0 (_tmp60_);
		_tmp62_ = type_arg_list;
		if (_tmp62_ != NULL) {
			{
				ValaList* _type_arg_list = NULL;
				ValaList* _tmp63_ = NULL;
				ValaList* _tmp64_ = NULL;
				gint _type_arg_size = 0;
				ValaList* _tmp65_ = NULL;
				gint _tmp66_ = 0;
				gint _tmp67_ = 0;
				gint _type_arg_index = 0;
				_tmp63_ = type_arg_list;
				_tmp64_ = _vala_iterable_ref0 (_tmp63_);
				_type_arg_list = _tmp64_;
				_tmp65_ = _type_arg_list;
				_tmp66_ = vala_collection_get_size ((ValaCollection*) _tmp65_);
				_tmp67_ = _tmp66_;
				_type_arg_size = _tmp67_;
				_type_arg_index = -1;
				while (TRUE) {
					gint _tmp68_ = 0;
					gint _tmp69_ = 0;
					gint _tmp70_ = 0;
					ValaDataType* type_arg = NULL;
					ValaList* _tmp71_ = NULL;
					gint _tmp72_ = 0;
					gpointer _tmp73_ = NULL;
					ValaDataType* _tmp74_ = NULL;
					ValaDataType* _tmp75_ = NULL;
					_tmp68_ = _type_arg_index;
					_type_arg_index = _tmp68_ + 1;
					_tmp69_ = _type_arg_index;
					_tmp70_ = _type_arg_size;
					if (!(_tmp69_ < _tmp70_)) {
						break;
					}
					_tmp71_ = _type_arg_list;
					_tmp72_ = _type_arg_index;
					_tmp73_ = vala_list_get (_tmp71_, _tmp72_);
					type_arg = (ValaDataType*) _tmp73_;
					_tmp74_ = type;
					_tmp75_ = type_arg;
					vala_data_type_add_type_argument (_tmp74_, _tmp75_);
					_vala_code_node_unref0 (type_arg);
				}
				_vala_iterable_unref0 (_type_arg_list);
			}
		}
	}
	while (TRUE) {
		gboolean _tmp76_ = FALSE;
		ValaDataType* _tmp77_ = NULL;
		ValaSourceLocation _tmp78_ = {0};
		ValaSourceReference* _tmp79_ = NULL;
		ValaSourceReference* _tmp80_ = NULL;
		ValaPointerType* _tmp81_ = NULL;
		_tmp76_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_STAR);
		if (!_tmp76_) {
			break;
		}
		_tmp77_ = type;
		_tmp78_ = begin;
		_tmp79_ = vala_genie_parser_get_src (self, &_tmp78_);
		_tmp80_ = _tmp79_;
		_tmp81_ = vala_pointer_type_new (_tmp77_, _tmp80_);
		_vala_code_node_unref0 (type);
		type = (ValaDataType*) _tmp81_;
		_vala_source_reference_unref0 (_tmp80_);
	}
	_tmp82_ = type;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp82_, VALA_TYPE_POINTER_TYPE)) {
		ValaDataType* _tmp83_ = NULL;
		gboolean _tmp84_ = FALSE;
		_tmp83_ = type;
		_tmp84_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
		vala_data_type_set_nullable (_tmp83_, _tmp84_);
	}
	_tmp85_ = is_array;
	if (_tmp85_) {
		gboolean _tmp86_ = FALSE;
		_tmp86_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
		if (!_tmp86_) {
			ValaDataType* _tmp87_ = NULL;
			ValaDataType* _tmp88_ = NULL;
			ValaSourceLocation _tmp89_ = {0};
			ValaSourceReference* _tmp90_ = NULL;
			ValaSourceReference* _tmp91_ = NULL;
			ValaArrayType* _tmp92_ = NULL;
			ValaDataType* _tmp93_ = NULL;
			gboolean _tmp94_ = FALSE;
			_tmp87_ = type;
			vala_data_type_set_value_owned (_tmp87_, TRUE);
			_tmp88_ = type;
			_tmp89_ = begin;
			_tmp90_ = vala_genie_parser_get_src (self, &_tmp89_);
			_tmp91_ = _tmp90_;
			_tmp92_ = vala_array_type_new (_tmp88_, 1, _tmp91_);
			_vala_code_node_unref0 (type);
			type = (ValaDataType*) _tmp92_;
			_vala_source_reference_unref0 (_tmp91_);
			_tmp93_ = type;
			_tmp94_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
			vala_data_type_set_nullable (_tmp93_, _tmp94_);
		} else {
			vala_genie_parser_prev (self);
			while (TRUE) {
				gboolean _tmp95_ = FALSE;
				gboolean invalid_array = FALSE;
				gint array_rank = 0;
				ValaDataType* _tmp106_ = NULL;
				ValaArrayType* array_type = NULL;
				ValaDataType* _tmp107_ = NULL;
				gint _tmp108_ = 0;
				ValaSourceLocation _tmp109_ = {0};
				ValaSourceReference* _tmp110_ = NULL;
				ValaSourceReference* _tmp111_ = NULL;
				ValaArrayType* _tmp112_ = NULL;
				ValaArrayType* _tmp113_ = NULL;
				ValaArrayType* _tmp114_ = NULL;
				gboolean _tmp115_ = FALSE;
				ValaArrayType* _tmp116_ = NULL;
				gboolean _tmp117_ = FALSE;
				ValaArrayType* _tmp118_ = NULL;
				ValaDataType* _tmp119_ = NULL;
				_tmp95_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
				if (!_tmp95_) {
					break;
				}
				invalid_array = FALSE;
				array_rank = 0;
				{
					gboolean _tmp96_ = FALSE;
					_tmp96_ = TRUE;
					while (TRUE) {
						gboolean _tmp97_ = FALSE;
						gint _tmp99_ = 0;
						gboolean _tmp100_ = FALSE;
						ValaGenieTokenType _tmp101_ = 0;
						gboolean _tmp103_ = FALSE;
						_tmp97_ = _tmp96_;
						if (!_tmp97_) {
							gboolean _tmp98_ = FALSE;
							_tmp98_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
							if (!_tmp98_) {
								break;
							}
						}
						_tmp96_ = FALSE;
						_tmp99_ = array_rank;
						array_rank = _tmp99_ + 1;
						_tmp101_ = vala_genie_parser_current (self);
						if (_tmp101_ != VALA_GENIE_TOKEN_TYPE_COMMA) {
							ValaGenieTokenType _tmp102_ = 0;
							_tmp102_ = vala_genie_parser_current (self);
							_tmp100_ = _tmp102_ != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
						} else {
							_tmp100_ = FALSE;
						}
						_tmp103_ = _tmp100_;
						if (_tmp103_) {
							ValaExpression* _tmp104_ = NULL;
							ValaExpression* _tmp105_ = NULL;
							_tmp104_ = vala_genie_parser_parse_expression (self, &_inner_error_);
							_tmp105_ = _tmp104_;
							_vala_code_node_unref0 (_tmp105_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_code_node_unref0 (type);
									_vala_code_node_unref0 (sym);
									_vala_iterable_unref0 (type_arg_list);
									return NULL;
								} else {
									_vala_code_node_unref0 (type);
									_vala_code_node_unref0 (sym);
									_vala_iterable_unref0 (type_arg_list);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							invalid_array = TRUE;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_iterable_unref0 (type_arg_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_iterable_unref0 (type_arg_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp106_ = type;
				vala_data_type_set_value_owned (_tmp106_, TRUE);
				_tmp107_ = type;
				_tmp108_ = array_rank;
				_tmp109_ = begin;
				_tmp110_ = vala_genie_parser_get_src (self, &_tmp109_);
				_tmp111_ = _tmp110_;
				_tmp112_ = vala_array_type_new (_tmp107_, _tmp108_, _tmp111_);
				_tmp113_ = _tmp112_;
				_vala_source_reference_unref0 (_tmp111_);
				array_type = _tmp113_;
				_tmp114_ = array_type;
				_tmp115_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
				vala_data_type_set_nullable ((ValaDataType*) _tmp114_, _tmp115_);
				_tmp116_ = array_type;
				_tmp117_ = invalid_array;
				vala_array_type_set_invalid_syntax (_tmp116_, _tmp117_);
				_tmp118_ = array_type;
				_tmp119_ = _vala_code_node_ref0 ((ValaDataType*) _tmp118_);
				_vala_code_node_unref0 (type);
				type = _tmp119_;
				_vala_code_node_unref0 (array_type);
			}
		}
	}
	_tmp120_ = owned_by_default;
	if (!_tmp120_) {
		gboolean _tmp121_ = FALSE;
		_tmp121_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_HASH);
		value_owned = _tmp121_;
	}
	_tmp122_ = type;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp122_, VALA_TYPE_POINTER_TYPE)) {
		value_owned = FALSE;
	}
	_tmp123_ = type;
	_tmp124_ = is_dynamic;
	vala_data_type_set_is_dynamic (_tmp123_, _tmp124_);
	_tmp125_ = type;
	_tmp126_ = value_owned;
	vala_data_type_set_value_owned (_tmp125_, _tmp126_);
	result = type;
	_vala_code_node_unref0 (sym);
	_vala_iterable_unref0 (type_arg_list);
	return result;
}


static ValaDataType* vala_genie_parser_parse_inline_array_type (ValaGenieParser* self, ValaDataType* type, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	ValaDataType* _tmp2_ = NULL;
	gboolean _tmp4_ = FALSE;
	ValaDataType* _tmp32_ = NULL;
	ValaDataType* _tmp33_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp2_ = type;
	if (_tmp2_ != NULL) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		gint array_length = 0;
		ValaGenieTokenType _tmp5_ = 0;
		ValaArrayType* array_type = NULL;
		ValaDataType* _tmp17_ = NULL;
		ValaSourceLocation _tmp18_ = {0};
		ValaSourceReference* _tmp19_ = NULL;
		ValaSourceReference* _tmp20_ = NULL;
		ValaArrayType* _tmp21_ = NULL;
		ValaArrayType* _tmp22_ = NULL;
		ValaArrayType* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		ValaArrayType* _tmp28_ = NULL;
		ValaDataType* _tmp29_ = NULL;
		gboolean _tmp30_ = FALSE;
		gboolean _tmp31_ = FALSE;
		array_length = -1;
		_tmp5_ = vala_genie_parser_current (self);
		if (_tmp5_ != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET) {
			ValaGenieTokenType _tmp6_ = 0;
			ValaExpression* _tmp11_ = NULL;
			ValaExpression* _tmp12_ = NULL;
			ValaIntegerLiteral* length_literal = NULL;
			ValaIntegerLiteral* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			_tmp6_ = vala_genie_parser_current (self);
			if (_tmp6_ != VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL) {
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				GError* _tmp9_ = NULL;
				GError* _tmp10_ = NULL;
				_tmp7_ = vala_genie_parser_get_error (self, "expected `]' or integer literal");
				_tmp8_ = _tmp7_;
				_tmp9_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp8_);
				_tmp10_ = _tmp9_;
				_g_free0 (_tmp8_);
				_inner_error_ = _tmp10_;
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp12_ = vala_genie_parser_parse_literal (self, &_inner_error_);
			_tmp11_ = _tmp12_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			length_literal = G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteral);
			_tmp13_ = length_literal;
			_tmp14_ = vala_integer_literal_get_value (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = atoi (_tmp15_);
			array_length = _tmp16_;
			_vala_code_node_unref0 (length_literal);
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp17_ = type;
		_tmp18_ = begin;
		_tmp19_ = vala_genie_parser_get_src (self, &_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = vala_array_type_new (_tmp17_, 1, _tmp20_);
		_tmp22_ = _tmp21_;
		_vala_source_reference_unref0 (_tmp20_);
		array_type = _tmp22_;
		_tmp23_ = array_type;
		vala_array_type_set_inline_allocated (_tmp23_, TRUE);
		_tmp24_ = array_length;
		if (_tmp24_ > 0) {
			ValaArrayType* _tmp25_ = NULL;
			ValaArrayType* _tmp26_ = NULL;
			gint _tmp27_ = 0;
			_tmp25_ = array_type;
			vala_array_type_set_fixed_length (_tmp25_, TRUE);
			_tmp26_ = array_type;
			_tmp27_ = array_length;
			vala_array_type_set_length (_tmp26_, _tmp27_);
		}
		_tmp28_ = array_type;
		_tmp29_ = type;
		_tmp30_ = vala_data_type_get_value_owned (_tmp29_);
		_tmp31_ = _tmp30_;
		vala_data_type_set_value_owned ((ValaDataType*) _tmp28_, _tmp31_);
		result = (ValaDataType*) array_type;
		return result;
	}
	_tmp32_ = type;
	_tmp33_ = _vala_code_node_ref0 (_tmp32_);
	result = _tmp33_;
	return result;
}


static ValaList* vala_genie_parser_parse_argument_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list = NULL;
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	ValaGenieTokenType _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp0_);
	list = _tmp1_;
	_tmp2_ = vala_genie_parser_current (self);
	if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				ValaExpression* _tmp6_ = NULL;
				ValaExpression* _tmp7_ = NULL;
				ValaArrayList* _tmp8_ = NULL;
				ValaExpression* _tmp9_ = NULL;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gboolean _tmp5_ = FALSE;
					_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp5_) {
						break;
					}
				}
				_tmp3_ = FALSE;
				_tmp7_ = vala_genie_parser_parse_argument (self, &_inner_error_);
				_tmp6_ = _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (list);
						return NULL;
					} else {
						_vala_iterable_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp8_ = list;
				_tmp9_ = _tmp6_;
				vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
				_vala_code_node_unref0 (_tmp9_);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_argument (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REF);
	if (_tmp1_) {
		ValaExpression* inner = NULL;
		ValaExpression* _tmp2_ = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaSourceLocation _tmp4_ = {0};
		ValaSourceReference* _tmp5_ = NULL;
		ValaSourceReference* _tmp6_ = NULL;
		ValaUnaryExpression* _tmp7_ = NULL;
		ValaExpression* _tmp8_ = NULL;
		_tmp2_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		inner = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp3_ = inner;
		_tmp4_ = begin;
		_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = vala_unary_expression_new (VALA_UNARY_OPERATOR_REF, _tmp3_, _tmp6_);
		_tmp8_ = (ValaExpression*) _tmp7_;
		_vala_source_reference_unref0 (_tmp6_);
		result = _tmp8_;
		_vala_code_node_unref0 (inner);
		return result;
	} else {
		gboolean _tmp9_ = FALSE;
		_tmp9_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OUT);
		if (_tmp9_) {
			ValaExpression* inner = NULL;
			ValaExpression* _tmp10_ = NULL;
			ValaExpression* _tmp11_ = NULL;
			ValaSourceLocation _tmp12_ = {0};
			ValaSourceReference* _tmp13_ = NULL;
			ValaSourceReference* _tmp14_ = NULL;
			ValaUnaryExpression* _tmp15_ = NULL;
			ValaExpression* _tmp16_ = NULL;
			_tmp10_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			inner = _tmp10_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp11_ = inner;
			_tmp12_ = begin;
			_tmp13_ = vala_genie_parser_get_src (self, &_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = vala_unary_expression_new (VALA_UNARY_OPERATOR_OUT, _tmp11_, _tmp14_);
			_tmp16_ = (ValaExpression*) _tmp15_;
			_vala_source_reference_unref0 (_tmp14_);
			result = _tmp16_;
			_vala_code_node_unref0 (inner);
			return result;
		} else {
			ValaExpression* expr = NULL;
			ValaExpression* _tmp17_ = NULL;
			ValaMemberAccess* ma = NULL;
			ValaExpression* _tmp18_ = NULL;
			ValaMemberAccess* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			gboolean _tmp21_ = FALSE;
			ValaMemberAccess* _tmp22_ = NULL;
			gboolean _tmp26_ = FALSE;
			gboolean _tmp28_ = FALSE;
			_tmp17_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			expr = _tmp17_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp18_ = expr;
			_tmp19_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp18_, VALA_TYPE_MEMBER_ACCESS) ? ((ValaMemberAccess*) _tmp18_) : NULL);
			ma = _tmp19_;
			_tmp22_ = ma;
			if (_tmp22_ != NULL) {
				ValaMemberAccess* _tmp23_ = NULL;
				ValaExpression* _tmp24_ = NULL;
				ValaExpression* _tmp25_ = NULL;
				_tmp23_ = ma;
				_tmp24_ = vala_member_access_get_inner (_tmp23_);
				_tmp25_ = _tmp24_;
				_tmp21_ = _tmp25_ == NULL;
			} else {
				_tmp21_ = FALSE;
			}
			_tmp26_ = _tmp21_;
			if (_tmp26_) {
				gboolean _tmp27_ = FALSE;
				_tmp27_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
				_tmp20_ = _tmp27_;
			} else {
				_tmp20_ = FALSE;
			}
			_tmp28_ = _tmp20_;
			if (_tmp28_) {
				ValaExpression* _tmp29_ = NULL;
				ValaExpression* _tmp30_ = NULL;
				ValaMemberAccess* _tmp31_ = NULL;
				const gchar* _tmp32_ = NULL;
				const gchar* _tmp33_ = NULL;
				ValaExpression* _tmp34_ = NULL;
				ValaSourceLocation _tmp35_ = {0};
				ValaSourceReference* _tmp36_ = NULL;
				ValaSourceReference* _tmp37_ = NULL;
				ValaNamedArgument* _tmp38_ = NULL;
				ValaExpression* _tmp39_ = NULL;
				_tmp30_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				_tmp29_ = _tmp30_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp29_;
				_tmp31_ = ma;
				_tmp32_ = vala_member_access_get_member_name (_tmp31_);
				_tmp33_ = _tmp32_;
				_tmp34_ = expr;
				_tmp35_ = begin;
				_tmp36_ = vala_genie_parser_get_src (self, &_tmp35_);
				_tmp37_ = _tmp36_;
				_tmp38_ = vala_named_argument_new (_tmp33_, _tmp34_, _tmp37_);
				_tmp39_ = (ValaExpression*) _tmp38_;
				_vala_source_reference_unref0 (_tmp37_);
				result = _tmp39_;
				_vala_code_node_unref0 (ma);
				_vala_code_node_unref0 (expr);
				return result;
			} else {
				result = expr;
				_vala_code_node_unref0 (ma);
				return result;
			}
			_vala_code_node_unref0 (ma);
			_vala_code_node_unref0 (expr);
		}
	}
}


static ValaExpression* vala_genie_parser_parse_primary_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	ValaGenieTokenType _tmp1_ = 0;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_current (self);
	switch (_tmp1_) {
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_NULL:
		{
			ValaExpression* _tmp2_ = NULL;
			ValaExpression* _tmp3_ = NULL;
			_tmp3_ = vala_genie_parser_parse_literal (self, &_inner_error_);
			_tmp2_ = _tmp3_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp2_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSERT:
		{
			ValaExpression* _tmp4_ = NULL;
			ValaExpression* _tmp5_ = NULL;
			_tmp5_ = vala_genie_parser_parse_assert_expression (self, &_inner_error_);
			_tmp4_ = _tmp5_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp4_;
			_vala_code_node_unref0 (expr);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_BRACE:
		{
			ValaInitializerList* _tmp6_ = NULL;
			ValaInitializerList* _tmp7_ = NULL;
			_tmp7_ = vala_genie_parser_parse_initializer (self, &_inner_error_);
			_tmp6_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = (ValaExpression*) _tmp6_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		{
			ValaExpression* _tmp8_ = NULL;
			ValaExpression* _tmp9_ = NULL;
			_tmp9_ = vala_genie_parser_parse_tuple (self, &_inner_error_);
			_tmp8_ = _tmp9_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp8_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL:
		{
			ValaExpression* _tmp10_ = NULL;
			ValaExpression* _tmp11_ = NULL;
			_tmp11_ = vala_genie_parser_parse_regex_literal (self, &_inner_error_);
			_tmp10_ = _tmp11_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp10_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE:
		{
			ValaExpression* _tmp12_ = NULL;
			ValaExpression* _tmp13_ = NULL;
			_tmp13_ = vala_genie_parser_parse_template (self, &_inner_error_);
			_tmp12_ = _tmp13_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp12_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_THIS:
		{
			ValaExpression* _tmp14_ = NULL;
			ValaExpression* _tmp15_ = NULL;
			_tmp15_ = vala_genie_parser_parse_this_access (self, &_inner_error_);
			_tmp14_ = _tmp15_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp14_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_SUPER:
		{
			ValaExpression* _tmp16_ = NULL;
			ValaExpression* _tmp17_ = NULL;
			_tmp17_ = vala_genie_parser_parse_base_access (self, &_inner_error_);
			_tmp16_ = _tmp17_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp16_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_NEW:
		{
			ValaExpression* _tmp18_ = NULL;
			ValaExpression* _tmp19_ = NULL;
			_tmp19_ = vala_genie_parser_parse_object_or_array_creation_expression (self, &_inner_error_);
			_tmp18_ = _tmp19_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp18_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_PRINT:
		{
			ValaExpression* _tmp20_ = NULL;
			ValaExpression* _tmp21_ = NULL;
			_tmp21_ = vala_genie_parser_parse_print_expression (self, &_inner_error_);
			_tmp20_ = _tmp21_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp20_;
			_vala_code_node_unref0 (expr);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_SIZEOF:
		{
			ValaExpression* _tmp22_ = NULL;
			ValaExpression* _tmp23_ = NULL;
			_tmp23_ = vala_genie_parser_parse_sizeof_expression (self, &_inner_error_);
			_tmp22_ = _tmp23_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp22_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_TYPEOF:
		{
			ValaExpression* _tmp24_ = NULL;
			ValaExpression* _tmp25_ = NULL;
			_tmp25_ = vala_genie_parser_parse_typeof_expression (self, &_inner_error_);
			_tmp24_ = _tmp25_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp24_;
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			ValaExpression* _tmp26_ = NULL;
			ValaExpression* _tmp27_ = NULL;
			_tmp27_ = vala_genie_parser_parse_yield_expression (self, &_inner_error_);
			_tmp26_ = _tmp27_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp26_;
			break;
		}
		default:
		{
			ValaExpression* _tmp28_ = NULL;
			ValaExpression* _tmp29_ = NULL;
			_tmp29_ = vala_genie_parser_parse_simple_name (self, &_inner_error_);
			_tmp28_ = _tmp29_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (expr);
			expr = _tmp28_;
			break;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp30_ = FALSE;
		ValaGenieTokenType _tmp31_ = 0;
		_tmp30_ = found;
		if (!_tmp30_) {
			break;
		}
		_tmp31_ = vala_genie_parser_current (self);
		switch (_tmp31_) {
			case VALA_GENIE_TOKEN_TYPE_DOT:
			{
				ValaExpression* _tmp32_ = NULL;
				ValaSourceLocation _tmp33_ = {0};
				ValaExpression* _tmp34_ = NULL;
				ValaExpression* _tmp35_ = NULL;
				_tmp33_ = begin;
				_tmp34_ = expr;
				_tmp35_ = vala_genie_parser_parse_member_access (self, &_tmp33_, _tmp34_, &_inner_error_);
				_tmp32_ = _tmp35_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp32_;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_PTR:
			{
				ValaExpression* _tmp36_ = NULL;
				ValaSourceLocation _tmp37_ = {0};
				ValaExpression* _tmp38_ = NULL;
				ValaExpression* _tmp39_ = NULL;
				_tmp37_ = begin;
				_tmp38_ = expr;
				_tmp39_ = vala_genie_parser_parse_pointer_member_access (self, &_tmp37_, _tmp38_, &_inner_error_);
				_tmp36_ = _tmp39_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp36_;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
			{
				ValaExpression* _tmp40_ = NULL;
				ValaSourceLocation _tmp41_ = {0};
				ValaExpression* _tmp42_ = NULL;
				ValaExpression* _tmp43_ = NULL;
				_tmp41_ = begin;
				_tmp42_ = expr;
				_tmp43_ = vala_genie_parser_parse_method_call (self, &_tmp41_, _tmp42_, &_inner_error_);
				_tmp40_ = _tmp43_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp40_;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET:
			{
				ValaExpression* _tmp44_ = NULL;
				ValaSourceLocation _tmp45_ = {0};
				ValaExpression* _tmp46_ = NULL;
				ValaExpression* _tmp47_ = NULL;
				_tmp45_ = begin;
				_tmp46_ = expr;
				_tmp47_ = vala_genie_parser_parse_element_access (self, &_tmp45_, _tmp46_, &_inner_error_);
				_tmp44_ = _tmp47_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp44_;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_INC:
			{
				ValaExpression* _tmp48_ = NULL;
				ValaSourceLocation _tmp49_ = {0};
				ValaExpression* _tmp50_ = NULL;
				ValaExpression* _tmp51_ = NULL;
				_tmp49_ = begin;
				_tmp50_ = expr;
				_tmp51_ = vala_genie_parser_parse_post_increment_expression (self, &_tmp49_, _tmp50_, &_inner_error_);
				_tmp48_ = _tmp51_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp48_;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_DEC:
			{
				ValaExpression* _tmp52_ = NULL;
				ValaSourceLocation _tmp53_ = {0};
				ValaExpression* _tmp54_ = NULL;
				ValaExpression* _tmp55_ = NULL;
				_tmp53_ = begin;
				_tmp54_ = expr;
				_tmp55_ = vala_genie_parser_parse_post_decrement_expression (self, &_tmp53_, _tmp54_, &_inner_error_);
				_tmp52_ = _tmp55_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_vala_code_node_unref0 (expr);
				expr = _tmp52_;
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = expr;
	return result;
}


static ValaExpression* vala_genie_parser_parse_simple_name (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gchar* id = NULL;
	gchar* _tmp1_ = NULL;
	ValaList* type_arg_list = NULL;
	ValaList* _tmp2_ = NULL;
	ValaMemberAccess* expr = NULL;
	const gchar* _tmp3_ = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaMemberAccess* _tmp7_ = NULL;
	ValaMemberAccess* _tmp8_ = NULL;
	ValaList* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	type_arg_list = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = id;
	_tmp4_ = begin;
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_member_access_new (NULL, _tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	expr = _tmp8_;
	_tmp9_ = type_arg_list;
	if (_tmp9_ != NULL) {
		{
			ValaList* _type_arg_list = NULL;
			ValaList* _tmp10_ = NULL;
			ValaList* _tmp11_ = NULL;
			gint _type_arg_size = 0;
			ValaList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gint _type_arg_index = 0;
			_tmp10_ = type_arg_list;
			_tmp11_ = _vala_iterable_ref0 (_tmp10_);
			_type_arg_list = _tmp11_;
			_tmp12_ = _type_arg_list;
			_tmp13_ = vala_collection_get_size ((ValaCollection*) _tmp12_);
			_tmp14_ = _tmp13_;
			_type_arg_size = _tmp14_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				ValaDataType* type_arg = NULL;
				ValaList* _tmp18_ = NULL;
				gint _tmp19_ = 0;
				gpointer _tmp20_ = NULL;
				ValaMemberAccess* _tmp21_ = NULL;
				ValaDataType* _tmp22_ = NULL;
				_tmp15_ = _type_arg_index;
				_type_arg_index = _tmp15_ + 1;
				_tmp16_ = _type_arg_index;
				_tmp17_ = _type_arg_size;
				if (!(_tmp16_ < _tmp17_)) {
					break;
				}
				_tmp18_ = _type_arg_list;
				_tmp19_ = _type_arg_index;
				_tmp20_ = vala_list_get (_tmp18_, _tmp19_);
				type_arg = (ValaDataType*) _tmp20_;
				_tmp21_ = expr;
				_tmp22_ = type_arg;
				vala_member_access_add_type_argument (_tmp21_, _tmp22_);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_iterable_unref0 (_type_arg_list);
		}
	}
	result = (ValaExpression*) expr;
	_vala_iterable_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_template (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaTemplate* template = NULL;
	ValaTemplate* _tmp1_ = NULL;
	ValaTemplate* _tmp7_ = NULL;
	ValaSourceLocation _tmp8_ = {0};
	ValaSourceReference* _tmp9_ = NULL;
	ValaSourceReference* _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_template_new (NULL);
	template = _tmp1_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaGenieTokenType _tmp2_ = 0;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaTemplate* _tmp5_ = NULL;
		ValaExpression* _tmp6_ = NULL;
		_tmp2_ = vala_genie_parser_current (self);
		if (!(_tmp2_ != VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE)) {
			break;
		}
		_tmp4_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp3_ = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp5_ = template;
		_tmp6_ = _tmp3_;
		vala_template_add_expression (_tmp5_, _tmp6_);
		_vala_code_node_unref0 (_tmp6_);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COMMA, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp7_ = template;
	_tmp8_ = begin;
	_tmp9_ = vala_genie_parser_get_src (self, &_tmp8_);
	_tmp10_ = _tmp9_;
	vala_code_node_set_source_reference ((ValaCodeNode*) _tmp7_, _tmp10_);
	_vala_source_reference_unref0 (_tmp10_);
	result = (ValaExpression*) template;
	return result;
}


static ValaExpression* vala_genie_parser_parse_tuple (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaArrayList* expr_list = NULL;
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	ValaGenieTokenType _tmp2_ = 0;
	ValaArrayList* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	ValaArrayList* _tmp27_ = NULL;
	gpointer _tmp28_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp0_);
	expr_list = _tmp1_;
	_tmp2_ = vala_genie_parser_current (self);
	if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				ValaExpression* _tmp6_ = NULL;
				ValaExpression* _tmp7_ = NULL;
				ValaArrayList* _tmp8_ = NULL;
				ValaExpression* _tmp9_ = NULL;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gboolean _tmp5_ = FALSE;
					_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp5_) {
						break;
					}
				}
				_tmp3_ = FALSE;
				_tmp7_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				_tmp6_ = _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (expr_list);
						return NULL;
					} else {
						_vala_iterable_unref0 (expr_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp8_ = expr_list;
				_tmp9_ = _tmp6_;
				vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
				_vala_code_node_unref0 (_tmp9_);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (expr_list);
			return NULL;
		} else {
			_vala_iterable_unref0 (expr_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp10_ = expr_list;
	_tmp11_ = vala_collection_get_size ((ValaCollection*) _tmp10_);
	_tmp12_ = _tmp11_;
	if (_tmp12_ != 1) {
		ValaTuple* tuple = NULL;
		ValaTuple* _tmp13_ = NULL;
		_tmp13_ = vala_tuple_new (NULL);
		tuple = _tmp13_;
		{
			ValaArrayList* _expr_list = NULL;
			ValaArrayList* _tmp14_ = NULL;
			ValaArrayList* _tmp15_ = NULL;
			gint _expr_size = 0;
			ValaArrayList* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gint _tmp18_ = 0;
			gint _expr_index = 0;
			_tmp14_ = expr_list;
			_tmp15_ = _vala_iterable_ref0 (_tmp14_);
			_expr_list = _tmp15_;
			_tmp16_ = _expr_list;
			_tmp17_ = vala_collection_get_size ((ValaCollection*) _tmp16_);
			_tmp18_ = _tmp17_;
			_expr_size = _tmp18_;
			_expr_index = -1;
			while (TRUE) {
				gint _tmp19_ = 0;
				gint _tmp20_ = 0;
				gint _tmp21_ = 0;
				ValaExpression* expr = NULL;
				ValaArrayList* _tmp22_ = NULL;
				gint _tmp23_ = 0;
				gpointer _tmp24_ = NULL;
				ValaTuple* _tmp25_ = NULL;
				ValaExpression* _tmp26_ = NULL;
				_tmp19_ = _expr_index;
				_expr_index = _tmp19_ + 1;
				_tmp20_ = _expr_index;
				_tmp21_ = _expr_size;
				if (!(_tmp20_ < _tmp21_)) {
					break;
				}
				_tmp22_ = _expr_list;
				_tmp23_ = _expr_index;
				_tmp24_ = vala_list_get ((ValaList*) _tmp22_, _tmp23_);
				expr = (ValaExpression*) _tmp24_;
				_tmp25_ = tuple;
				_tmp26_ = expr;
				vala_tuple_add_expression (_tmp25_, _tmp26_);
				_vala_code_node_unref0 (expr);
			}
			_vala_iterable_unref0 (_expr_list);
		}
		result = (ValaExpression*) tuple;
		_vala_iterable_unref0 (expr_list);
		return result;
	}
	_tmp27_ = expr_list;
	_tmp28_ = vala_list_get ((ValaList*) _tmp27_, 0);
	result = (ValaExpression*) _tmp28_;
	_vala_iterable_unref0 (expr_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	gchar* id = NULL;
	gchar* _tmp0_ = NULL;
	ValaList* type_arg_list = NULL;
	ValaList* _tmp1_ = NULL;
	ValaMemberAccess* expr = NULL;
	ValaExpression* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaMemberAccess* _tmp7_ = NULL;
	ValaMemberAccess* _tmp8_ = NULL;
	ValaList* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DOT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	type_arg_list = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = inner;
	_tmp3_ = id;
	_tmp4_ = *begin;
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_member_access_new (_tmp2_, _tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	expr = _tmp8_;
	_tmp9_ = type_arg_list;
	if (_tmp9_ != NULL) {
		{
			ValaList* _type_arg_list = NULL;
			ValaList* _tmp10_ = NULL;
			ValaList* _tmp11_ = NULL;
			gint _type_arg_size = 0;
			ValaList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gint _type_arg_index = 0;
			_tmp10_ = type_arg_list;
			_tmp11_ = _vala_iterable_ref0 (_tmp10_);
			_type_arg_list = _tmp11_;
			_tmp12_ = _type_arg_list;
			_tmp13_ = vala_collection_get_size ((ValaCollection*) _tmp12_);
			_tmp14_ = _tmp13_;
			_type_arg_size = _tmp14_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				ValaDataType* type_arg = NULL;
				ValaList* _tmp18_ = NULL;
				gint _tmp19_ = 0;
				gpointer _tmp20_ = NULL;
				ValaMemberAccess* _tmp21_ = NULL;
				ValaDataType* _tmp22_ = NULL;
				_tmp15_ = _type_arg_index;
				_type_arg_index = _tmp15_ + 1;
				_tmp16_ = _type_arg_index;
				_tmp17_ = _type_arg_size;
				if (!(_tmp16_ < _tmp17_)) {
					break;
				}
				_tmp18_ = _type_arg_list;
				_tmp19_ = _type_arg_index;
				_tmp20_ = vala_list_get (_tmp18_, _tmp19_);
				type_arg = (ValaDataType*) _tmp20_;
				_tmp21_ = expr;
				_tmp22_ = type_arg;
				vala_member_access_add_type_argument (_tmp21_, _tmp22_);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_iterable_unref0 (_type_arg_list);
		}
	}
	result = (ValaExpression*) expr;
	_vala_iterable_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_pointer_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	gchar* id = NULL;
	gchar* _tmp0_ = NULL;
	ValaList* type_arg_list = NULL;
	ValaList* _tmp1_ = NULL;
	ValaMemberAccess* expr = NULL;
	ValaExpression* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaMemberAccess* _tmp7_ = NULL;
	ValaMemberAccess* _tmp8_ = NULL;
	ValaList* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_PTR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	type_arg_list = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = inner;
	_tmp3_ = id;
	_tmp4_ = *begin;
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_member_access_new_pointer (_tmp2_, _tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	expr = _tmp8_;
	_tmp9_ = type_arg_list;
	if (_tmp9_ != NULL) {
		{
			ValaList* _type_arg_list = NULL;
			ValaList* _tmp10_ = NULL;
			ValaList* _tmp11_ = NULL;
			gint _type_arg_size = 0;
			ValaList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gint _type_arg_index = 0;
			_tmp10_ = type_arg_list;
			_tmp11_ = _vala_iterable_ref0 (_tmp10_);
			_type_arg_list = _tmp11_;
			_tmp12_ = _type_arg_list;
			_tmp13_ = vala_collection_get_size ((ValaCollection*) _tmp12_);
			_tmp14_ = _tmp13_;
			_type_arg_size = _tmp14_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				ValaDataType* type_arg = NULL;
				ValaList* _tmp18_ = NULL;
				gint _tmp19_ = 0;
				gpointer _tmp20_ = NULL;
				ValaMemberAccess* _tmp21_ = NULL;
				ValaDataType* _tmp22_ = NULL;
				_tmp15_ = _type_arg_index;
				_type_arg_index = _tmp15_ + 1;
				_tmp16_ = _type_arg_index;
				_tmp17_ = _type_arg_size;
				if (!(_tmp16_ < _tmp17_)) {
					break;
				}
				_tmp18_ = _type_arg_list;
				_tmp19_ = _type_arg_index;
				_tmp20_ = vala_list_get (_tmp18_, _tmp19_);
				type_arg = (ValaDataType*) _tmp20_;
				_tmp21_ = expr;
				_tmp22_ = type_arg;
				vala_member_access_add_type_argument (_tmp21_, _tmp22_);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_iterable_unref0 (_type_arg_list);
		}
	}
	result = (ValaExpression*) expr;
	_vala_iterable_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaList* vala_genie_parser_parse_print_argument_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list = NULL;
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	gint i = 0;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp2_ = {0};
	ValaGenieTokenType _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp0_);
	list = _tmp1_;
	i = 0;
	vala_genie_parser_get_location (self, &_tmp2_);
	begin = _tmp2_;
	_tmp3_ = vala_genie_parser_current (self);
	if (_tmp3_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_ = FALSE;
				ValaExpression* p_expr = NULL;
				ValaExpression* _tmp7_ = NULL;
				gint _tmp8_ = 0;
				ValaArrayList* _tmp46_ = NULL;
				ValaExpression* _tmp47_ = NULL;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gboolean _tmp6_ = FALSE;
					_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp6_) {
						break;
					}
				}
				_tmp4_ = FALSE;
				_tmp7_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				p_expr = _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (list);
						return NULL;
					} else {
						_vala_iterable_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp8_ = i;
				if (_tmp8_ == 0) {
					gint _tmp9_ = 0;
					ValaExpression* _tmp10_ = NULL;
					_tmp9_ = i;
					i = _tmp9_ + 1;
					_tmp10_ = p_expr;
					if (_tmp10_ != NULL) {
						ValaExpression* _tmp11_ = NULL;
						_tmp11_ = p_expr;
						if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, VALA_TYPE_STRING_LITERAL)) {
							ValaStringLiteral* s_exp = NULL;
							ValaExpression* _tmp12_ = NULL;
							ValaStringLiteral* _tmp13_ = NULL;
							gint len = 0;
							ValaStringLiteral* _tmp14_ = NULL;
							const gchar* _tmp15_ = NULL;
							const gchar* _tmp16_ = NULL;
							gint _tmp17_ = 0;
							gint _tmp18_ = 0;
							gint _tmp19_ = 0;
							_tmp12_ = p_expr;
							_tmp13_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp12_, VALA_TYPE_STRING_LITERAL, ValaStringLiteral));
							s_exp = _tmp13_;
							_tmp14_ = s_exp;
							_tmp15_ = vala_string_literal_get_value (_tmp14_);
							_tmp16_ = _tmp15_;
							_tmp17_ = strlen (_tmp16_);
							_tmp18_ = _tmp17_;
							len = _tmp18_;
							_tmp19_ = len;
							if (_tmp19_ > 2) {
								gchar* s = NULL;
								gchar* _tmp20_ = NULL;
								gchar* st = NULL;
								ValaStringLiteral* _tmp21_ = NULL;
								const gchar* _tmp22_ = NULL;
								const gchar* _tmp23_ = NULL;
								gint _tmp24_ = 0;
								gchar* _tmp25_ = NULL;
								const gchar* _tmp26_ = NULL;
								const gchar* _tmp27_ = NULL;
								gchar* _tmp28_ = NULL;
								ValaStringLiteral* _tmp29_ = NULL;
								const gchar* _tmp30_ = NULL;
								_tmp20_ = g_strdup ("\\n\"");
								s = _tmp20_;
								_tmp21_ = s_exp;
								_tmp22_ = vala_string_literal_get_value (_tmp21_);
								_tmp23_ = _tmp22_;
								_tmp24_ = len;
								_tmp25_ = string_substring (_tmp23_, (glong) 0, (glong) (_tmp24_ - 1));
								st = _tmp25_;
								_tmp26_ = st;
								_tmp27_ = s;
								_tmp28_ = g_strconcat (_tmp26_, _tmp27_, NULL);
								_g_free0 (st);
								st = _tmp28_;
								_tmp29_ = s_exp;
								_tmp30_ = st;
								vala_string_literal_set_value (_tmp29_, _tmp30_);
								_g_free0 (st);
								_g_free0 (s);
							} else {
								gchar* s = NULL;
								gchar* _tmp31_ = NULL;
								const gchar* _tmp32_ = NULL;
								ValaSourceLocation _tmp33_ = {0};
								ValaSourceReference* _tmp34_ = NULL;
								ValaSourceReference* _tmp35_ = NULL;
								ValaStringLiteral* _tmp36_ = NULL;
								_tmp31_ = g_strdup ("\"\\n\"");
								s = _tmp31_;
								_tmp32_ = s;
								_tmp33_ = begin;
								_tmp34_ = vala_genie_parser_get_src (self, &_tmp33_);
								_tmp35_ = _tmp34_;
								_tmp36_ = vala_string_literal_new (_tmp32_, _tmp35_);
								_vala_code_node_unref0 (p_expr);
								p_expr = (ValaExpression*) _tmp36_;
								_vala_source_reference_unref0 (_tmp35_);
								_g_free0 (s);
							}
							_vala_code_node_unref0 (s_exp);
						} else {
							gchar* s = NULL;
							gchar* _tmp37_ = NULL;
							ValaStringLiteral* s_exp = NULL;
							const gchar* _tmp38_ = NULL;
							ValaSourceLocation _tmp39_ = {0};
							ValaSourceReference* _tmp40_ = NULL;
							ValaSourceReference* _tmp41_ = NULL;
							ValaStringLiteral* _tmp42_ = NULL;
							ValaStringLiteral* _tmp43_ = NULL;
							ValaArrayList* _tmp44_ = NULL;
							ValaStringLiteral* _tmp45_ = NULL;
							_tmp37_ = g_strdup ("\"%s\\n\"");
							s = _tmp37_;
							_tmp38_ = s;
							_tmp39_ = begin;
							_tmp40_ = vala_genie_parser_get_src (self, &_tmp39_);
							_tmp41_ = _tmp40_;
							_tmp42_ = vala_string_literal_new (_tmp38_, _tmp41_);
							_tmp43_ = _tmp42_;
							_vala_source_reference_unref0 (_tmp41_);
							s_exp = _tmp43_;
							_tmp44_ = list;
							_tmp45_ = s_exp;
							vala_collection_add ((ValaCollection*) _tmp44_, (ValaExpression*) _tmp45_);
							_vala_code_node_unref0 (s_exp);
							_g_free0 (s);
						}
					}
				}
				_tmp46_ = list;
				_tmp47_ = p_expr;
				vala_collection_add ((ValaCollection*) _tmp46_, _tmp47_);
				_vala_code_node_unref0 (p_expr);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_print_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean parens = FALSE;
	gboolean _tmp1_ = FALSE;
	ValaMemberAccess* expr = NULL;
	ValaSourceLocation _tmp2_ = {0};
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaMemberAccess* _tmp5_ = NULL;
	ValaMemberAccess* _tmp6_ = NULL;
	ValaList* arg_list = NULL;
	ValaList* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	ValaMethodCall* print_expr = NULL;
	ValaMemberAccess* _tmp9_ = NULL;
	ValaSourceLocation _tmp10_ = {0};
	ValaSourceReference* _tmp11_ = NULL;
	ValaSourceReference* _tmp12_ = NULL;
	ValaMethodCall* _tmp13_ = NULL;
	ValaMethodCall* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_PRINT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	parens = _tmp1_;
	_tmp2_ = begin;
	_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_member_access_new (NULL, "print", _tmp4_);
	_tmp6_ = _tmp5_;
	_vala_source_reference_unref0 (_tmp4_);
	expr = _tmp6_;
	_tmp7_ = vala_genie_parser_parse_print_argument_list (self, &_inner_error_);
	arg_list = _tmp7_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = parens;
	if (_tmp8_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_iterable_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp9_ = expr;
	_tmp10_ = begin;
	_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = vala_method_call_new ((ValaExpression*) _tmp9_, _tmp12_);
	_tmp14_ = _tmp13_;
	_vala_source_reference_unref0 (_tmp12_);
	print_expr = _tmp14_;
	{
		ValaList* _arg_list = NULL;
		ValaList* _tmp15_ = NULL;
		ValaList* _tmp16_ = NULL;
		gint _arg_size = 0;
		ValaList* _tmp17_ = NULL;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		gint _arg_index = 0;
		_tmp15_ = arg_list;
		_tmp16_ = _vala_iterable_ref0 (_tmp15_);
		_arg_list = _tmp16_;
		_tmp17_ = _arg_list;
		_tmp18_ = vala_collection_get_size ((ValaCollection*) _tmp17_);
		_tmp19_ = _tmp18_;
		_arg_size = _tmp19_;
		_arg_index = -1;
		while (TRUE) {
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			ValaExpression* arg = NULL;
			ValaList* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			gpointer _tmp25_ = NULL;
			ValaMethodCall* _tmp26_ = NULL;
			ValaExpression* _tmp27_ = NULL;
			_tmp20_ = _arg_index;
			_arg_index = _tmp20_ + 1;
			_tmp21_ = _arg_index;
			_tmp22_ = _arg_size;
			if (!(_tmp21_ < _tmp22_)) {
				break;
			}
			_tmp23_ = _arg_list;
			_tmp24_ = _arg_index;
			_tmp25_ = vala_list_get (_tmp23_, _tmp24_);
			arg = (ValaExpression*) _tmp25_;
			_tmp26_ = print_expr;
			_tmp27_ = arg;
			vala_method_call_add_argument (_tmp26_, _tmp27_);
			_vala_code_node_unref0 (arg);
		}
		_vala_iterable_unref0 (_arg_list);
	}
	result = (ValaExpression*) print_expr;
	_vala_iterable_unref0 (arg_list);
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_assert_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean parens = FALSE;
	gboolean _tmp1_ = FALSE;
	ValaMemberAccess* expr = NULL;
	ValaSourceLocation _tmp2_ = {0};
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaMemberAccess* _tmp5_ = NULL;
	ValaMemberAccess* _tmp6_ = NULL;
	ValaList* arg_list = NULL;
	ValaList* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	ValaMethodCall* assert_expr = NULL;
	ValaMemberAccess* _tmp9_ = NULL;
	ValaSourceLocation _tmp10_ = {0};
	ValaSourceReference* _tmp11_ = NULL;
	ValaSourceReference* _tmp12_ = NULL;
	ValaMethodCall* _tmp13_ = NULL;
	ValaMethodCall* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSERT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	parens = _tmp1_;
	_tmp2_ = begin;
	_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_member_access_new (NULL, "assert", _tmp4_);
	_tmp6_ = _tmp5_;
	_vala_source_reference_unref0 (_tmp4_);
	expr = _tmp6_;
	_tmp7_ = vala_genie_parser_parse_argument_list (self, &_inner_error_);
	arg_list = _tmp7_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = parens;
	if (_tmp8_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_iterable_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp9_ = expr;
	_tmp10_ = begin;
	_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = vala_method_call_new ((ValaExpression*) _tmp9_, _tmp12_);
	_tmp14_ = _tmp13_;
	_vala_source_reference_unref0 (_tmp12_);
	assert_expr = _tmp14_;
	{
		ValaList* _arg_list = NULL;
		ValaList* _tmp15_ = NULL;
		ValaList* _tmp16_ = NULL;
		gint _arg_size = 0;
		ValaList* _tmp17_ = NULL;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		gint _arg_index = 0;
		_tmp15_ = arg_list;
		_tmp16_ = _vala_iterable_ref0 (_tmp15_);
		_arg_list = _tmp16_;
		_tmp17_ = _arg_list;
		_tmp18_ = vala_collection_get_size ((ValaCollection*) _tmp17_);
		_tmp19_ = _tmp18_;
		_arg_size = _tmp19_;
		_arg_index = -1;
		while (TRUE) {
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			ValaExpression* arg = NULL;
			ValaList* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			gpointer _tmp25_ = NULL;
			ValaMethodCall* _tmp26_ = NULL;
			ValaExpression* _tmp27_ = NULL;
			_tmp20_ = _arg_index;
			_arg_index = _tmp20_ + 1;
			_tmp21_ = _arg_index;
			_tmp22_ = _arg_size;
			if (!(_tmp21_ < _tmp22_)) {
				break;
			}
			_tmp23_ = _arg_list;
			_tmp24_ = _arg_index;
			_tmp25_ = vala_list_get (_tmp23_, _tmp24_);
			arg = (ValaExpression*) _tmp25_;
			_tmp26_ = assert_expr;
			_tmp27_ = arg;
			vala_method_call_add_argument (_tmp26_, _tmp27_);
			_vala_code_node_unref0 (arg);
		}
		_vala_iterable_unref0 (_arg_list);
	}
	result = (ValaExpression*) assert_expr;
	_vala_iterable_unref0 (arg_list);
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_method_call (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* arg_list = NULL;
	ValaList* _tmp0_ = NULL;
	ValaList* init_list = NULL;
	ValaList* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	ValaList* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_argument_list (self, &_inner_error_);
	arg_list = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (arg_list);
			return NULL;
		} else {
			_vala_iterable_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_object_initializer (self, &_inner_error_);
	init_list = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (arg_list);
			return NULL;
		} else {
			_vala_iterable_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = init_list;
	_tmp4_ = vala_collection_get_size ((ValaCollection*) _tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ > 0) {
		ValaExpression* _tmp6_ = NULL;
		_tmp6_ = inner;
		_tmp2_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, VALA_TYPE_MEMBER_ACCESS);
	} else {
		_tmp2_ = FALSE;
	}
	_tmp7_ = _tmp2_;
	if (_tmp7_) {
		ValaMemberAccess* member = NULL;
		ValaExpression* _tmp8_ = NULL;
		ValaMemberAccess* _tmp9_ = NULL;
		ValaMemberAccess* _tmp10_ = NULL;
		ValaObjectCreationExpression* expr = NULL;
		ValaMemberAccess* _tmp11_ = NULL;
		ValaSourceLocation _tmp12_ = {0};
		ValaSourceReference* _tmp13_ = NULL;
		ValaSourceReference* _tmp14_ = NULL;
		ValaObjectCreationExpression* _tmp15_ = NULL;
		ValaObjectCreationExpression* _tmp16_ = NULL;
		ValaObjectCreationExpression* _tmp17_ = NULL;
		_tmp8_ = inner;
		_tmp9_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp8_, VALA_TYPE_MEMBER_ACCESS, ValaMemberAccess));
		member = _tmp9_;
		_tmp10_ = member;
		vala_member_access_set_creation_member (_tmp10_, TRUE);
		_tmp11_ = member;
		_tmp12_ = *begin;
		_tmp13_ = vala_genie_parser_get_src (self, &_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = vala_object_creation_expression_new (_tmp11_, _tmp14_);
		_tmp16_ = _tmp15_;
		_vala_source_reference_unref0 (_tmp14_);
		expr = _tmp16_;
		_tmp17_ = expr;
		vala_object_creation_expression_set_struct_creation (_tmp17_, TRUE);
		{
			ValaList* _arg_list = NULL;
			ValaList* _tmp18_ = NULL;
			ValaList* _tmp19_ = NULL;
			gint _arg_size = 0;
			ValaList* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			gint _arg_index = 0;
			_tmp18_ = arg_list;
			_tmp19_ = _vala_iterable_ref0 (_tmp18_);
			_arg_list = _tmp19_;
			_tmp20_ = _arg_list;
			_tmp21_ = vala_collection_get_size ((ValaCollection*) _tmp20_);
			_tmp22_ = _tmp21_;
			_arg_size = _tmp22_;
			_arg_index = -1;
			while (TRUE) {
				gint _tmp23_ = 0;
				gint _tmp24_ = 0;
				gint _tmp25_ = 0;
				ValaExpression* arg = NULL;
				ValaList* _tmp26_ = NULL;
				gint _tmp27_ = 0;
				gpointer _tmp28_ = NULL;
				ValaObjectCreationExpression* _tmp29_ = NULL;
				ValaExpression* _tmp30_ = NULL;
				_tmp23_ = _arg_index;
				_arg_index = _tmp23_ + 1;
				_tmp24_ = _arg_index;
				_tmp25_ = _arg_size;
				if (!(_tmp24_ < _tmp25_)) {
					break;
				}
				_tmp26_ = _arg_list;
				_tmp27_ = _arg_index;
				_tmp28_ = vala_list_get (_tmp26_, _tmp27_);
				arg = (ValaExpression*) _tmp28_;
				_tmp29_ = expr;
				_tmp30_ = arg;
				vala_object_creation_expression_add_argument (_tmp29_, _tmp30_);
				_vala_code_node_unref0 (arg);
			}
			_vala_iterable_unref0 (_arg_list);
		}
		{
			ValaList* _initializer_list = NULL;
			ValaList* _tmp31_ = NULL;
			ValaList* _tmp32_ = NULL;
			gint _initializer_size = 0;
			ValaList* _tmp33_ = NULL;
			gint _tmp34_ = 0;
			gint _tmp35_ = 0;
			gint _initializer_index = 0;
			_tmp31_ = init_list;
			_tmp32_ = _vala_iterable_ref0 (_tmp31_);
			_initializer_list = _tmp32_;
			_tmp33_ = _initializer_list;
			_tmp34_ = vala_collection_get_size ((ValaCollection*) _tmp33_);
			_tmp35_ = _tmp34_;
			_initializer_size = _tmp35_;
			_initializer_index = -1;
			while (TRUE) {
				gint _tmp36_ = 0;
				gint _tmp37_ = 0;
				gint _tmp38_ = 0;
				ValaMemberInitializer* initializer = NULL;
				ValaList* _tmp39_ = NULL;
				gint _tmp40_ = 0;
				gpointer _tmp41_ = NULL;
				ValaObjectCreationExpression* _tmp42_ = NULL;
				ValaMemberInitializer* _tmp43_ = NULL;
				_tmp36_ = _initializer_index;
				_initializer_index = _tmp36_ + 1;
				_tmp37_ = _initializer_index;
				_tmp38_ = _initializer_size;
				if (!(_tmp37_ < _tmp38_)) {
					break;
				}
				_tmp39_ = _initializer_list;
				_tmp40_ = _initializer_index;
				_tmp41_ = vala_list_get (_tmp39_, _tmp40_);
				initializer = (ValaMemberInitializer*) _tmp41_;
				_tmp42_ = expr;
				_tmp43_ = initializer;
				vala_object_creation_expression_add_member_initializer (_tmp42_, _tmp43_);
				_vala_code_node_unref0 (initializer);
			}
			_vala_iterable_unref0 (_initializer_list);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (member);
		_vala_iterable_unref0 (init_list);
		_vala_iterable_unref0 (arg_list);
		return result;
	} else {
		ValaMethodCall* expr = NULL;
		ValaExpression* _tmp44_ = NULL;
		ValaSourceLocation _tmp45_ = {0};
		ValaSourceReference* _tmp46_ = NULL;
		ValaSourceReference* _tmp47_ = NULL;
		ValaMethodCall* _tmp48_ = NULL;
		ValaMethodCall* _tmp49_ = NULL;
		_tmp44_ = inner;
		_tmp45_ = *begin;
		_tmp46_ = vala_genie_parser_get_src (self, &_tmp45_);
		_tmp47_ = _tmp46_;
		_tmp48_ = vala_method_call_new (_tmp44_, _tmp47_);
		_tmp49_ = _tmp48_;
		_vala_source_reference_unref0 (_tmp47_);
		expr = _tmp49_;
		{
			ValaList* _arg_list = NULL;
			ValaList* _tmp50_ = NULL;
			ValaList* _tmp51_ = NULL;
			gint _arg_size = 0;
			ValaList* _tmp52_ = NULL;
			gint _tmp53_ = 0;
			gint _tmp54_ = 0;
			gint _arg_index = 0;
			_tmp50_ = arg_list;
			_tmp51_ = _vala_iterable_ref0 (_tmp50_);
			_arg_list = _tmp51_;
			_tmp52_ = _arg_list;
			_tmp53_ = vala_collection_get_size ((ValaCollection*) _tmp52_);
			_tmp54_ = _tmp53_;
			_arg_size = _tmp54_;
			_arg_index = -1;
			while (TRUE) {
				gint _tmp55_ = 0;
				gint _tmp56_ = 0;
				gint _tmp57_ = 0;
				ValaExpression* arg = NULL;
				ValaList* _tmp58_ = NULL;
				gint _tmp59_ = 0;
				gpointer _tmp60_ = NULL;
				ValaMethodCall* _tmp61_ = NULL;
				ValaExpression* _tmp62_ = NULL;
				_tmp55_ = _arg_index;
				_arg_index = _tmp55_ + 1;
				_tmp56_ = _arg_index;
				_tmp57_ = _arg_size;
				if (!(_tmp56_ < _tmp57_)) {
					break;
				}
				_tmp58_ = _arg_list;
				_tmp59_ = _arg_index;
				_tmp60_ = vala_list_get (_tmp58_, _tmp59_);
				arg = (ValaExpression*) _tmp60_;
				_tmp61_ = expr;
				_tmp62_ = arg;
				vala_method_call_add_argument (_tmp61_, _tmp62_);
				_vala_code_node_unref0 (arg);
			}
			_vala_iterable_unref0 (_arg_list);
		}
		result = (ValaExpression*) expr;
		_vala_iterable_unref0 (init_list);
		_vala_iterable_unref0 (arg_list);
		return result;
	}
	_vala_iterable_unref0 (init_list);
	_vala_iterable_unref0 (arg_list);
}


static ValaExpression* vala_genie_parser_parse_element_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* index_list = NULL;
	ValaList* _tmp0_ = NULL;
	ValaExpression* stop = NULL;
	gboolean _tmp1_ = FALSE;
	ValaList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gboolean _tmp6_ = FALSE;
	ValaExpression* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_expression_list (self, &_inner_error_);
	index_list = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stop = NULL;
	_tmp2_ = index_list;
	_tmp3_ = vala_collection_get_size ((ValaCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 1) {
		gboolean _tmp5_ = FALSE;
		_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
		_tmp1_ = _tmp5_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		ValaExpression* _tmp7_ = NULL;
		ValaExpression* _tmp8_ = NULL;
		_tmp8_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp7_ = _tmp8_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (stop);
				_vala_iterable_unref0 (index_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (stop);
				_vala_iterable_unref0 (index_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (stop);
		stop = _tmp7_;
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stop);
			_vala_iterable_unref0 (index_list);
			return NULL;
		} else {
			_vala_code_node_unref0 (stop);
			_vala_iterable_unref0 (index_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = stop;
	if (_tmp9_ == NULL) {
		ValaElementAccess* expr = NULL;
		ValaExpression* _tmp10_ = NULL;
		ValaSourceLocation _tmp11_ = {0};
		ValaSourceReference* _tmp12_ = NULL;
		ValaSourceReference* _tmp13_ = NULL;
		ValaElementAccess* _tmp14_ = NULL;
		ValaElementAccess* _tmp15_ = NULL;
		_tmp10_ = inner;
		_tmp11_ = *begin;
		_tmp12_ = vala_genie_parser_get_src (self, &_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = vala_element_access_new (_tmp10_, _tmp13_);
		_tmp15_ = _tmp14_;
		_vala_source_reference_unref0 (_tmp13_);
		expr = _tmp15_;
		{
			ValaList* _index_list = NULL;
			ValaList* _tmp16_ = NULL;
			ValaList* _tmp17_ = NULL;
			gint _index_size = 0;
			ValaList* _tmp18_ = NULL;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _index_index = 0;
			_tmp16_ = index_list;
			_tmp17_ = _vala_iterable_ref0 (_tmp16_);
			_index_list = _tmp17_;
			_tmp18_ = _index_list;
			_tmp19_ = vala_collection_get_size ((ValaCollection*) _tmp18_);
			_tmp20_ = _tmp19_;
			_index_size = _tmp20_;
			_index_index = -1;
			while (TRUE) {
				gint _tmp21_ = 0;
				gint _tmp22_ = 0;
				gint _tmp23_ = 0;
				ValaExpression* index = NULL;
				ValaList* _tmp24_ = NULL;
				gint _tmp25_ = 0;
				gpointer _tmp26_ = NULL;
				ValaElementAccess* _tmp27_ = NULL;
				ValaExpression* _tmp28_ = NULL;
				_tmp21_ = _index_index;
				_index_index = _tmp21_ + 1;
				_tmp22_ = _index_index;
				_tmp23_ = _index_size;
				if (!(_tmp22_ < _tmp23_)) {
					break;
				}
				_tmp24_ = _index_list;
				_tmp25_ = _index_index;
				_tmp26_ = vala_list_get (_tmp24_, _tmp25_);
				index = (ValaExpression*) _tmp26_;
				_tmp27_ = expr;
				_tmp28_ = index;
				vala_element_access_append_index (_tmp27_, _tmp28_);
				_vala_code_node_unref0 (index);
			}
			_vala_iterable_unref0 (_index_list);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (stop);
		_vala_iterable_unref0 (index_list);
		return result;
	} else {
		ValaExpression* _tmp29_ = NULL;
		ValaList* _tmp30_ = NULL;
		gpointer _tmp31_ = NULL;
		ValaExpression* _tmp32_ = NULL;
		ValaExpression* _tmp33_ = NULL;
		ValaSourceLocation _tmp34_ = {0};
		ValaSourceReference* _tmp35_ = NULL;
		ValaSourceReference* _tmp36_ = NULL;
		ValaSliceExpression* _tmp37_ = NULL;
		ValaExpression* _tmp38_ = NULL;
		_tmp29_ = inner;
		_tmp30_ = index_list;
		_tmp31_ = vala_list_get (_tmp30_, 0);
		_tmp32_ = (ValaExpression*) _tmp31_;
		_tmp33_ = stop;
		_tmp34_ = *begin;
		_tmp35_ = vala_genie_parser_get_src (self, &_tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = vala_slice_expression_new (_tmp29_, _tmp32_, _tmp33_, _tmp36_);
		_tmp38_ = (ValaExpression*) _tmp37_;
		_vala_source_reference_unref0 (_tmp36_);
		_vala_code_node_unref0 (_tmp32_);
		result = _tmp38_;
		_vala_code_node_unref0 (stop);
		_vala_iterable_unref0 (index_list);
		return result;
	}
	_vala_code_node_unref0 (stop);
	_vala_iterable_unref0 (index_list);
}


static ValaList* vala_genie_parser_parse_expression_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list = NULL;
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp0_);
	list = _tmp1_;
	{
		gboolean _tmp2_ = FALSE;
		_tmp2_ = TRUE;
		while (TRUE) {
			gboolean _tmp3_ = FALSE;
			ValaExpression* _tmp5_ = NULL;
			ValaExpression* _tmp6_ = NULL;
			ValaArrayList* _tmp7_ = NULL;
			ValaExpression* _tmp8_ = NULL;
			_tmp3_ = _tmp2_;
			if (!_tmp3_) {
				gboolean _tmp4_ = FALSE;
				_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
				if (!_tmp4_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			_tmp6_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			_tmp5_ = _tmp6_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (list);
					return NULL;
				} else {
					_vala_iterable_unref0 (list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp7_ = list;
			_tmp8_ = _tmp5_;
			vala_collection_add ((ValaCollection*) _tmp7_, _tmp8_);
			_vala_code_node_unref0 (_tmp8_);
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_this_access (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaMemberAccess* _tmp4_ = NULL;
	ValaExpression* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_THIS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_member_access_new (NULL, "this", _tmp3_);
	_tmp5_ = (ValaExpression*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaExpression* vala_genie_parser_parse_base_access (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaBaseAccess* _tmp4_ = NULL;
	ValaExpression* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_SUPER, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_base_access_new (_tmp3_);
	_tmp5_ = (ValaExpression*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaExpression* vala_genie_parser_parse_post_increment_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* _tmp0_ = NULL;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaPostfixExpression* _tmp4_ = NULL;
	ValaExpression* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_INC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = inner;
	_tmp1_ = *begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_postfix_expression_new (_tmp0_, TRUE, _tmp3_);
	_tmp5_ = (ValaExpression*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaExpression* vala_genie_parser_parse_post_decrement_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* _tmp0_ = NULL;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaPostfixExpression* _tmp4_ = NULL;
	ValaExpression* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_DEC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = inner;
	_tmp1_ = *begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_postfix_expression_new (_tmp0_, FALSE, _tmp3_);
	_tmp5_ = (ValaExpression*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaExpression* vala_genie_parser_parse_object_or_array_creation_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp11_ = FALSE;
	ValaMemberAccess* member = NULL;
	ValaMemberAccess* _tmp18_ = NULL;
	ValaExpression* expr = NULL;
	ValaSourceLocation _tmp19_ = {0};
	ValaMemberAccess* _tmp20_ = NULL;
	ValaExpression* _tmp21_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_NEW, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY);
	if (_tmp1_) {
		ValaDataType* mtype = NULL;
		ValaDataType* _tmp2_ = NULL;
		ValaExpression* expr = NULL;
		ValaSourceLocation _tmp3_ = {0};
		ValaDataType* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp2_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		mtype = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp3_ = begin;
		_tmp4_ = mtype;
		_tmp5_ = vala_genie_parser_parse_array_creation_expression (self, &_tmp3_, _tmp4_, &_inner_error_);
		expr = _tmp5_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype);
		return result;
	}
	_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST);
	if (_tmp6_) {
		ValaDataType* mtype = NULL;
		ValaDataType* _tmp7_ = NULL;
		ValaExpression* expr = NULL;
		ValaSourceLocation _tmp8_ = {0};
		ValaDataType* _tmp9_ = NULL;
		ValaExpression* _tmp10_ = NULL;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp7_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		mtype = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp8_ = begin;
		_tmp9_ = mtype;
		_tmp10_ = vala_genie_parser_parse_list_creation_expression (self, &_tmp8_, _tmp9_, &_inner_error_);
		expr = _tmp10_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype);
		return result;
	}
	_tmp11_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT);
	if (_tmp11_) {
		ValaDataType* mtype1 = NULL;
		ValaDataType* _tmp12_ = NULL;
		ValaDataType* mtype2 = NULL;
		ValaDataType* _tmp13_ = NULL;
		ValaExpression* expr = NULL;
		ValaSourceLocation _tmp14_ = {0};
		ValaDataType* _tmp15_ = NULL;
		ValaDataType* _tmp16_ = NULL;
		ValaExpression* _tmp17_ = NULL;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp12_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		mtype1 = _tmp12_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COMMA, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp13_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		mtype2 = _tmp13_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp14_ = begin;
		_tmp15_ = mtype1;
		_tmp16_ = mtype2;
		_tmp17_ = vala_genie_parser_parse_dict_creation_expression (self, &_tmp14_, _tmp15_, _tmp16_, &_inner_error_);
		expr = _tmp17_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype2);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype2);
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype2);
		_vala_code_node_unref0 (mtype1);
		return result;
	}
	_tmp18_ = vala_genie_parser_parse_member_name (self, NULL, &_inner_error_);
	member = _tmp18_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp19_ = begin;
	_tmp20_ = member;
	_tmp21_ = vala_genie_parser_parse_object_creation_expression (self, &_tmp19_, _tmp20_, &_inner_error_);
	expr = _tmp21_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (member);
			return NULL;
		} else {
			_vala_code_node_unref0 (member);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	_vala_code_node_unref0 (member);
	return result;
}


static ValaExpression* vala_genie_parser_parse_object_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error) {
	ValaExpression* result = NULL;
	ValaMemberAccess* _tmp0_ = NULL;
	ValaList* arg_list = NULL;
	gboolean _tmp1_ = FALSE;
	ValaList* init_list = NULL;
	ValaList* _tmp6_ = NULL;
	ValaObjectCreationExpression* expr = NULL;
	ValaMemberAccess* _tmp7_ = NULL;
	ValaSourceLocation _tmp8_ = {0};
	ValaSourceReference* _tmp9_ = NULL;
	ValaSourceReference* _tmp10_ = NULL;
	ValaObjectCreationExpression* _tmp11_ = NULL;
	ValaObjectCreationExpression* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (member != NULL, NULL);
	_tmp0_ = member;
	vala_member_access_set_creation_member (_tmp0_, TRUE);
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	if (_tmp1_) {
		ValaList* _tmp2_ = NULL;
		ValaList* _tmp3_ = NULL;
		_tmp3_ = vala_genie_parser_parse_argument_list (self, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (arg_list);
				return NULL;
			} else {
				_vala_iterable_unref0 (arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_iterable_unref0 (arg_list);
		arg_list = _tmp2_;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (arg_list);
				return NULL;
			} else {
				_vala_iterable_unref0 (arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		GEqualFunc _tmp4_ = NULL;
		ValaArrayList* _tmp5_ = NULL;
		_tmp4_ = g_direct_equal;
		_tmp5_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp4_);
		_vala_iterable_unref0 (arg_list);
		arg_list = (ValaList*) _tmp5_;
	}
	_tmp6_ = vala_genie_parser_parse_object_initializer (self, &_inner_error_);
	init_list = _tmp6_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (arg_list);
			return NULL;
		} else {
			_vala_iterable_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp7_ = member;
	_tmp8_ = *begin;
	_tmp9_ = vala_genie_parser_get_src (self, &_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = vala_object_creation_expression_new (_tmp7_, _tmp10_);
	_tmp12_ = _tmp11_;
	_vala_source_reference_unref0 (_tmp10_);
	expr = _tmp12_;
	{
		ValaList* _arg_list = NULL;
		ValaList* _tmp13_ = NULL;
		ValaList* _tmp14_ = NULL;
		gint _arg_size = 0;
		ValaList* _tmp15_ = NULL;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		gint _arg_index = 0;
		_tmp13_ = arg_list;
		_tmp14_ = _vala_iterable_ref0 (_tmp13_);
		_arg_list = _tmp14_;
		_tmp15_ = _arg_list;
		_tmp16_ = vala_collection_get_size ((ValaCollection*) _tmp15_);
		_tmp17_ = _tmp16_;
		_arg_size = _tmp17_;
		_arg_index = -1;
		while (TRUE) {
			gint _tmp18_ = 0;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			ValaExpression* arg = NULL;
			ValaList* _tmp21_ = NULL;
			gint _tmp22_ = 0;
			gpointer _tmp23_ = NULL;
			ValaObjectCreationExpression* _tmp24_ = NULL;
			ValaExpression* _tmp25_ = NULL;
			_tmp18_ = _arg_index;
			_arg_index = _tmp18_ + 1;
			_tmp19_ = _arg_index;
			_tmp20_ = _arg_size;
			if (!(_tmp19_ < _tmp20_)) {
				break;
			}
			_tmp21_ = _arg_list;
			_tmp22_ = _arg_index;
			_tmp23_ = vala_list_get (_tmp21_, _tmp22_);
			arg = (ValaExpression*) _tmp23_;
			_tmp24_ = expr;
			_tmp25_ = arg;
			vala_object_creation_expression_add_argument (_tmp24_, _tmp25_);
			_vala_code_node_unref0 (arg);
		}
		_vala_iterable_unref0 (_arg_list);
	}
	{
		ValaList* _initializer_list = NULL;
		ValaList* _tmp26_ = NULL;
		ValaList* _tmp27_ = NULL;
		gint _initializer_size = 0;
		ValaList* _tmp28_ = NULL;
		gint _tmp29_ = 0;
		gint _tmp30_ = 0;
		gint _initializer_index = 0;
		_tmp26_ = init_list;
		_tmp27_ = _vala_iterable_ref0 (_tmp26_);
		_initializer_list = _tmp27_;
		_tmp28_ = _initializer_list;
		_tmp29_ = vala_collection_get_size ((ValaCollection*) _tmp28_);
		_tmp30_ = _tmp29_;
		_initializer_size = _tmp30_;
		_initializer_index = -1;
		while (TRUE) {
			gint _tmp31_ = 0;
			gint _tmp32_ = 0;
			gint _tmp33_ = 0;
			ValaMemberInitializer* initializer = NULL;
			ValaList* _tmp34_ = NULL;
			gint _tmp35_ = 0;
			gpointer _tmp36_ = NULL;
			ValaObjectCreationExpression* _tmp37_ = NULL;
			ValaMemberInitializer* _tmp38_ = NULL;
			_tmp31_ = _initializer_index;
			_initializer_index = _tmp31_ + 1;
			_tmp32_ = _initializer_index;
			_tmp33_ = _initializer_size;
			if (!(_tmp32_ < _tmp33_)) {
				break;
			}
			_tmp34_ = _initializer_list;
			_tmp35_ = _initializer_index;
			_tmp36_ = vala_list_get (_tmp34_, _tmp35_);
			initializer = (ValaMemberInitializer*) _tmp36_;
			_tmp37_ = expr;
			_tmp38_ = initializer;
			vala_object_creation_expression_add_member_initializer (_tmp37_, _tmp38_);
			_vala_code_node_unref0 (initializer);
		}
		_vala_iterable_unref0 (_initializer_list);
	}
	result = (ValaExpression*) expr;
	_vala_iterable_unref0 (init_list);
	_vala_iterable_unref0 (arg_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_array_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error) {
	ValaExpression* result = NULL;
	gboolean size_specified = FALSE;
	ValaList* size_specifier_list = NULL;
	gboolean first = FALSE;
	ValaDataType* etype = NULL;
	ValaDataType* _tmp0_ = NULL;
	ValaDataType* _tmp1_ = NULL;
	gboolean has_bracket = FALSE;
	gboolean _tmp2_ = FALSE;
	ValaInitializerList* initializer = NULL;
	gboolean _tmp37_ = FALSE;
	ValaArrayCreationExpression* expr = NULL;
	ValaDataType* _tmp40_ = NULL;
	ValaList* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	gint _tmp43_ = 0;
	ValaInitializerList* _tmp44_ = NULL;
	ValaSourceLocation _tmp45_ = {0};
	ValaSourceReference* _tmp46_ = NULL;
	ValaSourceReference* _tmp47_ = NULL;
	ValaArrayCreationExpression* _tmp48_ = NULL;
	ValaArrayCreationExpression* _tmp49_ = NULL;
	gboolean _tmp50_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (element_type != NULL, NULL);
	size_specified = FALSE;
	size_specifier_list = NULL;
	first = TRUE;
	_tmp0_ = element_type;
	_tmp1_ = vala_data_type_copy (_tmp0_);
	etype = _tmp1_;
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
	has_bracket = _tmp2_;
	{
		gboolean _tmp3_ = FALSE;
		_tmp3_ = TRUE;
		while (TRUE) {
			gboolean _tmp4_ = FALSE;
			gboolean _tmp6_ = FALSE;
			GEqualFunc _tmp20_ = NULL;
			ValaArrayList* _tmp21_ = NULL;
			gboolean _tmp36_ = FALSE;
			_tmp4_ = _tmp3_;
			if (!_tmp4_) {
				gboolean _tmp5_ = FALSE;
				_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
				if (!_tmp5_) {
					break;
				}
			}
			_tmp3_ = FALSE;
			_tmp6_ = first;
			if (!_tmp6_) {
				gboolean _tmp7_ = FALSE;
				ValaDataType* _tmp12_ = NULL;
				ValaList* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				gint _tmp15_ = 0;
				ValaDataType* _tmp16_ = NULL;
				ValaSourceReference* _tmp17_ = NULL;
				ValaSourceReference* _tmp18_ = NULL;
				ValaArrayType* _tmp19_ = NULL;
				_tmp7_ = size_specified;
				if (_tmp7_) {
					gchar* _tmp8_ = NULL;
					gchar* _tmp9_ = NULL;
					GError* _tmp10_ = NULL;
					GError* _tmp11_ = NULL;
					_tmp8_ = vala_genie_parser_get_error (self, "size of inner arrays must not be specified in array creation expressio" \
"n");
					_tmp9_ = _tmp8_;
					_tmp10_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp9_);
					_tmp11_ = _tmp10_;
					_g_free0 (_tmp9_);
					_inner_error_ = _tmp11_;
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (etype);
						_vala_iterable_unref0 (size_specifier_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (etype);
						_vala_iterable_unref0 (size_specifier_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp12_ = etype;
				_tmp13_ = size_specifier_list;
				_tmp14_ = vala_collection_get_size ((ValaCollection*) _tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = etype;
				_tmp17_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = vala_array_type_new (_tmp12_, _tmp15_, _tmp18_);
				_vala_code_node_unref0 (etype);
				etype = (ValaDataType*) _tmp19_;
			} else {
				first = FALSE;
			}
			_tmp20_ = g_direct_equal;
			_tmp21_ = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp20_);
			_vala_iterable_unref0 (size_specifier_list);
			size_specifier_list = (ValaList*) _tmp21_;
			{
				gboolean _tmp22_ = FALSE;
				_tmp22_ = TRUE;
				while (TRUE) {
					gboolean _tmp23_ = FALSE;
					ValaExpression* size = NULL;
					gboolean _tmp25_ = FALSE;
					gboolean _tmp26_ = FALSE;
					gboolean _tmp27_ = FALSE;
					gboolean _tmp29_ = FALSE;
					gboolean _tmp31_ = FALSE;
					ValaList* _tmp34_ = NULL;
					ValaExpression* _tmp35_ = NULL;
					_tmp23_ = _tmp22_;
					if (!_tmp23_) {
						gboolean _tmp24_ = FALSE;
						_tmp24_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp24_) {
							break;
						}
					}
					_tmp22_ = FALSE;
					size = NULL;
					_tmp27_ = has_bracket;
					if (_tmp27_) {
						ValaGenieTokenType _tmp28_ = 0;
						_tmp28_ = vala_genie_parser_current (self);
						_tmp26_ = _tmp28_ != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
					} else {
						_tmp26_ = FALSE;
					}
					_tmp29_ = _tmp26_;
					if (_tmp29_) {
						ValaGenieTokenType _tmp30_ = 0;
						_tmp30_ = vala_genie_parser_current (self);
						_tmp25_ = _tmp30_ != VALA_GENIE_TOKEN_TYPE_COMMA;
					} else {
						_tmp25_ = FALSE;
					}
					_tmp31_ = _tmp25_;
					if (_tmp31_) {
						ValaExpression* _tmp32_ = NULL;
						ValaExpression* _tmp33_ = NULL;
						_tmp33_ = vala_genie_parser_parse_expression (self, &_inner_error_);
						_tmp32_ = _tmp33_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (etype);
								_vala_iterable_unref0 (size_specifier_list);
								return NULL;
							} else {
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (etype);
								_vala_iterable_unref0 (size_specifier_list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_vala_code_node_unref0 (size);
						size = _tmp32_;
						size_specified = TRUE;
					}
					_tmp34_ = size_specifier_list;
					_tmp35_ = size;
					vala_collection_add ((ValaCollection*) _tmp34_, _tmp35_);
					_vala_code_node_unref0 (size);
				}
			}
			_tmp36_ = has_bracket;
			if (_tmp36_) {
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (etype);
						_vala_iterable_unref0 (size_specifier_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (etype);
						_vala_iterable_unref0 (size_specifier_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
	}
	initializer = NULL;
	_tmp37_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp37_) {
		ValaInitializerList* _tmp38_ = NULL;
		ValaInitializerList* _tmp39_ = NULL;
		_tmp39_ = vala_genie_parser_parse_initializer (self, &_inner_error_);
		_tmp38_ = _tmp39_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (etype);
				_vala_iterable_unref0 (size_specifier_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (etype);
				_vala_iterable_unref0 (size_specifier_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (initializer);
		initializer = _tmp38_;
	}
	_tmp40_ = etype;
	_tmp41_ = size_specifier_list;
	_tmp42_ = vala_collection_get_size ((ValaCollection*) _tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = initializer;
	_tmp45_ = *begin;
	_tmp46_ = vala_genie_parser_get_src (self, &_tmp45_);
	_tmp47_ = _tmp46_;
	_tmp48_ = vala_array_creation_expression_new (_tmp40_, _tmp43_, _tmp44_, _tmp47_);
	_tmp49_ = _tmp48_;
	_vala_source_reference_unref0 (_tmp47_);
	expr = _tmp49_;
	_tmp50_ = size_specified;
	if (_tmp50_) {
		{
			ValaList* _size_list = NULL;
			ValaList* _tmp51_ = NULL;
			ValaList* _tmp52_ = NULL;
			gint _size_size = 0;
			ValaList* _tmp53_ = NULL;
			gint _tmp54_ = 0;
			gint _tmp55_ = 0;
			gint _size_index = 0;
			_tmp51_ = size_specifier_list;
			_tmp52_ = _vala_iterable_ref0 (_tmp51_);
			_size_list = _tmp52_;
			_tmp53_ = _size_list;
			_tmp54_ = vala_collection_get_size ((ValaCollection*) _tmp53_);
			_tmp55_ = _tmp54_;
			_size_size = _tmp55_;
			_size_index = -1;
			while (TRUE) {
				gint _tmp56_ = 0;
				gint _tmp57_ = 0;
				gint _tmp58_ = 0;
				ValaExpression* size = NULL;
				ValaList* _tmp59_ = NULL;
				gint _tmp60_ = 0;
				gpointer _tmp61_ = NULL;
				ValaArrayCreationExpression* _tmp62_ = NULL;
				ValaExpression* _tmp63_ = NULL;
				_tmp56_ = _size_index;
				_size_index = _tmp56_ + 1;
				_tmp57_ = _size_index;
				_tmp58_ = _size_size;
				if (!(_tmp57_ < _tmp58_)) {
					break;
				}
				_tmp59_ = _size_list;
				_tmp60_ = _size_index;
				_tmp61_ = vala_list_get (_tmp59_, _tmp60_);
				size = (ValaExpression*) _tmp61_;
				_tmp62_ = expr;
				_tmp63_ = size;
				vala_array_creation_expression_append_size (_tmp62_, _tmp63_);
				_vala_code_node_unref0 (size);
			}
			_vala_iterable_unref0 (_size_list);
		}
	}
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (etype);
	_vala_iterable_unref0 (size_specifier_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_list_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error) {
	ValaExpression* result = NULL;
	ValaMemberAccess* list_member = NULL;
	ValaMemberAccess* parent_member = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceReference* _tmp1_ = NULL;
	ValaSourceReference* _tmp2_ = NULL;
	ValaMemberAccess* _tmp3_ = NULL;
	ValaMemberAccess* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaMemberAccess* _tmp8_ = NULL;
	ValaMemberAccess* _tmp9_ = NULL;
	ValaDataType* _tmp10_ = NULL;
	ValaMemberAccess* _tmp11_ = NULL;
	ValaObjectCreationExpression* expr = NULL;
	ValaMemberAccess* _tmp12_ = NULL;
	ValaSourceLocation _tmp13_ = {0};
	ValaSourceReference* _tmp14_ = NULL;
	ValaSourceReference* _tmp15_ = NULL;
	ValaObjectCreationExpression* _tmp16_ = NULL;
	ValaObjectCreationExpression* _tmp17_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (element_type != NULL, NULL);
	list_member = NULL;
	parent_member = NULL;
	_tmp0_ = *begin;
	_tmp1_ = vala_genie_parser_get_src (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = vala_member_access_new (NULL, "Gee", _tmp2_);
	_vala_code_node_unref0 (parent_member);
	parent_member = _tmp3_;
	_vala_source_reference_unref0 (_tmp2_);
	_tmp4_ = parent_member;
	_tmp5_ = *begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_member_access_new ((ValaExpression*) _tmp4_, "ArrayList", _tmp7_);
	_vala_code_node_unref0 (list_member);
	list_member = _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	_tmp9_ = list_member;
	_tmp10_ = element_type;
	vala_member_access_add_type_argument (_tmp9_, _tmp10_);
	_tmp11_ = list_member;
	vala_member_access_set_creation_member (_tmp11_, TRUE);
	_tmp12_ = list_member;
	_tmp13_ = *begin;
	_tmp14_ = vala_genie_parser_get_src (self, &_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = vala_object_creation_expression_new (_tmp12_, _tmp15_);
	_tmp17_ = _tmp16_;
	_vala_source_reference_unref0 (_tmp15_);
	expr = _tmp17_;
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (parent_member);
	_vala_code_node_unref0 (list_member);
	return result;
}


static ValaExpression* vala_genie_parser_parse_dict_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* key_type, ValaDataType* value_type, GError** error) {
	ValaExpression* result = NULL;
	ValaMemberAccess* dict_member = NULL;
	ValaMemberAccess* parent_member = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceReference* _tmp1_ = NULL;
	ValaSourceReference* _tmp2_ = NULL;
	ValaMemberAccess* _tmp3_ = NULL;
	ValaMemberAccess* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaMemberAccess* _tmp8_ = NULL;
	ValaMemberAccess* _tmp9_ = NULL;
	ValaDataType* _tmp10_ = NULL;
	ValaMemberAccess* _tmp11_ = NULL;
	ValaDataType* _tmp12_ = NULL;
	ValaMemberAccess* _tmp13_ = NULL;
	ValaObjectCreationExpression* expr = NULL;
	ValaMemberAccess* _tmp14_ = NULL;
	ValaSourceLocation _tmp15_ = {0};
	ValaSourceReference* _tmp16_ = NULL;
	ValaSourceReference* _tmp17_ = NULL;
	ValaObjectCreationExpression* _tmp18_ = NULL;
	ValaObjectCreationExpression* _tmp19_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (begin != NULL, NULL);
	g_return_val_if_fail (key_type != NULL, NULL);
	g_return_val_if_fail (value_type != NULL, NULL);
	dict_member = NULL;
	parent_member = NULL;
	_tmp0_ = *begin;
	_tmp1_ = vala_genie_parser_get_src (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = vala_member_access_new (NULL, "Gee", _tmp2_);
	_vala_code_node_unref0 (parent_member);
	parent_member = _tmp3_;
	_vala_source_reference_unref0 (_tmp2_);
	_tmp4_ = parent_member;
	_tmp5_ = *begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_member_access_new ((ValaExpression*) _tmp4_, "HashMap", _tmp7_);
	_vala_code_node_unref0 (dict_member);
	dict_member = _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	_tmp9_ = dict_member;
	_tmp10_ = key_type;
	vala_member_access_add_type_argument (_tmp9_, _tmp10_);
	_tmp11_ = dict_member;
	_tmp12_ = value_type;
	vala_member_access_add_type_argument (_tmp11_, _tmp12_);
	_tmp13_ = dict_member;
	vala_member_access_set_creation_member (_tmp13_, TRUE);
	_tmp14_ = dict_member;
	_tmp15_ = *begin;
	_tmp16_ = vala_genie_parser_get_src (self, &_tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = vala_object_creation_expression_new (_tmp14_, _tmp17_);
	_tmp19_ = _tmp18_;
	_vala_source_reference_unref0 (_tmp17_);
	expr = _tmp19_;
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (parent_member);
	_vala_code_node_unref0 (dict_member);
	return result;
}


static ValaList* vala_genie_parser_parse_object_initializer (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list = NULL;
	GEqualFunc _tmp0_ = NULL;
	ValaArrayList* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_direct_equal;
	_tmp1_ = vala_array_list_new (VALA_TYPE_MEMBER_INITIALIZER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp0_);
	list = _tmp1_;
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACE);
	if (_tmp2_) {
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				ValaMemberInitializer* _tmp6_ = NULL;
				ValaMemberInitializer* _tmp7_ = NULL;
				ValaArrayList* _tmp8_ = NULL;
				ValaMemberInitializer* _tmp9_ = NULL;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gboolean _tmp5_ = FALSE;
					_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp5_) {
						break;
					}
				}
				_tmp3_ = FALSE;
				_tmp7_ = vala_genie_parser_parse_member_initializer (self, &_inner_error_);
				_tmp6_ = _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (list);
						return NULL;
					} else {
						_vala_iterable_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp8_ = list;
				_tmp9_ = _tmp6_;
				vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
				_vala_code_node_unref0 (_tmp9_);
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (list);
				return NULL;
			} else {
				_vala_iterable_unref0 (list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaMemberInitializer* vala_genie_parser_parse_member_initializer (ValaGenieParser* self, GError** error) {
	ValaMemberInitializer* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gchar* id = NULL;
	gchar* _tmp1_ = NULL;
	ValaExpression* expr = NULL;
	ValaExpression* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	ValaExpression* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaMemberInitializer* _tmp8_ = NULL;
	ValaMemberInitializer* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = id;
	_tmp4_ = expr;
	_tmp5_ = begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_member_initializer_new (_tmp3_, _tmp4_, _tmp7_);
	_tmp9_ = _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	result = _tmp9_;
	_vala_code_node_unref0 (expr);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_yield_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr = NULL;
	ValaExpression* _tmp0_ = NULL;
	ValaMethodCall* call = NULL;
	ValaExpression* _tmp1_ = NULL;
	ValaMethodCall* _tmp2_ = NULL;
	ValaObjectCreationExpression* object_creation = NULL;
	ValaExpression* _tmp3_ = NULL;
	ValaObjectCreationExpression* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	ValaMethodCall* _tmp6_ = NULL;
	gboolean _tmp8_ = FALSE;
	ValaMethodCall* _tmp13_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp0_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = expr;
	_tmp2_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, VALA_TYPE_METHOD_CALL) ? ((ValaMethodCall*) _tmp1_) : NULL);
	call = _tmp2_;
	_tmp3_ = expr;
	_tmp4_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, VALA_TYPE_OBJECT_CREATION_EXPRESSION) ? ((ValaObjectCreationExpression*) _tmp3_) : NULL);
	object_creation = _tmp4_;
	_tmp6_ = call;
	if (_tmp6_ == NULL) {
		ValaObjectCreationExpression* _tmp7_ = NULL;
		_tmp7_ = object_creation;
		_tmp5_ = _tmp7_ == NULL;
	} else {
		_tmp5_ = FALSE;
	}
	_tmp8_ = _tmp5_;
	if (_tmp8_) {
		ValaExpression* _tmp9_ = NULL;
		ValaSourceReference* _tmp10_ = NULL;
		ValaSourceReference* _tmp11_ = NULL;
		GError* _tmp12_ = NULL;
		_tmp9_ = expr;
		_tmp10_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp9_);
		_tmp11_ = _tmp10_;
		vala_report_error (_tmp11_, "syntax error, expected method call");
		_tmp12_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, "expected method call");
		_inner_error_ = _tmp12_;
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (object_creation);
			_vala_code_node_unref0 (call);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (object_creation);
			_vala_code_node_unref0 (call);
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = call;
	if (_tmp13_ != NULL) {
		ValaMethodCall* _tmp14_ = NULL;
		_tmp14_ = call;
		vala_method_call_set_is_yield_expression (_tmp14_, TRUE);
	} else {
		ValaObjectCreationExpression* _tmp15_ = NULL;
		_tmp15_ = object_creation;
		if (_tmp15_ != NULL) {
			ValaObjectCreationExpression* _tmp16_ = NULL;
			_tmp16_ = object_creation;
			vala_object_creation_expression_set_is_yield_expression (_tmp16_, TRUE);
		}
	}
	result = expr;
	_vala_code_node_unref0 (object_creation);
	_vala_code_node_unref0 (call);
	return result;
}


static ValaExpression* vala_genie_parser_parse_sizeof_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	ValaDataType* _tmp1_ = NULL;
	ValaDataType* _tmp2_ = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaSourceReference* _tmp5_ = NULL;
	ValaSizeofExpression* _tmp6_ = NULL;
	ValaExpression* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_SIZEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	type = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = type;
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_sizeof_expression_new (_tmp2_, _tmp5_);
	_tmp7_ = (ValaExpression*) _tmp6_;
	_vala_source_reference_unref0 (_tmp5_);
	result = _tmp7_;
	_vala_code_node_unref0 (type);
	return result;
}


static ValaExpression* vala_genie_parser_parse_typeof_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	ValaDataType* _tmp1_ = NULL;
	ValaDataType* _tmp2_ = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaSourceReference* _tmp5_ = NULL;
	ValaTypeofExpression* _tmp6_ = NULL;
	ValaExpression* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_TYPEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	type = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = type;
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_typeof_expression_new (_tmp2_, _tmp5_);
	_tmp7_ = (ValaExpression*) _tmp6_;
	_vala_source_reference_unref0 (_tmp5_);
	result = _tmp7_;
	_vala_code_node_unref0 (type);
	return result;
}


static ValaUnaryOperator vala_genie_parser_get_unary_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaUnaryOperator result = 0;
	ValaGenieTokenType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = token_type;
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_PLUS:
		{
			result = VALA_UNARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_MINUS:
		{
			result = VALA_UNARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_NEG:
		{
			result = VALA_UNARY_OPERATOR_LOGICAL_NEGATION;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TILDE:
		{
			result = VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_INC:
		{
			result = VALA_UNARY_OPERATOR_INCREMENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_DEC:
		{
			result = VALA_UNARY_OPERATOR_DECREMENT;
			return result;
		}
		default:
		{
			result = VALA_UNARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_unary_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaUnaryOperator operator = 0;
	ValaGenieTokenType _tmp1_ = 0;
	ValaUnaryOperator _tmp2_ = 0;
	ValaUnaryOperator _tmp3_ = 0;
	ValaGenieTokenType _tmp12_ = 0;
	ValaExpression* expr = NULL;
	ValaExpression* _tmp69_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_current (self);
	_tmp2_ = vala_genie_parser_get_unary_operator (self, _tmp1_);
	operator = _tmp2_;
	_tmp3_ = operator;
	if (_tmp3_ != VALA_UNARY_OPERATOR_NONE) {
		ValaExpression* op = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaUnaryOperator _tmp5_ = 0;
		ValaExpression* _tmp6_ = NULL;
		ValaSourceLocation _tmp7_ = {0};
		ValaSourceReference* _tmp8_ = NULL;
		ValaSourceReference* _tmp9_ = NULL;
		ValaUnaryExpression* _tmp10_ = NULL;
		ValaExpression* _tmp11_ = NULL;
		vala_genie_parser_next (self);
		_tmp4_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
		op = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp5_ = operator;
		_tmp6_ = op;
		_tmp7_ = begin;
		_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = vala_unary_expression_new (_tmp5_, _tmp6_, _tmp9_);
		_tmp11_ = (ValaExpression*) _tmp10_;
		_vala_source_reference_unref0 (_tmp9_);
		result = _tmp11_;
		_vala_code_node_unref0 (op);
		return result;
	}
	_tmp12_ = vala_genie_parser_current (self);
	switch (_tmp12_) {
		case VALA_GENIE_TOKEN_TYPE_HASH:
		{
			ValaCodeContext* _tmp13_ = NULL;
			gboolean _tmp14_ = FALSE;
			gboolean _tmp15_ = FALSE;
			ValaExpression* op = NULL;
			ValaExpression* _tmp19_ = NULL;
			ValaExpression* _tmp20_ = NULL;
			ValaSourceLocation _tmp21_ = {0};
			ValaSourceReference* _tmp22_ = NULL;
			ValaSourceReference* _tmp23_ = NULL;
			ValaReferenceTransferExpression* _tmp24_ = NULL;
			ValaExpression* _tmp25_ = NULL;
			_tmp13_ = self->priv->context;
			_tmp14_ = vala_code_context_get_deprecated (_tmp13_);
			_tmp15_ = _tmp14_;
			if (!_tmp15_) {
				ValaSourceLocation _tmp16_ = {0};
				ValaSourceReference* _tmp17_ = NULL;
				ValaSourceReference* _tmp18_ = NULL;
				_tmp16_ = begin;
				_tmp17_ = vala_genie_parser_get_src (self, &_tmp16_);
				_tmp18_ = _tmp17_;
				vala_report_warning (_tmp18_, "deprecated syntax, use `(owned)` cast");
				_vala_source_reference_unref0 (_tmp18_);
			}
			vala_genie_parser_next (self);
			_tmp19_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			op = _tmp19_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp20_ = op;
			_tmp21_ = begin;
			_tmp22_ = vala_genie_parser_get_src (self, &_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = vala_reference_transfer_expression_new (_tmp20_, _tmp23_);
			_tmp25_ = (ValaExpression*) _tmp24_;
			_vala_source_reference_unref0 (_tmp23_);
			result = _tmp25_;
			_vala_code_node_unref0 (op);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		{
			ValaGenieTokenType _tmp26_ = 0;
			ValaSourceLocation _tmp54_ = {0};
			vala_genie_parser_next (self);
			_tmp26_ = vala_genie_parser_current (self);
			switch (_tmp26_) {
				case VALA_GENIE_TOKEN_TYPE_OWNED:
				{
					gboolean _tmp27_ = FALSE;
					vala_genie_parser_next (self);
					_tmp27_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS);
					if (_tmp27_) {
						ValaExpression* op = NULL;
						ValaExpression* _tmp28_ = NULL;
						ValaExpression* _tmp29_ = NULL;
						ValaSourceLocation _tmp30_ = {0};
						ValaSourceReference* _tmp31_ = NULL;
						ValaSourceReference* _tmp32_ = NULL;
						ValaReferenceTransferExpression* _tmp33_ = NULL;
						ValaExpression* _tmp34_ = NULL;
						_tmp28_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
						op = _tmp28_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_tmp29_ = op;
						_tmp30_ = begin;
						_tmp31_ = vala_genie_parser_get_src (self, &_tmp30_);
						_tmp32_ = _tmp31_;
						_tmp33_ = vala_reference_transfer_expression_new (_tmp29_, _tmp32_);
						_tmp34_ = (ValaExpression*) _tmp33_;
						_vala_source_reference_unref0 (_tmp32_);
						result = _tmp34_;
						_vala_code_node_unref0 (op);
						return result;
					}
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_VOID:
				case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
				case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
				case VALA_GENIE_TOKEN_TYPE_ARRAY:
				case VALA_GENIE_TOKEN_TYPE_LIST:
				case VALA_GENIE_TOKEN_TYPE_DICT:
				{
					ValaDataType* type = NULL;
					ValaDataType* _tmp35_ = NULL;
					gboolean _tmp36_ = FALSE;
					_tmp35_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					type = _tmp35_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return NULL;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp36_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS);
					if (_tmp36_) {
						ValaGenieTokenType _tmp37_ = 0;
						_tmp37_ = vala_genie_parser_current (self);
						switch (_tmp37_) {
							case VALA_GENIE_TOKEN_TYPE_OP_NEG:
							case VALA_GENIE_TOKEN_TYPE_TILDE:
							case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
							case VALA_GENIE_TOKEN_TYPE_TRUE:
							case VALA_GENIE_TOKEN_TYPE_FALSE:
							case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_NULL:
							case VALA_GENIE_TOKEN_TYPE_THIS:
							case VALA_GENIE_TOKEN_TYPE_SUPER:
							case VALA_GENIE_TOKEN_TYPE_NEW:
							case VALA_GENIE_TOKEN_TYPE_SIZEOF:
							case VALA_GENIE_TOKEN_TYPE_TYPEOF:
							case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
							case VALA_GENIE_TOKEN_TYPE_PARAMS:
							case VALA_GENIE_TOKEN_TYPE_YIELD:
							{
								ValaExpression* inner = NULL;
								ValaExpression* _tmp38_ = NULL;
								ValaExpression* _tmp39_ = NULL;
								ValaDataType* _tmp40_ = NULL;
								ValaSourceLocation _tmp41_ = {0};
								ValaSourceReference* _tmp42_ = NULL;
								ValaSourceReference* _tmp43_ = NULL;
								ValaCastExpression* _tmp44_ = NULL;
								ValaExpression* _tmp45_ = NULL;
								_tmp38_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
								inner = _tmp38_;
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (type);
										return NULL;
									} else {
										_vala_code_node_unref0 (type);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								_tmp39_ = inner;
								_tmp40_ = type;
								_tmp41_ = begin;
								_tmp42_ = vala_genie_parser_get_src (self, &_tmp41_);
								_tmp43_ = _tmp42_;
								_tmp44_ = vala_cast_expression_new (_tmp39_, _tmp40_, _tmp43_, FALSE);
								_tmp45_ = (ValaExpression*) _tmp44_;
								_vala_source_reference_unref0 (_tmp43_);
								result = _tmp45_;
								_vala_code_node_unref0 (inner);
								_vala_code_node_unref0 (type);
								return result;
							}
							default:
							{
								break;
							}
						}
					}
					_vala_code_node_unref0 (type);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_OP_NEG:
				{
					gboolean _tmp46_ = FALSE;
					vala_genie_parser_next (self);
					_tmp46_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS);
					if (_tmp46_) {
						ValaExpression* inner = NULL;
						ValaExpression* _tmp47_ = NULL;
						ValaExpression* _tmp48_ = NULL;
						ValaSourceLocation _tmp49_ = {0};
						ValaSourceReference* _tmp50_ = NULL;
						ValaSourceReference* _tmp51_ = NULL;
						ValaCastExpression* _tmp52_ = NULL;
						ValaExpression* _tmp53_ = NULL;
						_tmp47_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
						inner = _tmp47_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_tmp48_ = inner;
						_tmp49_ = begin;
						_tmp50_ = vala_genie_parser_get_src (self, &_tmp49_);
						_tmp51_ = _tmp50_;
						_tmp52_ = vala_cast_expression_new_non_null (_tmp48_, _tmp51_);
						_tmp53_ = (ValaExpression*) _tmp52_;
						_vala_source_reference_unref0 (_tmp51_);
						result = _tmp53_;
						_vala_code_node_unref0 (inner);
						return result;
					}
					break;
				}
				default:
				{
					break;
				}
			}
			_tmp54_ = begin;
			vala_genie_parser_rollback (self, &_tmp54_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_STAR:
		{
			ValaExpression* op = NULL;
			ValaExpression* _tmp55_ = NULL;
			ValaExpression* _tmp56_ = NULL;
			ValaSourceLocation _tmp57_ = {0};
			ValaSourceReference* _tmp58_ = NULL;
			ValaSourceReference* _tmp59_ = NULL;
			ValaPointerIndirection* _tmp60_ = NULL;
			ValaExpression* _tmp61_ = NULL;
			vala_genie_parser_next (self);
			_tmp55_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			op = _tmp55_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp56_ = op;
			_tmp57_ = begin;
			_tmp58_ = vala_genie_parser_get_src (self, &_tmp57_);
			_tmp59_ = _tmp58_;
			_tmp60_ = vala_pointer_indirection_new (_tmp56_, _tmp59_);
			_tmp61_ = (ValaExpression*) _tmp60_;
			_vala_source_reference_unref0 (_tmp59_);
			result = _tmp61_;
			_vala_code_node_unref0 (op);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_BITWISE_AND:
		{
			ValaExpression* op = NULL;
			ValaExpression* _tmp62_ = NULL;
			ValaExpression* _tmp63_ = NULL;
			ValaSourceLocation _tmp64_ = {0};
			ValaSourceReference* _tmp65_ = NULL;
			ValaSourceReference* _tmp66_ = NULL;
			ValaAddressofExpression* _tmp67_ = NULL;
			ValaExpression* _tmp68_ = NULL;
			vala_genie_parser_next (self);
			_tmp62_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			op = _tmp62_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp63_ = op;
			_tmp64_ = begin;
			_tmp65_ = vala_genie_parser_get_src (self, &_tmp64_);
			_tmp66_ = _tmp65_;
			_tmp67_ = vala_addressof_expression_new (_tmp63_, _tmp66_);
			_tmp68_ = (ValaExpression*) _tmp67_;
			_vala_source_reference_unref0 (_tmp66_);
			result = _tmp68_;
			_vala_code_node_unref0 (op);
			return result;
		}
		default:
		{
			break;
		}
	}
	_tmp69_ = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
	expr = _tmp69_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaBinaryOperator vala_genie_parser_get_binary_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaBinaryOperator result = 0;
	ValaGenieTokenType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = token_type;
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_STAR:
		{
			result = VALA_BINARY_OPERATOR_MUL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DIV:
		{
			result = VALA_BINARY_OPERATOR_DIV;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PERCENT:
		{
			result = VALA_BINARY_OPERATOR_MOD;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PLUS:
		{
			result = VALA_BINARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_MINUS:
		{
			result = VALA_BINARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_LT:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_GT:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_LE:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_GE:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_EQ:
		{
			result = VALA_BINARY_OPERATOR_EQUALITY;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_IS:
		{
			ValaGenieTokenType _tmp1_ = 0;
			vala_genie_parser_next (self);
			_tmp1_ = vala_genie_parser_current (self);
			if (_tmp1_ == VALA_GENIE_TOKEN_TYPE_OP_NEG) {
				vala_genie_parser_prev (self);
				result = VALA_BINARY_OPERATOR_INEQUALITY;
				return result;
			}
			vala_genie_parser_prev (self);
			result = VALA_BINARY_OPERATOR_EQUALITY;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_NE:
		{
			result = VALA_BINARY_OPERATOR_INEQUALITY;
			return result;
		}
		default:
		{
			result = VALA_BINARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_multiplicative_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaBinaryOperator operator = 0;
		ValaGenieTokenType _tmp3_ = 0;
		ValaBinaryOperator _tmp4_ = 0;
		ValaBinaryOperator _tmp5_ = 0;
		_tmp2_ = found;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_current (self);
		_tmp4_ = vala_genie_parser_get_binary_operator (self, _tmp3_);
		operator = _tmp4_;
		_tmp5_ = operator;
		switch (_tmp5_) {
			case VALA_BINARY_OPERATOR_MUL:
			case VALA_BINARY_OPERATOR_DIV:
			case VALA_BINARY_OPERATOR_MOD:
			{
				ValaExpression* right = NULL;
				ValaExpression* _tmp6_ = NULL;
				ValaBinaryOperator _tmp7_ = 0;
				ValaExpression* _tmp8_ = NULL;
				ValaExpression* _tmp9_ = NULL;
				ValaSourceLocation _tmp10_ = {0};
				ValaSourceReference* _tmp11_ = NULL;
				ValaSourceReference* _tmp12_ = NULL;
				ValaBinaryExpression* _tmp13_ = NULL;
				vala_genie_parser_next (self);
				_tmp6_ = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
				right = _tmp6_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp7_ = operator;
				_tmp8_ = left;
				_tmp9_ = right;
				_tmp10_ = begin;
				_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = vala_binary_expression_new (_tmp7_, _tmp8_, _tmp9_, _tmp12_);
				_vala_code_node_unref0 (left);
				left = (ValaExpression*) _tmp13_;
				_vala_source_reference_unref0 (_tmp12_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_additive_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_multiplicative_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaBinaryOperator operator = 0;
		ValaGenieTokenType _tmp3_ = 0;
		ValaBinaryOperator _tmp4_ = 0;
		ValaBinaryOperator _tmp5_ = 0;
		_tmp2_ = found;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_current (self);
		_tmp4_ = vala_genie_parser_get_binary_operator (self, _tmp3_);
		operator = _tmp4_;
		_tmp5_ = operator;
		switch (_tmp5_) {
			case VALA_BINARY_OPERATOR_PLUS:
			case VALA_BINARY_OPERATOR_MINUS:
			{
				ValaExpression* right = NULL;
				ValaExpression* _tmp6_ = NULL;
				ValaBinaryOperator _tmp7_ = 0;
				ValaExpression* _tmp8_ = NULL;
				ValaExpression* _tmp9_ = NULL;
				ValaSourceLocation _tmp10_ = {0};
				ValaSourceReference* _tmp11_ = NULL;
				ValaSourceReference* _tmp12_ = NULL;
				ValaBinaryExpression* _tmp13_ = NULL;
				vala_genie_parser_next (self);
				_tmp6_ = vala_genie_parser_parse_multiplicative_expression (self, &_inner_error_);
				right = _tmp6_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp7_ = operator;
				_tmp8_ = left;
				_tmp9_ = right;
				_tmp10_ = begin;
				_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = vala_binary_expression_new (_tmp7_, _tmp8_, _tmp9_, _tmp12_);
				_vala_code_node_unref0 (left);
				left = (ValaExpression*) _tmp13_;
				_vala_source_reference_unref0 (_tmp12_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_shift_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaGenieTokenType _tmp3_ = 0;
		_tmp2_ = found;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_current (self);
		switch (_tmp3_) {
			case VALA_GENIE_TOKEN_TYPE_OP_SHIFT_LEFT:
			{
				ValaExpression* right = NULL;
				ValaExpression* _tmp4_ = NULL;
				ValaExpression* _tmp5_ = NULL;
				ValaExpression* _tmp6_ = NULL;
				ValaSourceLocation _tmp7_ = {0};
				ValaSourceReference* _tmp8_ = NULL;
				ValaSourceReference* _tmp9_ = NULL;
				ValaBinaryExpression* _tmp10_ = NULL;
				vala_genie_parser_next (self);
				_tmp4_ = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
				right = _tmp4_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp5_ = left;
				_tmp6_ = right;
				_tmp7_ = begin;
				_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
				_tmp9_ = _tmp8_;
				_tmp10_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_LEFT, _tmp5_, _tmp6_, _tmp9_);
				_vala_code_node_unref0 (left);
				left = (ValaExpression*) _tmp10_;
				_vala_source_reference_unref0 (_tmp9_);
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_GT:
			{
				gchar* first_gt_pos = NULL;
				ValaGenieParserTokenInfo* _tmp11_ = NULL;
				gint _tmp11__length1 = 0;
				gint _tmp12_ = 0;
				ValaGenieParserTokenInfo _tmp13_ = {0};
				ValaSourceLocation _tmp14_ = {0};
				gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				ValaGenieTokenType _tmp17_ = 0;
				gboolean _tmp24_ = FALSE;
				_tmp11_ = self->priv->tokens;
				_tmp11__length1 = self->priv->tokens_length1;
				_tmp12_ = self->priv->index;
				_tmp13_ = _tmp11_[_tmp12_];
				_tmp14_ = _tmp13_.begin;
				_tmp15_ = _tmp14_.pos;
				first_gt_pos = _tmp15_;
				vala_genie_parser_next (self);
				_tmp17_ = vala_genie_parser_current (self);
				if (_tmp17_ == VALA_GENIE_TOKEN_TYPE_OP_GT) {
					ValaGenieParserTokenInfo* _tmp18_ = NULL;
					gint _tmp18__length1 = 0;
					gint _tmp19_ = 0;
					ValaGenieParserTokenInfo _tmp20_ = {0};
					ValaSourceLocation _tmp21_ = {0};
					gchar* _tmp22_ = NULL;
					gchar* _tmp23_ = NULL;
					_tmp18_ = self->priv->tokens;
					_tmp18__length1 = self->priv->tokens_length1;
					_tmp19_ = self->priv->index;
					_tmp20_ = _tmp18_[_tmp19_];
					_tmp21_ = _tmp20_.begin;
					_tmp22_ = _tmp21_.pos;
					_tmp23_ = first_gt_pos;
					_tmp16_ = _tmp22_ == (_tmp23_ + 1);
				} else {
					_tmp16_ = FALSE;
				}
				_tmp24_ = _tmp16_;
				if (_tmp24_) {
					ValaExpression* right = NULL;
					ValaExpression* _tmp25_ = NULL;
					ValaExpression* _tmp26_ = NULL;
					ValaExpression* _tmp27_ = NULL;
					ValaSourceLocation _tmp28_ = {0};
					ValaSourceReference* _tmp29_ = NULL;
					ValaSourceReference* _tmp30_ = NULL;
					ValaBinaryExpression* _tmp31_ = NULL;
					vala_genie_parser_next (self);
					_tmp25_ = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
					right = _tmp25_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp26_ = left;
					_tmp27_ = right;
					_tmp28_ = begin;
					_tmp29_ = vala_genie_parser_get_src (self, &_tmp28_);
					_tmp30_ = _tmp29_;
					_tmp31_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_RIGHT, _tmp26_, _tmp27_, _tmp30_);
					_vala_code_node_unref0 (left);
					left = (ValaExpression*) _tmp31_;
					_vala_source_reference_unref0 (_tmp30_);
					_vala_code_node_unref0 (right);
				} else {
					vala_genie_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_relational_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaBinaryOperator operator = 0;
		ValaGenieTokenType _tmp3_ = 0;
		ValaBinaryOperator _tmp4_ = 0;
		ValaBinaryOperator _tmp5_ = 0;
		_tmp2_ = found;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_current (self);
		_tmp4_ = vala_genie_parser_get_binary_operator (self, _tmp3_);
		operator = _tmp4_;
		_tmp5_ = operator;
		switch (_tmp5_) {
			case VALA_BINARY_OPERATOR_LESS_THAN:
			case VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL:
			case VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL:
			{
				ValaExpression* right = NULL;
				ValaExpression* _tmp6_ = NULL;
				ValaBinaryOperator _tmp7_ = 0;
				ValaExpression* _tmp8_ = NULL;
				ValaExpression* _tmp9_ = NULL;
				ValaSourceLocation _tmp10_ = {0};
				ValaSourceReference* _tmp11_ = NULL;
				ValaSourceReference* _tmp12_ = NULL;
				ValaBinaryExpression* _tmp13_ = NULL;
				vala_genie_parser_next (self);
				_tmp6_ = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
				right = _tmp6_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp7_ = operator;
				_tmp8_ = left;
				_tmp9_ = right;
				_tmp10_ = begin;
				_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = vala_binary_expression_new (_tmp7_, _tmp8_, _tmp9_, _tmp12_);
				_vala_code_node_unref0 (left);
				left = (ValaExpression*) _tmp13_;
				_vala_source_reference_unref0 (_tmp12_);
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_BINARY_OPERATOR_GREATER_THAN:
			{
				gboolean _tmp14_ = FALSE;
				ValaGenieTokenType _tmp15_ = 0;
				gboolean _tmp17_ = FALSE;
				vala_genie_parser_next (self);
				_tmp15_ = vala_genie_parser_current (self);
				if (_tmp15_ != VALA_GENIE_TOKEN_TYPE_OP_GT) {
					ValaGenieTokenType _tmp16_ = 0;
					_tmp16_ = vala_genie_parser_current (self);
					_tmp14_ = _tmp16_ != VALA_GENIE_TOKEN_TYPE_OP_GE;
				} else {
					_tmp14_ = FALSE;
				}
				_tmp17_ = _tmp14_;
				if (_tmp17_) {
					ValaExpression* right = NULL;
					ValaExpression* _tmp18_ = NULL;
					ValaBinaryOperator _tmp19_ = 0;
					ValaExpression* _tmp20_ = NULL;
					ValaExpression* _tmp21_ = NULL;
					ValaSourceLocation _tmp22_ = {0};
					ValaSourceReference* _tmp23_ = NULL;
					ValaSourceReference* _tmp24_ = NULL;
					ValaBinaryExpression* _tmp25_ = NULL;
					_tmp18_ = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
					right = _tmp18_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp19_ = operator;
					_tmp20_ = left;
					_tmp21_ = right;
					_tmp22_ = begin;
					_tmp23_ = vala_genie_parser_get_src (self, &_tmp22_);
					_tmp24_ = _tmp23_;
					_tmp25_ = vala_binary_expression_new (_tmp19_, _tmp20_, _tmp21_, _tmp24_);
					_vala_code_node_unref0 (left);
					left = (ValaExpression*) _tmp25_;
					_vala_source_reference_unref0 (_tmp24_);
					_vala_code_node_unref0 (right);
				} else {
					vala_genie_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				ValaGenieTokenType _tmp26_ = 0;
				_tmp26_ = vala_genie_parser_current (self);
				switch (_tmp26_) {
					case VALA_GENIE_TOKEN_TYPE_ISA:
					{
						ValaDataType* type = NULL;
						ValaDataType* _tmp27_ = NULL;
						ValaExpression* _tmp28_ = NULL;
						ValaDataType* _tmp29_ = NULL;
						ValaSourceLocation _tmp30_ = {0};
						ValaSourceReference* _tmp31_ = NULL;
						ValaSourceReference* _tmp32_ = NULL;
						ValaTypeCheck* _tmp33_ = NULL;
						vala_genie_parser_next (self);
						_tmp27_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
						type = _tmp27_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_tmp28_ = left;
						_tmp29_ = type;
						_tmp30_ = begin;
						_tmp31_ = vala_genie_parser_get_src (self, &_tmp30_);
						_tmp32_ = _tmp31_;
						_tmp33_ = vala_typecheck_new (_tmp28_, _tmp29_, _tmp32_);
						_vala_code_node_unref0 (left);
						left = (ValaExpression*) _tmp33_;
						_vala_source_reference_unref0 (_tmp32_);
						_vala_code_node_unref0 (type);
						break;
					}
					case VALA_GENIE_TOKEN_TYPE_AS:
					{
						ValaDataType* type = NULL;
						ValaDataType* _tmp34_ = NULL;
						ValaExpression* _tmp35_ = NULL;
						ValaDataType* _tmp36_ = NULL;
						ValaSourceLocation _tmp37_ = {0};
						ValaSourceReference* _tmp38_ = NULL;
						ValaSourceReference* _tmp39_ = NULL;
						ValaCastExpression* _tmp40_ = NULL;
						vala_genie_parser_next (self);
						_tmp34_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
						type = _tmp34_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_tmp35_ = left;
						_tmp36_ = type;
						_tmp37_ = begin;
						_tmp38_ = vala_genie_parser_get_src (self, &_tmp37_);
						_tmp39_ = _tmp38_;
						_tmp40_ = vala_cast_expression_new (_tmp35_, _tmp36_, _tmp39_, TRUE);
						_vala_code_node_unref0 (left);
						left = (ValaExpression*) _tmp40_;
						_vala_source_reference_unref0 (_tmp39_);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						found = FALSE;
						break;
					}
				}
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_equality_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean found = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_relational_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaBinaryOperator operator = 0;
		ValaGenieTokenType _tmp3_ = 0;
		ValaBinaryOperator _tmp4_ = 0;
		ValaBinaryOperator _tmp5_ = 0;
		_tmp2_ = found;
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_current (self);
		_tmp4_ = vala_genie_parser_get_binary_operator (self, _tmp3_);
		operator = _tmp4_;
		_tmp5_ = operator;
		switch (_tmp5_) {
			case VALA_BINARY_OPERATOR_INEQUALITY:
			case VALA_BINARY_OPERATOR_EQUALITY:
			{
				gboolean _tmp6_ = FALSE;
				ValaBinaryOperator _tmp7_ = 0;
				gboolean _tmp9_ = FALSE;
				ValaExpression* right = NULL;
				ValaExpression* _tmp10_ = NULL;
				ValaBinaryOperator _tmp11_ = 0;
				ValaExpression* _tmp12_ = NULL;
				ValaExpression* _tmp13_ = NULL;
				ValaSourceLocation _tmp14_ = {0};
				ValaSourceReference* _tmp15_ = NULL;
				ValaSourceReference* _tmp16_ = NULL;
				ValaBinaryExpression* _tmp17_ = NULL;
				_tmp7_ = operator;
				if (_tmp7_ == VALA_BINARY_OPERATOR_INEQUALITY) {
					ValaGenieTokenType _tmp8_ = 0;
					_tmp8_ = vala_genie_parser_current (self);
					_tmp6_ = _tmp8_ == VALA_GENIE_TOKEN_TYPE_IS;
				} else {
					_tmp6_ = FALSE;
				}
				_tmp9_ = _tmp6_;
				if (_tmp9_) {
					vala_genie_parser_next (self);
				}
				vala_genie_parser_next (self);
				_tmp10_ = vala_genie_parser_parse_relational_expression (self, &_inner_error_);
				right = _tmp10_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp11_ = operator;
				_tmp12_ = left;
				_tmp13_ = right;
				_tmp14_ = begin;
				_tmp15_ = vala_genie_parser_get_src (self, &_tmp14_);
				_tmp16_ = _tmp15_;
				_tmp17_ = vala_binary_expression_new (_tmp11_, _tmp12_, _tmp13_, _tmp16_);
				_vala_code_node_unref0 (left);
				left = (ValaExpression*) _tmp17_;
				_vala_source_reference_unref0 (_tmp16_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_and_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_equality_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_BITWISE_AND);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_equality_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_AND, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_exclusive_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_and_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CARRET);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_and_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_XOR, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_inclusive_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_exclusive_or_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_BITWISE_OR);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_exclusive_or_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_OR, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_in_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_inclusive_or_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IN);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_inclusive_or_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_IN, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_and_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_in_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_AND);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_in_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_AND, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* left = NULL;
	ValaExpression* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_conditional_and_expression (self, &_inner_error_);
	left = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		ValaExpression* right = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaSourceLocation _tmp6_ = {0};
		ValaSourceReference* _tmp7_ = NULL;
		ValaSourceReference* _tmp8_ = NULL;
		ValaBinaryExpression* _tmp9_ = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_OR);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = vala_genie_parser_parse_conditional_and_expression (self, &_inner_error_);
		right = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = left;
		_tmp5_ = right;
		_tmp6_ = begin;
		_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_OR, _tmp4_, _tmp5_, _tmp8_);
		_vala_code_node_unref0 (left);
		left = (ValaExpression*) _tmp9_;
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* condition = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_conditional_or_expression (self, &_inner_error_);
	condition = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
	if (_tmp2_) {
		ValaExpression* true_expr = NULL;
		ValaExpression* _tmp3_ = NULL;
		ValaExpression* false_expr = NULL;
		ValaExpression* _tmp4_ = NULL;
		ValaExpression* _tmp5_ = NULL;
		ValaExpression* _tmp6_ = NULL;
		ValaExpression* _tmp7_ = NULL;
		ValaSourceLocation _tmp8_ = {0};
		ValaSourceReference* _tmp9_ = NULL;
		ValaSourceReference* _tmp10_ = NULL;
		ValaConditionalExpression* _tmp11_ = NULL;
		ValaExpression* _tmp12_ = NULL;
		_tmp3_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		true_expr = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp4_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		false_expr = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp5_ = condition;
		_tmp6_ = true_expr;
		_tmp7_ = false_expr;
		_tmp8_ = begin;
		_tmp9_ = vala_genie_parser_get_src (self, &_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = vala_conditional_expression_new (_tmp5_, _tmp6_, _tmp7_, _tmp10_);
		_tmp12_ = (ValaExpression*) _tmp11_;
		_vala_source_reference_unref0 (_tmp10_);
		result = _tmp12_;
		_vala_code_node_unref0 (false_expr);
		_vala_code_node_unref0 (true_expr);
		_vala_code_node_unref0 (condition);
		return result;
	} else {
		result = condition;
		return result;
	}
	_vala_code_node_unref0 (condition);
}


static ValaParameter* vala_genie_parser_parse_lambda_parameter (ValaGenieParser* self, GError** error) {
	ValaParameter* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaParameterDirection direction = 0;
	gboolean _tmp1_ = FALSE;
	gchar* id = NULL;
	gchar* _tmp3_ = NULL;
	ValaParameter* param = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaParameter* _tmp7_ = NULL;
	ValaParameter* _tmp8_ = NULL;
	ValaParameter* _tmp9_ = NULL;
	ValaParameterDirection _tmp10_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	direction = VALA_PARAMETER_DIRECTION_IN;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OUT);
	if (_tmp1_) {
		direction = VALA_PARAMETER_DIRECTION_OUT;
	} else {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REF);
		if (_tmp2_) {
			direction = VALA_PARAMETER_DIRECTION_REF;
		}
	}
	_tmp3_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = begin;
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_parameter_new (id, NULL, _tmp6_);
	_tmp8_ = _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	param = _tmp8_;
	_tmp9_ = param;
	_tmp10_ = direction;
	vala_parameter_set_direction (_tmp9_, _tmp10_);
	result = param;
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_lambda_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaList* params = NULL;
	GEqualFunc _tmp1_ = NULL;
	ValaArrayList* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	ValaLambdaExpression* lambda = NULL;
	gboolean _tmp16_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = g_direct_equal;
	_tmp2_ = vala_array_list_new (VALA_TYPE_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp1_);
	params = (ValaList*) _tmp2_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	if (_tmp3_) {
		ValaGenieTokenType _tmp4_ = 0;
		_tmp4_ = vala_genie_parser_current (self);
		if (_tmp4_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					gboolean _tmp6_ = FALSE;
					ValaParameter* _tmp8_ = NULL;
					ValaParameter* _tmp9_ = NULL;
					ValaList* _tmp10_ = NULL;
					ValaParameter* _tmp11_ = NULL;
					_tmp6_ = _tmp5_;
					if (!_tmp6_) {
						gboolean _tmp7_ = FALSE;
						_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp7_) {
							break;
						}
					}
					_tmp5_ = FALSE;
					_tmp9_ = vala_genie_parser_parse_lambda_parameter (self, &_inner_error_);
					_tmp8_ = _tmp9_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_iterable_unref0 (params);
							return NULL;
						} else {
							_vala_iterable_unref0 (params);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp10_ = params;
					_tmp11_ = _tmp8_;
					vala_collection_add ((ValaCollection*) _tmp10_, _tmp11_);
					_vala_code_node_unref0 (_tmp11_);
				}
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (params);
				return NULL;
			} else {
				_vala_iterable_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		ValaParameter* _tmp12_ = NULL;
		ValaParameter* _tmp13_ = NULL;
		ValaList* _tmp14_ = NULL;
		ValaParameter* _tmp15_ = NULL;
		_tmp13_ = vala_genie_parser_parse_lambda_parameter (self, &_inner_error_);
		_tmp12_ = _tmp13_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (params);
				return NULL;
			} else {
				_vala_iterable_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp14_ = params;
		_tmp15_ = _tmp12_;
		vala_collection_add ((ValaCollection*) _tmp14_, _tmp15_);
		_vala_code_node_unref0 (_tmp15_);
	}
	_tmp16_ = vala_genie_parser_accept_block (self);
	if (_tmp16_) {
		ValaBlock* block = NULL;
		ValaBlock* _tmp17_ = NULL;
		ValaBlock* _tmp18_ = NULL;
		ValaSourceLocation _tmp19_ = {0};
		ValaSourceReference* _tmp20_ = NULL;
		ValaSourceReference* _tmp21_ = NULL;
		ValaLambdaExpression* _tmp22_ = NULL;
		_tmp17_ = vala_genie_parser_parse_block (self, &_inner_error_);
		block = _tmp17_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp18_ = block;
		_tmp19_ = begin;
		_tmp20_ = vala_genie_parser_get_src (self, &_tmp19_);
		_tmp21_ = _tmp20_;
		_tmp22_ = vala_lambda_expression_new_with_statement_body (_tmp18_, _tmp21_);
		_vala_code_node_unref0 (lambda);
		lambda = _tmp22_;
		_vala_source_reference_unref0 (_tmp21_);
		_vala_code_node_unref0 (block);
	} else {
		ValaExpression* expr = NULL;
		ValaExpression* _tmp23_ = NULL;
		ValaExpression* _tmp24_ = NULL;
		ValaSourceLocation _tmp25_ = {0};
		ValaSourceReference* _tmp26_ = NULL;
		ValaSourceReference* _tmp27_ = NULL;
		ValaLambdaExpression* _tmp28_ = NULL;
		_tmp23_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		expr = _tmp23_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp24_ = expr;
		_tmp25_ = begin;
		_tmp26_ = vala_genie_parser_get_src (self, &_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = vala_lambda_expression_new (_tmp24_, _tmp27_);
		_vala_code_node_unref0 (lambda);
		lambda = _tmp28_;
		_vala_source_reference_unref0 (_tmp27_);
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				_vala_code_node_unref0 (lambda);
				_vala_iterable_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (expr);
	}
	{
		ValaList* _param_list = NULL;
		ValaList* _tmp29_ = NULL;
		ValaList* _tmp30_ = NULL;
		gint _param_size = 0;
		ValaList* _tmp31_ = NULL;
		gint _tmp32_ = 0;
		gint _tmp33_ = 0;
		gint _param_index = 0;
		_tmp29_ = params;
		_tmp30_ = _vala_iterable_ref0 (_tmp29_);
		_param_list = _tmp30_;
		_tmp31_ = _param_list;
		_tmp32_ = vala_collection_get_size ((ValaCollection*) _tmp31_);
		_tmp33_ = _tmp32_;
		_param_size = _tmp33_;
		_param_index = -1;
		while (TRUE) {
			gint _tmp34_ = 0;
			gint _tmp35_ = 0;
			gint _tmp36_ = 0;
			ValaParameter* param = NULL;
			ValaList* _tmp37_ = NULL;
			gint _tmp38_ = 0;
			gpointer _tmp39_ = NULL;
			ValaLambdaExpression* _tmp40_ = NULL;
			ValaParameter* _tmp41_ = NULL;
			_tmp34_ = _param_index;
			_param_index = _tmp34_ + 1;
			_tmp35_ = _param_index;
			_tmp36_ = _param_size;
			if (!(_tmp35_ < _tmp36_)) {
				break;
			}
			_tmp37_ = _param_list;
			_tmp38_ = _param_index;
			_tmp39_ = vala_list_get (_tmp37_, _tmp38_);
			param = (ValaParameter*) _tmp39_;
			_tmp40_ = lambda;
			_tmp41_ = param;
			vala_lambda_expression_add_parameter (_tmp40_, _tmp41_);
			_vala_code_node_unref0 (param);
		}
		_vala_iterable_unref0 (_param_list);
	}
	result = (ValaExpression*) lambda;
	_vala_iterable_unref0 (params);
	return result;
}


static ValaAssignmentOperator vala_genie_parser_get_assignment_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaAssignmentOperator result = 0;
	ValaGenieTokenType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = token_type;
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_ASSIGN:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SIMPLE;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD:
		{
			result = VALA_ASSIGNMENT_OPERATOR_ADD;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SUB;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_OR;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_AND;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV:
		{
			result = VALA_ASSIGNMENT_OPERATOR_DIV;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL:
		{
			result = VALA_ASSIGNMENT_OPERATOR_MUL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_PERCENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT;
			return result;
		}
		default:
		{
			result = VALA_ASSIGNMENT_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaGenieTokenType _tmp0_ = 0;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp2_ = {0};
	ValaExpression* expr = NULL;
	ValaExpression* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_current (self);
	if (_tmp0_ == VALA_GENIE_TOKEN_TYPE_DEF) {
		ValaExpression* lambda = NULL;
		ValaExpression* _tmp1_ = NULL;
		_tmp1_ = vala_genie_parser_parse_lambda_expression (self, &_inner_error_);
		lambda = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		self->priv->current_expr_is_lambda = TRUE;
		result = lambda;
		return result;
	} else {
		self->priv->current_expr_is_lambda = FALSE;
	}
	vala_genie_parser_get_location (self, &_tmp2_);
	begin = _tmp2_;
	_tmp3_ = vala_genie_parser_parse_conditional_expression (self, &_inner_error_);
	expr = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaAssignmentOperator operator = 0;
		ValaGenieTokenType _tmp4_ = 0;
		ValaAssignmentOperator _tmp5_ = 0;
		ValaAssignmentOperator _tmp6_ = 0;
		_tmp4_ = vala_genie_parser_current (self);
		_tmp5_ = vala_genie_parser_get_assignment_operator (self, _tmp4_);
		operator = _tmp5_;
		_tmp6_ = operator;
		if (_tmp6_ != VALA_ASSIGNMENT_OPERATOR_NONE) {
			ValaExpression* rhs = NULL;
			ValaExpression* _tmp7_ = NULL;
			ValaExpression* _tmp8_ = NULL;
			ValaExpression* _tmp9_ = NULL;
			ValaAssignmentOperator _tmp10_ = 0;
			ValaSourceLocation _tmp11_ = {0};
			ValaSourceReference* _tmp12_ = NULL;
			ValaSourceReference* _tmp13_ = NULL;
			ValaAssignment* _tmp14_ = NULL;
			vala_genie_parser_next (self);
			_tmp7_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			rhs = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp8_ = expr;
			_tmp9_ = rhs;
			_tmp10_ = operator;
			_tmp11_ = begin;
			_tmp12_ = vala_genie_parser_get_src (self, &_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = vala_assignment_new (_tmp8_, _tmp9_, _tmp10_, _tmp13_);
			_vala_code_node_unref0 (expr);
			expr = (ValaExpression*) _tmp14_;
			_vala_source_reference_unref0 (_tmp13_);
			_vala_code_node_unref0 (rhs);
		} else {
			ValaGenieTokenType _tmp15_ = 0;
			_tmp15_ = vala_genie_parser_current (self);
			if (_tmp15_ == VALA_GENIE_TOKEN_TYPE_OP_GT) {
				gchar* first_gt_pos = NULL;
				ValaGenieParserTokenInfo* _tmp16_ = NULL;
				gint _tmp16__length1 = 0;
				gint _tmp17_ = 0;
				ValaGenieParserTokenInfo _tmp18_ = {0};
				ValaSourceLocation _tmp19_ = {0};
				gchar* _tmp20_ = NULL;
				gboolean _tmp21_ = FALSE;
				ValaGenieTokenType _tmp22_ = 0;
				gboolean _tmp29_ = FALSE;
				_tmp16_ = self->priv->tokens;
				_tmp16__length1 = self->priv->tokens_length1;
				_tmp17_ = self->priv->index;
				_tmp18_ = _tmp16_[_tmp17_];
				_tmp19_ = _tmp18_.begin;
				_tmp20_ = _tmp19_.pos;
				first_gt_pos = _tmp20_;
				vala_genie_parser_next (self);
				_tmp22_ = vala_genie_parser_current (self);
				if (_tmp22_ == VALA_GENIE_TOKEN_TYPE_OP_GE) {
					ValaGenieParserTokenInfo* _tmp23_ = NULL;
					gint _tmp23__length1 = 0;
					gint _tmp24_ = 0;
					ValaGenieParserTokenInfo _tmp25_ = {0};
					ValaSourceLocation _tmp26_ = {0};
					gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					_tmp23_ = self->priv->tokens;
					_tmp23__length1 = self->priv->tokens_length1;
					_tmp24_ = self->priv->index;
					_tmp25_ = _tmp23_[_tmp24_];
					_tmp26_ = _tmp25_.begin;
					_tmp27_ = _tmp26_.pos;
					_tmp28_ = first_gt_pos;
					_tmp21_ = _tmp27_ == (_tmp28_ + 1);
				} else {
					_tmp21_ = FALSE;
				}
				_tmp29_ = _tmp21_;
				if (_tmp29_) {
					ValaExpression* rhs = NULL;
					ValaExpression* _tmp30_ = NULL;
					ValaExpression* _tmp31_ = NULL;
					ValaExpression* _tmp32_ = NULL;
					ValaSourceLocation _tmp33_ = {0};
					ValaSourceReference* _tmp34_ = NULL;
					ValaSourceReference* _tmp35_ = NULL;
					ValaAssignment* _tmp36_ = NULL;
					vala_genie_parser_next (self);
					_tmp30_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					rhs = _tmp30_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (expr);
							return NULL;
						} else {
							_vala_code_node_unref0 (expr);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp31_ = expr;
					_tmp32_ = rhs;
					_tmp33_ = begin;
					_tmp34_ = vala_genie_parser_get_src (self, &_tmp33_);
					_tmp35_ = _tmp34_;
					_tmp36_ = vala_assignment_new (_tmp31_, _tmp32_, VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT, _tmp35_);
					_vala_code_node_unref0 (expr);
					expr = (ValaExpression*) _tmp36_;
					_vala_source_reference_unref0 (_tmp35_);
					_vala_code_node_unref0 (rhs);
				} else {
					vala_genie_parser_prev (self);
					break;
				}
			} else {
				break;
			}
		}
	}
	result = expr;
	return result;
}


static ValaStatement* vala_genie_parser_get_for_statement_type (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean is_foreach = FALSE;
	ValaSourceLocation _tmp6_ = {0};
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	is_foreach = FALSE;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		ValaGenieTokenType _tmp2_ = 0;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		_tmp2_ = vala_genie_parser_current (self);
		if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_EOL) {
			ValaGenieTokenType _tmp3_ = 0;
			_tmp3_ = vala_genie_parser_current (self);
			_tmp1_ = _tmp3_ != VALA_GENIE_TOKEN_TYPE_DO;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		if (!_tmp4_) {
			break;
		}
		vala_genie_parser_next (self);
		_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IN);
		if (_tmp5_) {
			is_foreach = TRUE;
			break;
		}
	}
	_tmp6_ = begin;
	vala_genie_parser_rollback (self, &_tmp6_);
	_tmp7_ = is_foreach;
	if (_tmp7_) {
		ValaStatement* _tmp8_ = NULL;
		ValaStatement* _tmp9_ = NULL;
		_tmp9_ = vala_genie_parser_parse_foreach_statement (self, &_inner_error_);
		_tmp8_ = _tmp9_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp8_;
		return result;
	} else {
		ValaStatement* _tmp10_ = NULL;
		ValaStatement* _tmp11_ = NULL;
		_tmp11_ = vala_genie_parser_parse_for_statement (self, &_inner_error_);
		_tmp10_ = _tmp11_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp10_;
		return result;
	}
}


static void vala_genie_parser_parse_statements (ValaGenieParser* self, ValaBlock* block, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		ValaGenieTokenType _tmp2_ = 0;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp6_ = FALSE;
		_tmp2_ = vala_genie_parser_current (self);
		if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_DEDENT) {
			ValaGenieTokenType _tmp3_ = 0;
			_tmp3_ = vala_genie_parser_current (self);
			_tmp1_ = _tmp3_ != VALA_GENIE_TOKEN_TYPE_WHEN;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		if (_tmp4_) {
			ValaGenieTokenType _tmp5_ = 0;
			_tmp5_ = vala_genie_parser_current (self);
			_tmp0_ = _tmp5_ != VALA_GENIE_TOKEN_TYPE_DEFAULT;
		} else {
			_tmp0_ = FALSE;
		}
		_tmp6_ = _tmp0_;
		if (!_tmp6_) {
			break;
		}
		{
			ValaStatement* stmt = NULL;
			gboolean is_decl = FALSE;
			ValaGenieScanner* _tmp7_ = NULL;
			ValaComment* _tmp8_ = NULL;
			ValaGenieTokenType _tmp9_ = 0;
			gboolean _tmp61_ = FALSE;
			stmt = NULL;
			is_decl = FALSE;
			_tmp7_ = self->priv->scanner;
			_tmp8_ = vala_genie_scanner_pop_comment (_tmp7_);
			_vala_comment_unref0 (self->priv->comment);
			self->priv->comment = _tmp8_;
			_tmp9_ = vala_genie_parser_current (self);
			switch (_tmp9_) {
				case VALA_GENIE_TOKEN_TYPE_REQUIRES:
				case VALA_GENIE_TOKEN_TYPE_ENSURES:
				{
					ValaSourceLocation begin = {0};
					ValaSourceLocation _tmp10_ = {0};
					gboolean _tmp11_ = FALSE;
					gboolean _tmp12_ = FALSE;
					gboolean _tmp14_ = FALSE;
					ValaSourceLocation _tmp17_ = {0};
					ValaSourceReference* _tmp18_ = NULL;
					ValaSourceReference* _tmp19_ = NULL;
					ValaEmptyStatement* _tmp20_ = NULL;
					vala_genie_parser_get_location (self, &_tmp10_);
					begin = _tmp10_;
					vala_genie_parser_next (self);
					_tmp12_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
					if (_tmp12_) {
						gboolean _tmp13_ = FALSE;
						_tmp13_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
						_tmp11_ = _tmp13_;
					} else {
						_tmp11_ = FALSE;
					}
					_tmp14_ = _tmp11_;
					if (_tmp14_) {
						while (TRUE) {
							ValaGenieTokenType _tmp15_ = 0;
							_tmp15_ = vala_genie_parser_current (self);
							if (!(_tmp15_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
								break;
							}
							vala_genie_parser_next (self);
						}
						vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch7_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					} else {
						while (TRUE) {
							ValaGenieTokenType _tmp16_ = 0;
							_tmp16_ = vala_genie_parser_current (self);
							if (!(_tmp16_ != VALA_GENIE_TOKEN_TYPE_EOL)) {
								break;
							}
							vala_genie_parser_next (self);
						}
						vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch7_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp17_ = begin;
					_tmp18_ = vala_genie_parser_get_src (self, &_tmp17_);
					_tmp19_ = _tmp18_;
					_tmp20_ = vala_empty_statement_new (_tmp19_);
					_vala_code_node_unref0 (stmt);
					stmt = (ValaStatement*) _tmp20_;
					_vala_source_reference_unref0 (_tmp19_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_INDENT:
				{
					ValaBlock* _tmp21_ = NULL;
					ValaBlock* _tmp22_ = NULL;
					_tmp22_ = vala_genie_parser_parse_block (self, &_inner_error_);
					_tmp21_ = _tmp22_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = (ValaStatement*) _tmp21_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_SEMICOLON:
				case VALA_GENIE_TOKEN_TYPE_PASS:
				{
					ValaStatement* _tmp23_ = NULL;
					ValaStatement* _tmp24_ = NULL;
					_tmp24_ = vala_genie_parser_parse_empty_statement (self, &_inner_error_);
					_tmp23_ = _tmp24_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp23_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_PRINT:
				case VALA_GENIE_TOKEN_TYPE_ASSERT:
				{
					ValaStatement* _tmp25_ = NULL;
					ValaStatement* _tmp26_ = NULL;
					_tmp26_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
					_tmp25_ = _tmp26_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp25_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_IF:
				{
					ValaStatement* _tmp27_ = NULL;
					ValaStatement* _tmp28_ = NULL;
					_tmp28_ = vala_genie_parser_parse_if_statement (self, &_inner_error_);
					_tmp27_ = _tmp28_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp27_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_CASE:
				{
					ValaStatement* _tmp29_ = NULL;
					ValaStatement* _tmp30_ = NULL;
					_tmp30_ = vala_genie_parser_parse_switch_statement (self, &_inner_error_);
					_tmp29_ = _tmp30_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp29_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_WHILE:
				{
					ValaStatement* _tmp31_ = NULL;
					ValaStatement* _tmp32_ = NULL;
					_tmp32_ = vala_genie_parser_parse_while_statement (self, &_inner_error_);
					_tmp31_ = _tmp32_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp31_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_DO:
				{
					ValaStatement* _tmp33_ = NULL;
					ValaStatement* _tmp34_ = NULL;
					_tmp34_ = vala_genie_parser_parse_do_statement (self, &_inner_error_);
					_tmp33_ = _tmp34_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp33_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_FOR:
				{
					ValaStatement* _tmp35_ = NULL;
					ValaStatement* _tmp36_ = NULL;
					_tmp36_ = vala_genie_parser_get_for_statement_type (self, &_inner_error_);
					_tmp35_ = _tmp36_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp35_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_BREAK:
				{
					ValaStatement* _tmp37_ = NULL;
					ValaStatement* _tmp38_ = NULL;
					_tmp38_ = vala_genie_parser_parse_break_statement (self, &_inner_error_);
					_tmp37_ = _tmp38_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp37_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_CONTINUE:
				{
					ValaStatement* _tmp39_ = NULL;
					ValaStatement* _tmp40_ = NULL;
					_tmp40_ = vala_genie_parser_parse_continue_statement (self, &_inner_error_);
					_tmp39_ = _tmp40_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp39_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_RETURN:
				{
					ValaStatement* _tmp41_ = NULL;
					ValaStatement* _tmp42_ = NULL;
					_tmp42_ = vala_genie_parser_parse_return_statement (self, &_inner_error_);
					_tmp41_ = _tmp42_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp41_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_RAISE:
				{
					ValaStatement* _tmp43_ = NULL;
					ValaStatement* _tmp44_ = NULL;
					_tmp44_ = vala_genie_parser_parse_throw_statement (self, &_inner_error_);
					_tmp43_ = _tmp44_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp43_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_TRY:
				{
					ValaStatement* _tmp45_ = NULL;
					ValaStatement* _tmp46_ = NULL;
					_tmp46_ = vala_genie_parser_parse_try_statement (self, &_inner_error_);
					_tmp45_ = _tmp46_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp45_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_LOCK:
				{
					ValaStatement* _tmp47_ = NULL;
					ValaStatement* _tmp48_ = NULL;
					_tmp48_ = vala_genie_parser_parse_lock_statement (self, &_inner_error_);
					_tmp47_ = _tmp48_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp47_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_DELETE:
				{
					ValaStatement* _tmp49_ = NULL;
					ValaStatement* _tmp50_ = NULL;
					_tmp50_ = vala_genie_parser_parse_delete_statement (self, &_inner_error_);
					_tmp49_ = _tmp50_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp49_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_VAR:
				{
					ValaBlock* _tmp51_ = NULL;
					is_decl = TRUE;
					_tmp51_ = block;
					vala_genie_parser_parse_local_variable_declarations (self, _tmp51_, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_YIELD:
				{
					ValaStatement* _tmp52_ = NULL;
					ValaStatement* _tmp53_ = NULL;
					_tmp53_ = vala_genie_parser_parse_yield_statement (self, &_inner_error_);
					_tmp52_ = _tmp53_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp52_;
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_OP_INC:
				case VALA_GENIE_TOKEN_TYPE_OP_DEC:
				case VALA_GENIE_TOKEN_TYPE_SUPER:
				case VALA_GENIE_TOKEN_TYPE_THIS:
				case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
				case VALA_GENIE_TOKEN_TYPE_STAR:
				case VALA_GENIE_TOKEN_TYPE_NEW:
				{
					ValaStatement* _tmp54_ = NULL;
					ValaStatement* _tmp55_ = NULL;
					_tmp55_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
					_tmp54_ = _tmp55_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_vala_code_node_unref0 (stmt);
					stmt = _tmp54_;
					break;
				}
				default:
				{
					gboolean is_expr = FALSE;
					gboolean _tmp56_ = FALSE;
					gboolean _tmp57_ = FALSE;
					_tmp56_ = vala_genie_parser_is_expression (self, &_inner_error_);
					is_expr = _tmp56_;
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_tmp57_ = is_expr;
					if (_tmp57_) {
						ValaStatement* _tmp58_ = NULL;
						ValaStatement* _tmp59_ = NULL;
						_tmp59_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
						_tmp58_ = _tmp59_;
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch7_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						_vala_code_node_unref0 (stmt);
						stmt = _tmp58_;
					} else {
						ValaBlock* _tmp60_ = NULL;
						is_decl = TRUE;
						_tmp60_ = block;
						vala_genie_parser_parse_local_variable_declarations (self, _tmp60_, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch7_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					break;
				}
			}
			_tmp61_ = is_decl;
			if (!_tmp61_) {
				ValaBlock* _tmp62_ = NULL;
				ValaStatement* _tmp63_ = NULL;
				_tmp62_ = block;
				_tmp63_ = stmt;
				vala_block_add_statement (_tmp62_, _tmp63_);
			}
			_vala_code_node_unref0 (stmt);
		}
		goto __finally7;
		__catch7_vala_parse_error:
		{
			GError* e = NULL;
			ValaGenieParserRecoveryState _tmp64_ = 0;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp64_ = vala_genie_parser_recover (self);
			if (_tmp64_ != VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN) {
				_g_error_free0 (e);
				break;
			}
			_g_error_free0 (e);
		}
		__finally7:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static gboolean vala_genie_parser_is_expression (ValaGenieParser* self, GError** error) {
	gboolean result = FALSE;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieTokenType _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_skip_type (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	_tmp1_ = vala_genie_parser_current (self);
	switch (_tmp1_) {
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		case VALA_GENIE_TOKEN_TYPE_OP_INC:
		case VALA_GENIE_TOKEN_TYPE_OP_DEC:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB:
		case VALA_GENIE_TOKEN_TYPE_OP_GT:
		case VALA_GENIE_TOKEN_TYPE_DOT:
		case VALA_GENIE_TOKEN_TYPE_OP_PTR:
		{
			ValaSourceLocation _tmp2_ = {0};
			_tmp2_ = begin;
			vala_genie_parser_rollback (self, &_tmp2_);
			result = TRUE;
			return result;
		}
		default:
		{
			ValaSourceLocation _tmp3_ = {0};
			_tmp3_ = begin;
			vala_genie_parser_rollback (self, &_tmp3_);
			result = FALSE;
			return result;
		}
	}
}


static ValaBlock* vala_genie_parser_parse_embedded_statement (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaGenieTokenType _tmp0_ = 0;
	ValaGenieScanner* _tmp2_ = NULL;
	ValaComment* _tmp3_ = NULL;
	ValaBlock* block = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaBlock* _tmp7_ = NULL;
	ValaBlock* _tmp8_ = NULL;
	ValaStatement* _tmp9_ = NULL;
	ValaStatement* _tmp10_ = NULL;
	ValaBlock* _tmp11_ = NULL;
	ValaStatement* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_current (self);
	if (_tmp0_ == VALA_GENIE_TOKEN_TYPE_INDENT) {
		ValaBlock* block = NULL;
		ValaBlock* _tmp1_ = NULL;
		_tmp1_ = vala_genie_parser_parse_block (self, &_inner_error_);
		block = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = block;
		return result;
	}
	_tmp2_ = self->priv->scanner;
	_tmp3_ = vala_genie_scanner_pop_comment (_tmp2_);
	_vala_comment_unref0 (self->priv->comment);
	self->priv->comment = _tmp3_;
	vala_genie_parser_get_location (self, &_tmp4_);
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_block_new (_tmp6_);
	_tmp8_ = _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	block = _tmp8_;
	_tmp10_ = vala_genie_parser_parse_embedded_statement_without_block (self, &_inner_error_);
	_tmp9_ = _tmp10_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp11_ = block;
	_tmp12_ = _tmp9_;
	vala_block_add_statement (_tmp11_, _tmp12_);
	_vala_code_node_unref0 (_tmp12_);
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_embedded_statement_without_block (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaGenieTokenType _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_current (self);
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_PASS:
		case VALA_GENIE_TOKEN_TYPE_SEMICOLON:
		{
			ValaStatement* _tmp1_ = NULL;
			ValaStatement* _tmp2_ = NULL;
			_tmp2_ = vala_genie_parser_parse_empty_statement (self, &_inner_error_);
			_tmp1_ = _tmp2_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp1_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_IF:
		{
			ValaStatement* _tmp3_ = NULL;
			ValaStatement* _tmp4_ = NULL;
			_tmp4_ = vala_genie_parser_parse_if_statement (self, &_inner_error_);
			_tmp3_ = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp3_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CASE:
		{
			ValaStatement* _tmp5_ = NULL;
			ValaStatement* _tmp6_ = NULL;
			_tmp6_ = vala_genie_parser_parse_switch_statement (self, &_inner_error_);
			_tmp5_ = _tmp6_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp5_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_WHILE:
		{
			ValaStatement* _tmp7_ = NULL;
			ValaStatement* _tmp8_ = NULL;
			_tmp8_ = vala_genie_parser_parse_while_statement (self, &_inner_error_);
			_tmp7_ = _tmp8_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp7_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DO:
		{
			ValaStatement* _tmp9_ = NULL;
			ValaStatement* _tmp10_ = NULL;
			_tmp10_ = vala_genie_parser_parse_do_statement (self, &_inner_error_);
			_tmp9_ = _tmp10_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp9_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FOR:
		{
			ValaStatement* _tmp11_ = NULL;
			ValaStatement* _tmp12_ = NULL;
			_tmp12_ = vala_genie_parser_get_for_statement_type (self, &_inner_error_);
			_tmp11_ = _tmp12_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp11_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_BREAK:
		{
			ValaStatement* _tmp13_ = NULL;
			ValaStatement* _tmp14_ = NULL;
			_tmp14_ = vala_genie_parser_parse_break_statement (self, &_inner_error_);
			_tmp13_ = _tmp14_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp13_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CONTINUE:
		{
			ValaStatement* _tmp15_ = NULL;
			ValaStatement* _tmp16_ = NULL;
			_tmp16_ = vala_genie_parser_parse_continue_statement (self, &_inner_error_);
			_tmp15_ = _tmp16_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp15_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_RETURN:
		{
			ValaStatement* _tmp17_ = NULL;
			ValaStatement* _tmp18_ = NULL;
			_tmp18_ = vala_genie_parser_parse_return_statement (self, &_inner_error_);
			_tmp17_ = _tmp18_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp17_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			ValaStatement* _tmp19_ = NULL;
			ValaStatement* _tmp20_ = NULL;
			_tmp20_ = vala_genie_parser_parse_yield_statement (self, &_inner_error_);
			_tmp19_ = _tmp20_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp19_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_RAISE:
		{
			ValaStatement* _tmp21_ = NULL;
			ValaStatement* _tmp22_ = NULL;
			_tmp22_ = vala_genie_parser_parse_throw_statement (self, &_inner_error_);
			_tmp21_ = _tmp22_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp21_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TRY:
		{
			ValaStatement* _tmp23_ = NULL;
			ValaStatement* _tmp24_ = NULL;
			_tmp24_ = vala_genie_parser_parse_try_statement (self, &_inner_error_);
			_tmp23_ = _tmp24_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp23_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_LOCK:
		{
			ValaStatement* _tmp25_ = NULL;
			ValaStatement* _tmp26_ = NULL;
			_tmp26_ = vala_genie_parser_parse_lock_statement (self, &_inner_error_);
			_tmp25_ = _tmp26_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp25_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DELETE:
		{
			ValaStatement* _tmp27_ = NULL;
			ValaStatement* _tmp28_ = NULL;
			_tmp28_ = vala_genie_parser_parse_delete_statement (self, &_inner_error_);
			_tmp27_ = _tmp28_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp27_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_VAR:
		case VALA_GENIE_TOKEN_TYPE_CONST:
		{
			gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			GError* _tmp31_ = NULL;
			GError* _tmp32_ = NULL;
			_tmp29_ = vala_genie_parser_get_error (self, "embedded statement cannot be declaration ");
			_tmp30_ = _tmp29_;
			_tmp31_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp30_);
			_tmp32_ = _tmp31_;
			_g_free0 (_tmp30_);
			_inner_error_ = _tmp32_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		case VALA_GENIE_TOKEN_TYPE_OP_INC:
		case VALA_GENIE_TOKEN_TYPE_OP_DEC:
		case VALA_GENIE_TOKEN_TYPE_SUPER:
		case VALA_GENIE_TOKEN_TYPE_THIS:
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		case VALA_GENIE_TOKEN_TYPE_STAR:
		case VALA_GENIE_TOKEN_TYPE_NEW:
		{
			ValaStatement* _tmp33_ = NULL;
			ValaStatement* _tmp34_ = NULL;
			_tmp34_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
			_tmp33_ = _tmp34_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp33_;
			return result;
		}
		default:
		{
			gboolean _tmp35_ = FALSE;
			gboolean _tmp36_ = FALSE;
			_tmp36_ = vala_genie_parser_is_expression (self, &_inner_error_);
			_tmp35_ = _tmp36_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			if (_tmp35_) {
				ValaStatement* _tmp37_ = NULL;
				ValaStatement* _tmp38_ = NULL;
				_tmp38_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
				_tmp37_ = _tmp38_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return NULL;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				result = _tmp37_;
				return result;
			} else {
				gchar* _tmp39_ = NULL;
				gchar* _tmp40_ = NULL;
				GError* _tmp41_ = NULL;
				GError* _tmp42_ = NULL;
				_tmp39_ = vala_genie_parser_get_error (self, "embedded statement cannot be declaration");
				_tmp40_ = _tmp39_;
				_tmp41_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp40_);
				_tmp42_ = _tmp41_;
				_g_free0 (_tmp40_);
				_inner_error_ = _tmp42_;
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
}


static ValaBlock* vala_genie_parser_parse_block (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaBlock* block = NULL;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaBlock* _tmp4_ = NULL;
	ValaBlock* _tmp5_ = NULL;
	ValaBlock* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	ValaBlock* _tmp14_ = NULL;
	ValaSourceReference* _tmp15_ = NULL;
	ValaSourceReference* _tmp16_ = NULL;
	ValaSourceReference* _tmp17_ = NULL;
	ValaSourceReference* _tmp18_ = NULL;
	ValaSourceLocation _tmp19_ = {0};
	ValaSourceLocation _tmp20_ = {0};
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_block_new (_tmp3_);
	_tmp5_ = _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	block = _tmp5_;
	_tmp6_ = block;
	vala_genie_parser_parse_statements (self, _tmp6_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DEDENT);
	if (!_tmp7_) {
		ValaCodeContext* _tmp8_ = NULL;
		ValaReport* _tmp9_ = NULL;
		ValaReport* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		_tmp8_ = self->priv->context;
		_tmp9_ = vala_code_context_get_report (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = vala_report_get_errors (_tmp10_);
		if (_tmp11_ == 0) {
			ValaSourceReference* _tmp12_ = NULL;
			ValaSourceReference* _tmp13_ = NULL;
			_tmp12_ = vala_genie_parser_get_current_src (self);
			_tmp13_ = _tmp12_;
			vala_report_error (_tmp13_, "tab indentation is incorrect");
			_vala_source_reference_unref0 (_tmp13_);
		}
	}
	_tmp14_ = block;
	_tmp15_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = vala_genie_parser_get_current_src (self);
	_tmp18_ = _tmp17_;
	vala_source_reference_get_end (_tmp18_, &_tmp19_);
	_tmp20_ = _tmp19_;
	vala_source_reference_set_end (_tmp16_, &_tmp20_);
	_vala_source_reference_unref0 (_tmp18_);
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_empty_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaEmptyStatement* _tmp4_ = NULL;
	ValaStatement* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_PASS);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SEMICOLON);
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_empty_statement_new (_tmp3_);
	_tmp5_ = (ValaStatement*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static void vala_genie_parser_add_local_var_variable (ValaGenieParser* self, ValaBlock* block, const gchar* id, GError** error) {
	ValaDataType* type_copy = NULL;
	ValaLocalVariable* local = NULL;
	const gchar* _tmp0_ = NULL;
	ValaLocalVariable* _tmp1_ = NULL;
	ValaBlock* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaDeclarationStatement* _tmp5_ = NULL;
	ValaDeclarationStatement* _tmp6_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	g_return_if_fail (id != NULL);
	type_copy = NULL;
	_tmp0_ = id;
	_tmp1_ = vala_genie_parser_parse_local_variable (self, type_copy, _tmp0_, &_inner_error_);
	local = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type_copy);
			return;
		} else {
			_vala_code_node_unref0 (type_copy);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = block;
	_tmp3_ = vala_code_node_get_source_reference ((ValaCodeNode*) local);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_declaration_statement_new ((ValaSymbol*) local, _tmp4_);
	_tmp6_ = _tmp5_;
	vala_block_add_statement (_tmp2_, (ValaStatement*) _tmp6_);
	_vala_code_node_unref0 (_tmp6_);
	_vala_code_node_unref0 (local);
	_vala_code_node_unref0 (type_copy);
}


static void vala_genie_parser_parse_local_variable_declarations (ValaGenieParser* self, ValaBlock* block, GError** error) {
	gboolean _tmp0_ = FALSE;
	ValaArrayList* id_list = NULL;
	GEqualFunc _tmp12_ = NULL;
	ValaArrayList* _tmp13_ = NULL;
	ValaDataType* variable_type = NULL;
	ValaDataType* _tmp21_ = NULL;
	ValaDataType* _tmp22_ = NULL;
	ValaDataType* type = NULL;
	ValaDataType* _tmp23_ = NULL;
	ValaDataType* _tmp24_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR);
	if (_tmp0_) {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		if (_tmp2_) {
			gboolean _tmp3_ = FALSE;
			_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
			_tmp1_ = _tmp3_;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		if (_tmp4_) {
			while (TRUE) {
				ValaGenieTokenType _tmp5_ = 0;
				gchar* s = NULL;
				gchar* _tmp6_ = NULL;
				ValaBlock* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				_tmp5_ = vala_genie_parser_current (self);
				if (!(_tmp5_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
					break;
				}
				_tmp6_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
				s = _tmp6_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_tmp7_ = block;
				_tmp8_ = s;
				vala_genie_parser_add_local_var_variable (self, _tmp7_, _tmp8_, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (s);
						return;
					} else {
						_g_free0 (s);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
				vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SEMICOLON);
				_g_free0 (s);
			}
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			gchar* s = NULL;
			gchar* _tmp9_ = NULL;
			ValaBlock* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			_tmp9_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			s = _tmp9_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp10_ = block;
			_tmp11_ = s;
			vala_genie_parser_add_local_var_variable (self, _tmp10_, _tmp11_, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (s);
					return;
				} else {
					_g_free0 (s);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_genie_parser_expect_terminator (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (s);
					return;
				} else {
					_g_free0 (s);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_g_free0 (s);
		}
		return;
	}
	_tmp12_ = g_direct_equal;
	_tmp13_ = vala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, _tmp12_);
	id_list = _tmp13_;
	variable_type = NULL;
	{
		gboolean _tmp14_ = FALSE;
		_tmp14_ = TRUE;
		while (TRUE) {
			gboolean _tmp15_ = FALSE;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_ = NULL;
			ValaArrayList* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			_tmp15_ = _tmp14_;
			if (!_tmp15_) {
				gboolean _tmp16_ = FALSE;
				_tmp16_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
				if (!_tmp16_) {
					break;
				}
			}
			_tmp14_ = FALSE;
			_tmp18_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			_tmp17_ = _tmp18_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_vala_iterable_unref0 (id_list);
					return;
				} else {
					_vala_code_node_unref0 (variable_type);
					_vala_iterable_unref0 (id_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp19_ = id_list;
			_tmp20_ = _tmp17_;
			vala_collection_add ((ValaCollection*) _tmp19_, _tmp20_);
			_g_free0 (_tmp20_);
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp22_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
	_tmp21_ = _tmp22_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_code_node_unref0 (variable_type);
	variable_type = _tmp21_;
	_tmp23_ = variable_type;
	_tmp24_ = vala_genie_parser_parse_inline_array_type (self, _tmp23_, &_inner_error_);
	type = _tmp24_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		ValaArrayList* _id_list = NULL;
		ValaArrayList* _tmp25_ = NULL;
		ValaArrayList* _tmp26_ = NULL;
		gint _id_size = 0;
		ValaArrayList* _tmp27_ = NULL;
		gint _tmp28_ = 0;
		gint _tmp29_ = 0;
		gint _id_index = 0;
		_tmp25_ = id_list;
		_tmp26_ = _vala_iterable_ref0 (_tmp25_);
		_id_list = _tmp26_;
		_tmp27_ = _id_list;
		_tmp28_ = vala_collection_get_size ((ValaCollection*) _tmp27_);
		_tmp29_ = _tmp28_;
		_id_size = _tmp29_;
		_id_index = -1;
		while (TRUE) {
			gint _tmp30_ = 0;
			gint _tmp31_ = 0;
			gint _tmp32_ = 0;
			gchar* id = NULL;
			ValaArrayList* _tmp33_ = NULL;
			gint _tmp34_ = 0;
			gpointer _tmp35_ = NULL;
			ValaDataType* type_copy = NULL;
			ValaDataType* _tmp36_ = NULL;
			ValaLocalVariable* local = NULL;
			ValaDataType* _tmp39_ = NULL;
			const gchar* _tmp40_ = NULL;
			ValaLocalVariable* _tmp41_ = NULL;
			ValaBlock* _tmp42_ = NULL;
			ValaLocalVariable* _tmp43_ = NULL;
			ValaLocalVariable* _tmp44_ = NULL;
			ValaSourceReference* _tmp45_ = NULL;
			ValaSourceReference* _tmp46_ = NULL;
			ValaDeclarationStatement* _tmp47_ = NULL;
			ValaDeclarationStatement* _tmp48_ = NULL;
			_tmp30_ = _id_index;
			_id_index = _tmp30_ + 1;
			_tmp31_ = _id_index;
			_tmp32_ = _id_size;
			if (!(_tmp31_ < _tmp32_)) {
				break;
			}
			_tmp33_ = _id_list;
			_tmp34_ = _id_index;
			_tmp35_ = vala_list_get ((ValaList*) _tmp33_, _tmp34_);
			id = (gchar*) _tmp35_;
			type_copy = NULL;
			_tmp36_ = type;
			if (_tmp36_ != NULL) {
				ValaDataType* _tmp37_ = NULL;
				ValaDataType* _tmp38_ = NULL;
				_tmp37_ = type;
				_tmp38_ = vala_data_type_copy (_tmp37_);
				_vala_code_node_unref0 (type_copy);
				type_copy = _tmp38_;
			}
			_tmp39_ = type_copy;
			_tmp40_ = id;
			_tmp41_ = vala_genie_parser_parse_local_variable (self, _tmp39_, _tmp40_, &_inner_error_);
			local = _tmp41_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type_copy);
					_g_free0 (id);
					_vala_iterable_unref0 (_id_list);
					_vala_code_node_unref0 (type);
					_vala_code_node_unref0 (variable_type);
					_vala_iterable_unref0 (id_list);
					return;
				} else {
					_vala_code_node_unref0 (type_copy);
					_g_free0 (id);
					_vala_iterable_unref0 (_id_list);
					_vala_code_node_unref0 (type);
					_vala_code_node_unref0 (variable_type);
					_vala_iterable_unref0 (id_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp42_ = block;
			_tmp43_ = local;
			_tmp44_ = local;
			_tmp45_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp44_);
			_tmp46_ = _tmp45_;
			_tmp47_ = vala_declaration_statement_new ((ValaSymbol*) _tmp43_, _tmp46_);
			_tmp48_ = _tmp47_;
			vala_block_add_statement (_tmp42_, (ValaStatement*) _tmp48_);
			_vala_code_node_unref0 (_tmp48_);
			_vala_code_node_unref0 (local);
			_vala_code_node_unref0 (type_copy);
			_g_free0 (id);
		}
		_vala_iterable_unref0 (_id_list);
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (type);
			_vala_code_node_unref0 (variable_type);
			_vala_iterable_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_code_node_unref0 (type);
	_vala_code_node_unref0 (variable_type);
	_vala_iterable_unref0 (id_list);
}


static ValaLocalVariable* vala_genie_parser_parse_local_variable (ValaGenieParser* self, ValaDataType* variable_type, const gchar* id, GError** error) {
	ValaLocalVariable* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* initializer = NULL;
	gboolean _tmp1_ = FALSE;
	ValaDataType* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	ValaExpression* _tmp6_ = NULL;
	ValaSourceLocation _tmp7_ = {0};
	ValaSourceReference* _tmp8_ = NULL;
	ValaSourceReference* _tmp9_ = NULL;
	ValaLocalVariable* _tmp10_ = NULL;
	ValaLocalVariable* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	initializer = NULL;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp1_) {
		ValaExpression* _tmp2_ = NULL;
		ValaExpression* _tmp3_ = NULL;
		_tmp3_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (initializer);
		initializer = _tmp2_;
	}
	_tmp4_ = variable_type;
	_tmp5_ = id;
	_tmp6_ = initializer;
	_tmp7_ = begin;
	_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = vala_local_variable_new (_tmp4_, _tmp5_, _tmp6_, _tmp9_);
	_tmp11_ = _tmp10_;
	_vala_source_reference_unref0 (_tmp9_);
	result = _tmp11_;
	_vala_code_node_unref0 (initializer);
	return result;
}


static ValaStatement* vala_genie_parser_parse_expression_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	ValaExpression* _tmp3_ = NULL;
	ValaSourceLocation _tmp4_ = {0};
	ValaSourceReference* _tmp5_ = NULL;
	ValaSourceReference* _tmp6_ = NULL;
	ValaExpressionStatement* _tmp7_ = NULL;
	ValaStatement* _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_statement_expression (self, &_inner_error_);
	expr = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = self->priv->current_expr_is_lambda;
	if (_tmp2_) {
		self->priv->current_expr_is_lambda = FALSE;
	} else {
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp3_ = expr;
	_tmp4_ = begin;
	_tmp5_ = vala_genie_parser_get_src (self, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = vala_expression_statement_new (_tmp3_, _tmp6_);
	_tmp8_ = (ValaStatement*) _tmp7_;
	_vala_source_reference_unref0 (_tmp6_);
	result = _tmp8_;
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_statement_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr = NULL;
	ValaExpression* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaStatement* vala_genie_parser_parse_if_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* condition = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	ValaSourceReference* src = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaBlock* true_stmt = NULL;
	ValaBlock* _tmp5_ = NULL;
	ValaBlock* false_stmt = NULL;
	gboolean _tmp6_ = FALSE;
	ValaExpression* _tmp13_ = NULL;
	ValaBlock* _tmp14_ = NULL;
	ValaBlock* _tmp15_ = NULL;
	ValaSourceReference* _tmp16_ = NULL;
	ValaIfStatement* _tmp17_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_IF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	condition = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO);
	if (!_tmp2_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	}
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	src = _tmp4_;
	_tmp5_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	true_stmt = _tmp5_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	false_stmt = NULL;
	_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ELSE);
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp10_ = FALSE;
		ValaBlock* _tmp11_ = NULL;
		ValaBlock* _tmp12_ = NULL;
		_tmp8_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO);
		if (!_tmp8_) {
			ValaGenieTokenType _tmp9_ = 0;
			_tmp9_ = vala_genie_parser_current (self);
			_tmp7_ = _tmp9_ != VALA_GENIE_TOKEN_TYPE_IF;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp10_ = _tmp7_;
		if (_tmp10_) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (false_stmt);
					_vala_code_node_unref0 (true_stmt);
					_vala_source_reference_unref0 (src);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (false_stmt);
					_vala_code_node_unref0 (true_stmt);
					_vala_source_reference_unref0 (src);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		} else {
			vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		}
		_tmp12_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
		_tmp11_ = _tmp12_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (false_stmt);
		false_stmt = _tmp11_;
	}
	_tmp13_ = condition;
	_tmp14_ = true_stmt;
	_tmp15_ = false_stmt;
	_tmp16_ = src;
	_tmp17_ = vala_if_statement_new (_tmp13_, _tmp14_, _tmp15_, _tmp16_);
	result = (ValaStatement*) _tmp17_;
	_vala_code_node_unref0 (false_stmt);
	_vala_code_node_unref0 (true_stmt);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_genie_parser_parse_switch_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* condition = NULL;
	ValaExpression* _tmp1_ = NULL;
	ValaSwitchStatement* stmt = NULL;
	ValaExpression* _tmp2_ = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaSourceReference* _tmp5_ = NULL;
	ValaSwitchStatement* _tmp6_ = NULL;
	ValaSwitchStatement* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CASE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	condition = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = condition;
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_switch_statement_new (_tmp2_, _tmp5_);
	_tmp7_ = _tmp6_;
	_vala_source_reference_unref0 (_tmp5_);
	stmt = _tmp7_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaGenieTokenType _tmp8_ = 0;
		ValaSwitchSection* section = NULL;
		ValaSourceLocation _tmp9_ = {0};
		ValaSourceReference* _tmp10_ = NULL;
		ValaSourceReference* _tmp11_ = NULL;
		ValaSwitchSection* _tmp12_ = NULL;
		ValaSwitchSection* _tmp13_ = NULL;
		gboolean _tmp14_ = FALSE;
		gboolean _tmp33_ = FALSE;
		ValaSwitchSection* _tmp34_ = NULL;
		ValaBreakStatement* break_stmt = NULL;
		ValaSourceLocation _tmp35_ = {0};
		ValaSourceReference* _tmp36_ = NULL;
		ValaSourceReference* _tmp37_ = NULL;
		ValaBreakStatement* _tmp38_ = NULL;
		ValaBreakStatement* _tmp39_ = NULL;
		ValaSwitchSection* _tmp40_ = NULL;
		ValaBreakStatement* _tmp41_ = NULL;
		ValaSwitchStatement* _tmp42_ = NULL;
		ValaSwitchSection* _tmp43_ = NULL;
		_tmp8_ = vala_genie_parser_current (self);
		if (!(_tmp8_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
			break;
		}
		_tmp9_ = begin;
		_tmp10_ = vala_genie_parser_get_src (self, &_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = vala_switch_section_new (_tmp11_);
		_tmp13_ = _tmp12_;
		_vala_source_reference_unref0 (_tmp11_);
		section = _tmp13_;
		_tmp14_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WHEN);
		if (_tmp14_) {
			{
				gboolean _tmp15_ = FALSE;
				_tmp15_ = TRUE;
				while (TRUE) {
					gboolean _tmp16_ = FALSE;
					ValaExpression* _tmp18_ = NULL;
					ValaExpression* _tmp19_ = NULL;
					ValaSwitchSection* _tmp20_ = NULL;
					ValaExpression* _tmp21_ = NULL;
					ValaSourceLocation _tmp22_ = {0};
					ValaSourceReference* _tmp23_ = NULL;
					ValaSourceReference* _tmp24_ = NULL;
					ValaSwitchLabel* _tmp25_ = NULL;
					ValaSwitchLabel* _tmp26_ = NULL;
					_tmp16_ = _tmp15_;
					if (!_tmp16_) {
						gboolean _tmp17_ = FALSE;
						_tmp17_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp17_) {
							break;
						}
					}
					_tmp15_ = FALSE;
					_tmp19_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					_tmp18_ = _tmp19_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							return NULL;
						} else {
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp20_ = section;
					_tmp21_ = _tmp18_;
					_tmp22_ = begin;
					_tmp23_ = vala_genie_parser_get_src (self, &_tmp22_);
					_tmp24_ = _tmp23_;
					_tmp25_ = vala_switch_label_new (_tmp21_, _tmp24_);
					_tmp26_ = _tmp25_;
					vala_switch_section_add_label (_tmp20_, _tmp26_);
					_vala_code_node_unref0 (_tmp26_);
					_vala_source_reference_unref0 (_tmp24_);
					_vala_code_node_unref0 (_tmp21_);
				}
			}
		} else {
			ValaSwitchSection* _tmp27_ = NULL;
			ValaSourceLocation _tmp28_ = {0};
			ValaSourceReference* _tmp29_ = NULL;
			ValaSourceReference* _tmp30_ = NULL;
			ValaSwitchLabel* _tmp31_ = NULL;
			ValaSwitchLabel* _tmp32_ = NULL;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEFAULT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp27_ = section;
			_tmp28_ = begin;
			_tmp29_ = vala_genie_parser_get_src (self, &_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = vala_switch_label_new_with_default (_tmp30_);
			_tmp32_ = _tmp31_;
			vala_switch_section_add_label (_tmp27_, _tmp32_);
			_vala_code_node_unref0 (_tmp32_);
			_vala_source_reference_unref0 (_tmp30_);
		}
		_tmp33_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		if (!_tmp33_) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
		_tmp34_ = section;
		vala_genie_parser_parse_statements (self, (ValaBlock*) _tmp34_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp35_ = begin;
		_tmp36_ = vala_genie_parser_get_src (self, &_tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = vala_break_statement_new (_tmp37_);
		_tmp39_ = _tmp38_;
		_vala_source_reference_unref0 (_tmp37_);
		break_stmt = _tmp39_;
		_tmp40_ = section;
		_tmp41_ = break_stmt;
		vala_block_add_statement ((ValaBlock*) _tmp40_, (ValaStatement*) _tmp41_);
		_tmp42_ = stmt;
		_tmp43_ = section;
		vala_switch_statement_add_section (_tmp42_, _tmp43_);
		_vala_code_node_unref0 (break_stmt);
		_vala_code_node_unref0 (section);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaStatement*) stmt;
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_genie_parser_parse_while_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* condition = NULL;
	ValaExpression* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	ValaBlock* body = NULL;
	ValaBlock* _tmp3_ = NULL;
	ValaExpression* _tmp4_ = NULL;
	ValaBlock* _tmp5_ = NULL;
	ValaSourceLocation _tmp6_ = {0};
	ValaSourceReference* _tmp7_ = NULL;
	ValaSourceReference* _tmp8_ = NULL;
	ValaWhileStatement* _tmp9_ = NULL;
	ValaStatement* _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	condition = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO);
	if (!_tmp2_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	}
	_tmp3_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	body = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = condition;
	_tmp5_ = body;
	_tmp6_ = begin;
	_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = vala_while_statement_new (_tmp4_, _tmp5_, _tmp8_);
	_tmp10_ = (ValaStatement*) _tmp9_;
	_vala_source_reference_unref0 (_tmp8_);
	result = _tmp10_;
	_vala_code_node_unref0 (body);
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_genie_parser_parse_do_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaBlock* body = NULL;
	ValaBlock* _tmp1_ = NULL;
	ValaExpression* condition = NULL;
	ValaExpression* _tmp2_ = NULL;
	ValaBlock* _tmp3_ = NULL;
	ValaExpression* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaDoStatement* _tmp8_ = NULL;
	ValaStatement* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	body = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	condition = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = body;
	_tmp4_ = condition;
	_tmp5_ = begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_do_statement_new (_tmp3_, _tmp4_, _tmp7_);
	_tmp9_ = (ValaStatement*) _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	result = _tmp9_;
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (body);
	return result;
}


static ValaStatement* vala_genie_parser_parse_for_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaBlock* block = NULL;
	ValaExpression* initializer = NULL;
	ValaExpression* condition = NULL;
	ValaExpression* iterator = NULL;
	gboolean is_expr = FALSE;
	gchar* id = NULL;
	ValaGenieTokenType _tmp1_ = 0;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp35_ = FALSE;
	gboolean _tmp64_ = FALSE;
	ValaSourceReference* src = NULL;
	ValaSourceLocation _tmp65_ = {0};
	ValaSourceReference* _tmp66_ = NULL;
	ValaBlock* body = NULL;
	ValaBlock* _tmp67_ = NULL;
	ValaForStatement* stmt = NULL;
	ValaExpression* _tmp68_ = NULL;
	ValaBlock* _tmp69_ = NULL;
	ValaSourceReference* _tmp70_ = NULL;
	ValaForStatement* _tmp71_ = NULL;
	ValaExpression* _tmp72_ = NULL;
	ValaForStatement* _tmp75_ = NULL;
	ValaExpression* _tmp76_ = NULL;
	ValaBlock* _tmp77_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	block = NULL;
	initializer = NULL;
	condition = NULL;
	iterator = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FOR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_current (self);
	switch (_tmp1_) {
		case VALA_GENIE_TOKEN_TYPE_VAR:
		{
			is_expr = FALSE;
			break;
		}
		default:
		{
			gboolean local_is_expr = FALSE;
			gboolean _tmp2_ = FALSE;
			gboolean _tmp3_ = FALSE;
			_tmp2_ = vala_genie_parser_is_expression (self, &_inner_error_);
			local_is_expr = _tmp2_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp3_ = local_is_expr;
			is_expr = _tmp3_;
			break;
		}
	}
	_tmp4_ = is_expr;
	if (_tmp4_) {
		ValaSourceLocation expr_begin = {0};
		ValaSourceLocation _tmp5_ = {0};
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		ValaSourceLocation _tmp8_ = {0};
		ValaExpression* _tmp9_ = NULL;
		ValaExpression* _tmp10_ = NULL;
		vala_genie_parser_get_location (self, &_tmp5_);
		expr_begin = _tmp5_;
		_tmp7_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		_tmp6_ = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_g_free0 (id);
		id = _tmp6_;
		_tmp8_ = expr_begin;
		vala_genie_parser_rollback (self, &_tmp8_);
		_tmp10_ = vala_genie_parser_parse_statement_expression (self, &_inner_error_);
		_tmp9_ = _tmp10_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (initializer);
		initializer = _tmp9_;
	} else {
		ValaSourceLocation _tmp11_ = {0};
		ValaSourceReference* _tmp12_ = NULL;
		ValaSourceReference* _tmp13_ = NULL;
		ValaBlock* _tmp14_ = NULL;
		ValaDataType* variable_type = NULL;
		gboolean _tmp15_ = FALSE;
		ValaDataType* type_copy = NULL;
		ValaDataType* _tmp22_ = NULL;
		ValaLocalVariable* local = NULL;
		ValaDataType* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		ValaLocalVariable* _tmp27_ = NULL;
		ValaBlock* _tmp28_ = NULL;
		ValaLocalVariable* _tmp29_ = NULL;
		ValaLocalVariable* _tmp30_ = NULL;
		ValaSourceReference* _tmp31_ = NULL;
		ValaSourceReference* _tmp32_ = NULL;
		ValaDeclarationStatement* _tmp33_ = NULL;
		ValaDeclarationStatement* _tmp34_ = NULL;
		_tmp11_ = begin;
		_tmp12_ = vala_genie_parser_get_src (self, &_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = vala_block_new (_tmp13_);
		_vala_code_node_unref0 (block);
		block = _tmp14_;
		_vala_source_reference_unref0 (_tmp13_);
		_tmp15_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR);
		if (_tmp15_) {
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			_vala_code_node_unref0 (variable_type);
			variable_type = NULL;
			_tmp17_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			_tmp16_ = _tmp17_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_g_free0 (id);
			id = _tmp16_;
		} else {
			gchar* _tmp18_ = NULL;
			gchar* _tmp19_ = NULL;
			ValaDataType* _tmp20_ = NULL;
			ValaDataType* _tmp21_ = NULL;
			_tmp19_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			_tmp18_ = _tmp19_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_g_free0 (id);
			id = _tmp18_;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp21_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			_tmp20_ = _tmp21_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (variable_type);
			variable_type = _tmp20_;
		}
		type_copy = NULL;
		_tmp22_ = variable_type;
		if (_tmp22_ != NULL) {
			ValaDataType* _tmp23_ = NULL;
			ValaDataType* _tmp24_ = NULL;
			_tmp23_ = variable_type;
			_tmp24_ = vala_data_type_copy (_tmp23_);
			_vala_code_node_unref0 (type_copy);
			type_copy = _tmp24_;
		}
		_tmp25_ = type_copy;
		_tmp26_ = id;
		_tmp27_ = vala_genie_parser_parse_local_variable (self, _tmp25_, _tmp26_, &_inner_error_);
		local = _tmp27_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type_copy);
				_vala_code_node_unref0 (variable_type);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (type_copy);
				_vala_code_node_unref0 (variable_type);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp28_ = block;
		_tmp29_ = local;
		_tmp30_ = local;
		_tmp31_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = vala_declaration_statement_new ((ValaSymbol*) _tmp29_, _tmp32_);
		_tmp34_ = _tmp33_;
		vala_block_add_statement (_tmp28_, (ValaStatement*) _tmp34_);
		_vala_code_node_unref0 (_tmp34_);
		_vala_code_node_unref0 (local);
		_vala_code_node_unref0 (type_copy);
		_vala_code_node_unref0 (variable_type);
	}
	_tmp35_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_TO);
	if (_tmp35_) {
		ValaSourceLocation to_begin = {0};
		ValaSourceLocation _tmp36_ = {0};
		ValaSourceReference* to_src = NULL;
		ValaSourceLocation _tmp37_ = {0};
		ValaSourceReference* _tmp38_ = NULL;
		ValaMemberAccess* left = NULL;
		const gchar* _tmp39_ = NULL;
		ValaSourceReference* _tmp40_ = NULL;
		ValaMemberAccess* _tmp41_ = NULL;
		ValaExpression* right = NULL;
		ValaExpression* _tmp42_ = NULL;
		ValaMemberAccess* _tmp43_ = NULL;
		ValaExpression* _tmp44_ = NULL;
		ValaSourceReference* _tmp45_ = NULL;
		ValaBinaryExpression* _tmp46_ = NULL;
		ValaMemberAccess* _tmp47_ = NULL;
		ValaSourceReference* _tmp48_ = NULL;
		ValaPostfixExpression* _tmp49_ = NULL;
		vala_genie_parser_get_location (self, &_tmp36_);
		to_begin = _tmp36_;
		_tmp37_ = to_begin;
		_tmp38_ = vala_genie_parser_get_src (self, &_tmp37_);
		to_src = _tmp38_;
		_tmp39_ = id;
		_tmp40_ = to_src;
		_tmp41_ = vala_member_access_new (NULL, _tmp39_, _tmp40_);
		left = _tmp41_;
		_tmp42_ = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
		right = _tmp42_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (to_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (to_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp43_ = left;
		_tmp44_ = right;
		_tmp45_ = to_src;
		_tmp46_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL, (ValaExpression*) _tmp43_, _tmp44_, _tmp45_);
		_vala_code_node_unref0 (condition);
		condition = (ValaExpression*) _tmp46_;
		_tmp47_ = left;
		_tmp48_ = to_src;
		_tmp49_ = vala_postfix_expression_new ((ValaExpression*) _tmp47_, TRUE, _tmp48_);
		_vala_code_node_unref0 (iterator);
		iterator = (ValaExpression*) _tmp49_;
		_vala_code_node_unref0 (right);
		_vala_code_node_unref0 (left);
		_vala_source_reference_unref0 (to_src);
	} else {
		ValaSourceLocation downto_begin = {0};
		ValaSourceLocation _tmp50_ = {0};
		ValaSourceReference* downto_src = NULL;
		ValaSourceLocation _tmp51_ = {0};
		ValaSourceReference* _tmp52_ = NULL;
		ValaMemberAccess* left = NULL;
		const gchar* _tmp53_ = NULL;
		ValaSourceReference* _tmp54_ = NULL;
		ValaMemberAccess* _tmp55_ = NULL;
		ValaExpression* right = NULL;
		ValaExpression* _tmp56_ = NULL;
		ValaMemberAccess* _tmp57_ = NULL;
		ValaExpression* _tmp58_ = NULL;
		ValaSourceReference* _tmp59_ = NULL;
		ValaBinaryExpression* _tmp60_ = NULL;
		ValaMemberAccess* _tmp61_ = NULL;
		ValaSourceReference* _tmp62_ = NULL;
		ValaPostfixExpression* _tmp63_ = NULL;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DOWNTO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_get_location (self, &_tmp50_);
		downto_begin = _tmp50_;
		_tmp51_ = downto_begin;
		_tmp52_ = vala_genie_parser_get_src (self, &_tmp51_);
		downto_src = _tmp52_;
		_tmp53_ = id;
		_tmp54_ = downto_src;
		_tmp55_ = vala_member_access_new (NULL, _tmp53_, _tmp54_);
		left = _tmp55_;
		_tmp56_ = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
		right = _tmp56_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (downto_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (downto_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp57_ = left;
		_tmp58_ = right;
		_tmp59_ = downto_src;
		_tmp60_ = vala_binary_expression_new (VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL, (ValaExpression*) _tmp57_, _tmp58_, _tmp59_);
		_vala_code_node_unref0 (condition);
		condition = (ValaExpression*) _tmp60_;
		_tmp61_ = left;
		_tmp62_ = downto_src;
		_tmp63_ = vala_postfix_expression_new ((ValaExpression*) _tmp61_, FALSE, _tmp62_);
		_vala_code_node_unref0 (iterator);
		iterator = (ValaExpression*) _tmp63_;
		_vala_code_node_unref0 (right);
		_vala_code_node_unref0 (left);
		_vala_source_reference_unref0 (downto_src);
	}
	_tmp64_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	if (!_tmp64_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp65_ = begin;
	_tmp66_ = vala_genie_parser_get_src (self, &_tmp65_);
	src = _tmp66_;
	_tmp67_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	body = _tmp67_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp68_ = condition;
	_tmp69_ = body;
	_tmp70_ = src;
	_tmp71_ = vala_for_statement_new (_tmp68_, _tmp69_, _tmp70_);
	stmt = _tmp71_;
	_tmp72_ = initializer;
	if (_tmp72_ != NULL) {
		ValaForStatement* _tmp73_ = NULL;
		ValaExpression* _tmp74_ = NULL;
		_tmp73_ = stmt;
		_tmp74_ = initializer;
		vala_for_statement_add_initializer (_tmp73_, _tmp74_);
	}
	_tmp75_ = stmt;
	_tmp76_ = iterator;
	vala_for_statement_add_iterator (_tmp75_, _tmp76_);
	_tmp77_ = block;
	if (_tmp77_ != NULL) {
		ValaBlock* _tmp78_ = NULL;
		ValaForStatement* _tmp79_ = NULL;
		_tmp78_ = block;
		_tmp79_ = stmt;
		vala_block_add_statement (_tmp78_, (ValaStatement*) _tmp79_);
		result = (ValaStatement*) block;
		_vala_code_node_unref0 (stmt);
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_g_free0 (id);
		_vala_code_node_unref0 (iterator);
		_vala_code_node_unref0 (condition);
		_vala_code_node_unref0 (initializer);
		return result;
	} else {
		result = (ValaStatement*) stmt;
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_g_free0 (id);
		_vala_code_node_unref0 (iterator);
		_vala_code_node_unref0 (condition);
		_vala_code_node_unref0 (initializer);
		_vala_code_node_unref0 (block);
		return result;
	}
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_g_free0 (id);
	_vala_code_node_unref0 (iterator);
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (block);
}


static ValaStatement* vala_genie_parser_parse_foreach_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	gchar* id = NULL;
	gboolean _tmp1_ = FALSE;
	ValaExpression* collection = NULL;
	ValaExpression* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	ValaSourceReference* src = NULL;
	ValaSourceLocation _tmp11_ = {0};
	ValaSourceReference* _tmp12_ = NULL;
	ValaBlock* body = NULL;
	ValaBlock* _tmp13_ = NULL;
	ValaDataType* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	ValaExpression* _tmp16_ = NULL;
	ValaBlock* _tmp17_ = NULL;
	ValaSourceReference* _tmp18_ = NULL;
	ValaForeachStatement* _tmp19_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	type = NULL;
	id = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FOR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR);
	if (_tmp1_) {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		_tmp3_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_g_free0 (id);
		id = _tmp2_;
	} else {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		_tmp5_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		_tmp4_ = _tmp5_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_g_free0 (id);
		id = _tmp4_;
		_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
		if (_tmp6_) {
			ValaDataType* _tmp7_ = NULL;
			ValaDataType* _tmp8_ = NULL;
			_tmp8_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			_tmp7_ = _tmp8_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (type);
			type = _tmp7_;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_IN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	collection = _tmp9_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp10_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	if (!_tmp10_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (collection);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (collection);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp11_ = begin;
	_tmp12_ = vala_genie_parser_get_src (self, &_tmp11_);
	src = _tmp12_;
	_tmp13_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	body = _tmp13_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp14_ = type;
	_tmp15_ = id;
	_tmp16_ = collection;
	_tmp17_ = body;
	_tmp18_ = src;
	_tmp19_ = vala_foreach_statement_new (_tmp14_, _tmp15_, _tmp16_, _tmp17_, _tmp18_);
	result = (ValaStatement*) _tmp19_;
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (collection);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaStatement* vala_genie_parser_parse_break_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaBreakStatement* _tmp4_ = NULL;
	ValaStatement* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_BREAK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_break_statement_new (_tmp3_);
	_tmp5_ = (ValaStatement*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaStatement* vala_genie_parser_parse_continue_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaContinueStatement* _tmp4_ = NULL;
	ValaStatement* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONTINUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_continue_statement_new (_tmp3_);
	_tmp5_ = (ValaStatement*) _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	result = _tmp5_;
	return result;
}


static ValaStatement* vala_genie_parser_parse_return_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	gboolean _tmp1_ = FALSE;
	ValaGenieTokenType _tmp2_ = 0;
	gboolean _tmp4_ = FALSE;
	ValaExpression* _tmp7_ = NULL;
	ValaSourceLocation _tmp8_ = {0};
	ValaSourceReference* _tmp9_ = NULL;
	ValaSourceReference* _tmp10_ = NULL;
	ValaReturnStatement* _tmp11_ = NULL;
	ValaStatement* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_RETURN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = NULL;
	_tmp2_ = vala_genie_parser_current (self);
	if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		ValaGenieTokenType _tmp3_ = 0;
		_tmp3_ = vala_genie_parser_current (self);
		_tmp1_ = _tmp3_ != VALA_GENIE_TOKEN_TYPE_EOL;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		ValaExpression* _tmp5_ = NULL;
		ValaExpression* _tmp6_ = NULL;
		_tmp6_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp5_ = _tmp6_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (expr);
		expr = _tmp5_;
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp7_ = expr;
	_tmp8_ = begin;
	_tmp9_ = vala_genie_parser_get_src (self, &_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = vala_return_statement_new (_tmp7_, _tmp10_);
	_tmp12_ = (ValaStatement*) _tmp11_;
	_vala_source_reference_unref0 (_tmp10_);
	result = _tmp12_;
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaStatement* vala_genie_parser_parse_yield_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	ValaGenieTokenType _tmp3_ = 0;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp7_ = FALSE;
	ValaExpression* expr = NULL;
	gboolean _tmp10_ = FALSE;
	ValaExpression* _tmp13_ = NULL;
	ValaSourceLocation _tmp14_ = {0};
	ValaSourceReference* _tmp15_ = NULL;
	ValaSourceReference* _tmp16_ = NULL;
	ValaYieldStatement* _tmp17_ = NULL;
	ValaStatement* _tmp18_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_current (self);
	if (_tmp3_ != VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		ValaGenieTokenType _tmp4_ = 0;
		_tmp4_ = vala_genie_parser_current (self);
		_tmp2_ = _tmp4_ != VALA_GENIE_TOKEN_TYPE_EOL;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp5_ = _tmp2_;
	if (_tmp5_) {
		ValaGenieTokenType _tmp6_ = 0;
		_tmp6_ = vala_genie_parser_current (self);
		_tmp1_ = _tmp6_ != VALA_GENIE_TOKEN_TYPE_RETURN;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp7_ = _tmp1_;
	if (_tmp7_) {
		ValaStatement* _tmp8_ = NULL;
		ValaStatement* _tmp9_ = NULL;
		vala_genie_parser_prev (self);
		_tmp9_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
		_tmp8_ = _tmp9_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp8_;
		return result;
	}
	expr = NULL;
	_tmp10_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RETURN);
	if (_tmp10_) {
		ValaExpression* _tmp11_ = NULL;
		ValaExpression* _tmp12_ = NULL;
		_tmp12_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp11_ = _tmp12_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (expr);
		expr = _tmp11_;
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = expr;
	_tmp14_ = begin;
	_tmp15_ = vala_genie_parser_get_src (self, &_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = vala_yield_statement_new (_tmp13_, _tmp16_);
	_tmp18_ = (ValaStatement*) _tmp17_;
	_vala_source_reference_unref0 (_tmp16_);
	result = _tmp18_;
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaStatement* vala_genie_parser_parse_throw_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	ValaExpression* _tmp1_ = NULL;
	ValaExpression* _tmp2_ = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaSourceReference* _tmp5_ = NULL;
	ValaThrowStatement* _tmp6_ = NULL;
	ValaStatement* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_RAISE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = expr;
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_throw_statement_new (_tmp2_, _tmp5_);
	_tmp7_ = (ValaStatement*) _tmp6_;
	_vala_source_reference_unref0 (_tmp5_);
	result = _tmp7_;
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaStatement* vala_genie_parser_parse_try_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaBlock* try_block = NULL;
	ValaBlock* _tmp1_ = NULL;
	ValaBlock* finally_clause = NULL;
	ValaArrayList* catch_clauses = NULL;
	GEqualFunc _tmp2_ = NULL;
	ValaArrayList* _tmp3_ = NULL;
	ValaGenieTokenType _tmp4_ = 0;
	ValaTryStatement* stmt = NULL;
	ValaBlock* _tmp11_ = NULL;
	ValaBlock* _tmp12_ = NULL;
	ValaSourceLocation _tmp13_ = {0};
	ValaSourceReference* _tmp14_ = NULL;
	ValaSourceReference* _tmp15_ = NULL;
	ValaTryStatement* _tmp16_ = NULL;
	ValaTryStatement* _tmp17_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_TRY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_block (self, &_inner_error_);
	try_block = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	finally_clause = NULL;
	_tmp2_ = g_direct_equal;
	_tmp3_ = vala_array_list_new (VALA_TYPE_CATCH_CLAUSE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp2_);
	catch_clauses = _tmp3_;
	_tmp4_ = vala_genie_parser_current (self);
	if (_tmp4_ == VALA_GENIE_TOKEN_TYPE_EXCEPT) {
		ValaArrayList* _tmp5_ = NULL;
		ValaGenieTokenType _tmp6_ = 0;
		_tmp5_ = catch_clauses;
		vala_genie_parser_parse_catch_clauses (self, (ValaList*) _tmp5_, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_iterable_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp6_ = vala_genie_parser_current (self);
		if (_tmp6_ == VALA_GENIE_TOKEN_TYPE_FINALLY) {
			ValaBlock* _tmp7_ = NULL;
			ValaBlock* _tmp8_ = NULL;
			_tmp8_ = vala_genie_parser_parse_finally_clause (self, &_inner_error_);
			_tmp7_ = _tmp8_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					return NULL;
				} else {
					_vala_iterable_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (finally_clause);
			finally_clause = _tmp7_;
		}
	} else {
		ValaBlock* _tmp9_ = NULL;
		ValaBlock* _tmp10_ = NULL;
		_tmp10_ = vala_genie_parser_parse_finally_clause (self, &_inner_error_);
		_tmp9_ = _tmp10_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_iterable_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (finally_clause);
		finally_clause = _tmp9_;
	}
	_tmp11_ = try_block;
	_tmp12_ = finally_clause;
	_tmp13_ = begin;
	_tmp14_ = vala_genie_parser_get_src (self, &_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = vala_try_statement_new (_tmp11_, _tmp12_, _tmp15_);
	_tmp17_ = _tmp16_;
	_vala_source_reference_unref0 (_tmp15_);
	stmt = _tmp17_;
	{
		ValaArrayList* _clause_list = NULL;
		ValaArrayList* _tmp18_ = NULL;
		ValaArrayList* _tmp19_ = NULL;
		gint _clause_size = 0;
		ValaArrayList* _tmp20_ = NULL;
		gint _tmp21_ = 0;
		gint _tmp22_ = 0;
		gint _clause_index = 0;
		_tmp18_ = catch_clauses;
		_tmp19_ = _vala_iterable_ref0 (_tmp18_);
		_clause_list = _tmp19_;
		_tmp20_ = _clause_list;
		_tmp21_ = vala_collection_get_size ((ValaCollection*) _tmp20_);
		_tmp22_ = _tmp21_;
		_clause_size = _tmp22_;
		_clause_index = -1;
		while (TRUE) {
			gint _tmp23_ = 0;
			gint _tmp24_ = 0;
			gint _tmp25_ = 0;
			ValaCatchClause* clause = NULL;
			ValaArrayList* _tmp26_ = NULL;
			gint _tmp27_ = 0;
			gpointer _tmp28_ = NULL;
			ValaTryStatement* _tmp29_ = NULL;
			ValaCatchClause* _tmp30_ = NULL;
			_tmp23_ = _clause_index;
			_clause_index = _tmp23_ + 1;
			_tmp24_ = _clause_index;
			_tmp25_ = _clause_size;
			if (!(_tmp24_ < _tmp25_)) {
				break;
			}
			_tmp26_ = _clause_list;
			_tmp27_ = _clause_index;
			_tmp28_ = vala_list_get ((ValaList*) _tmp26_, _tmp27_);
			clause = (ValaCatchClause*) _tmp28_;
			_tmp29_ = stmt;
			_tmp30_ = clause;
			vala_try_statement_add_catch_clause (_tmp29_, _tmp30_);
			_vala_code_node_unref0 (clause);
		}
		_vala_iterable_unref0 (_clause_list);
	}
	result = (ValaStatement*) stmt;
	_vala_iterable_unref0 (catch_clauses);
	_vala_code_node_unref0 (finally_clause);
	_vala_code_node_unref0 (try_block);
	return result;
}


static void vala_genie_parser_parse_catch_clauses (ValaGenieParser* self, ValaList* catch_clauses, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (catch_clauses != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		ValaSourceLocation begin = {0};
		ValaSourceLocation _tmp1_ = {0};
		ValaDataType* type = NULL;
		gchar* id = NULL;
		gboolean _tmp2_ = FALSE;
		ValaBlock* block = NULL;
		ValaBlock* _tmp7_ = NULL;
		ValaList* _tmp8_ = NULL;
		ValaDataType* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		ValaBlock* _tmp11_ = NULL;
		ValaSourceLocation _tmp12_ = {0};
		ValaSourceReference* _tmp13_ = NULL;
		ValaSourceReference* _tmp14_ = NULL;
		ValaCatchClause* _tmp15_ = NULL;
		ValaCatchClause* _tmp16_ = NULL;
		_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EXCEPT);
		if (!_tmp0_) {
			break;
		}
		vala_genie_parser_get_location (self, &_tmp1_);
		begin = _tmp1_;
		type = NULL;
		id = NULL;
		_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		if (!_tmp2_) {
			gchar* _tmp3_ = NULL;
			gchar* _tmp4_ = NULL;
			ValaDataType* _tmp5_ = NULL;
			ValaDataType* _tmp6_ = NULL;
			_tmp4_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			_tmp3_ = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_g_free0 (id);
			id = _tmp3_;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp6_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			_tmp5_ = _tmp6_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_vala_code_node_unref0 (type);
			type = _tmp5_;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		_tmp7_ = vala_genie_parser_parse_block (self, &_inner_error_);
		block = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		_tmp8_ = catch_clauses;
		_tmp9_ = type;
		_tmp10_ = id;
		_tmp11_ = block;
		_tmp12_ = begin;
		_tmp13_ = vala_genie_parser_get_src (self, &_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = vala_catch_clause_new (_tmp9_, _tmp10_, _tmp11_, _tmp14_);
		_tmp16_ = _tmp15_;
		vala_collection_add ((ValaCollection*) _tmp8_, _tmp16_);
		_vala_code_node_unref0 (_tmp16_);
		_vala_source_reference_unref0 (_tmp14_);
		_vala_code_node_unref0 (block);
		_g_free0 (id);
		_vala_code_node_unref0 (type);
	}
}


static ValaBlock* vala_genie_parser_parse_finally_clause (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaBlock* block = NULL;
	ValaBlock* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FINALLY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_accept_block (self);
	_tmp0_ = vala_genie_parser_parse_block (self, &_inner_error_);
	block = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_lock_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	ValaExpression* _tmp1_ = NULL;
	ValaBlock* stmt = NULL;
	ValaBlock* _tmp2_ = NULL;
	ValaExpression* _tmp3_ = NULL;
	ValaBlock* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaLockStatement* _tmp8_ = NULL;
	ValaStatement* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_LOCK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	stmt = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = expr;
	_tmp4_ = stmt;
	_tmp5_ = begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_lock_statement_new (_tmp3_, _tmp4_, _tmp7_);
	_tmp9_ = (ValaStatement*) _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	result = _tmp9_;
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaStatement* vala_genie_parser_parse_delete_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaExpression* expr = NULL;
	ValaExpression* _tmp1_ = NULL;
	ValaExpression* _tmp2_ = NULL;
	ValaSourceLocation _tmp3_ = {0};
	ValaSourceReference* _tmp4_ = NULL;
	ValaSourceReference* _tmp5_ = NULL;
	ValaDeleteStatement* _tmp6_ = NULL;
	ValaStatement* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DELETE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
	expr = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = expr;
	_tmp3_ = begin;
	_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = vala_delete_statement_new (_tmp2_, _tmp5_);
	_tmp7_ = (ValaStatement*) _tmp6_;
	_vala_source_reference_unref0 (_tmp5_);
	result = _tmp7_;
	_vala_code_node_unref0 (expr);
	return result;
}


static gchar* vala_genie_parser_parse_attribute_value (ValaGenieParser* self, GError** error) {
	gchar* result = NULL;
	ValaGenieTokenType _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_current (self);
	switch (_tmp0_) {
		case VALA_GENIE_TOKEN_TYPE_NULL:
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
		{
			gchar* _tmp1_ = NULL;
			vala_genie_parser_next (self);
			_tmp1_ = vala_genie_parser_get_last_string (self);
			result = _tmp1_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_MINUS:
		{
			ValaGenieTokenType _tmp2_ = 0;
			vala_genie_parser_next (self);
			_tmp2_ = vala_genie_parser_current (self);
			switch (_tmp2_) {
				case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
				case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
				{
					gchar* _tmp3_ = NULL;
					gchar* _tmp4_ = NULL;
					gchar* _tmp5_ = NULL;
					gchar* _tmp6_ = NULL;
					vala_genie_parser_next (self);
					_tmp3_ = vala_genie_parser_get_last_string (self);
					_tmp4_ = _tmp3_;
					_tmp5_ = g_strconcat ("-", _tmp4_, NULL);
					_tmp6_ = _tmp5_;
					_g_free0 (_tmp4_);
					result = _tmp6_;
					return result;
				}
				default:
				{
					gchar* _tmp7_ = NULL;
					gchar* _tmp8_ = NULL;
					GError* _tmp9_ = NULL;
					GError* _tmp10_ = NULL;
					_tmp7_ = vala_genie_parser_get_error (self, "expected number");
					_tmp8_ = _tmp7_;
					_tmp9_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp8_);
					_tmp10_ = _tmp9_;
					_g_free0 (_tmp8_);
					_inner_error_ = _tmp10_;
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return NULL;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
		default:
		{
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			GError* _tmp13_ = NULL;
			GError* _tmp14_ = NULL;
			_tmp11_ = vala_genie_parser_get_error (self, "expected literal");
			_tmp12_ = _tmp11_;
			_tmp13_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp12_);
			_tmp14_ = _tmp13_;
			_g_free0 (_tmp12_);
			_inner_error_ = _tmp14_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
}


static ValaList* vala_genie_parser_parse_attributes (ValaGenieParser* self, gboolean parameter, GError** error) {
	ValaList* result = NULL;
	ValaGenieTokenType _tmp0_ = 0;
	ValaArrayList* attrs = NULL;
	GEqualFunc _tmp1_ = NULL;
	ValaArrayList* _tmp2_ = NULL;
	gboolean _tmp29_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_current (self);
	if (_tmp0_ != VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET) {
		result = NULL;
		return result;
	}
	_tmp1_ = g_direct_equal;
	_tmp2_ = vala_array_list_new (VALA_TYPE_ATTRIBUTE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp1_);
	attrs = _tmp2_;
	while (TRUE) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
		if (!_tmp3_) {
			break;
		}
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_ = FALSE;
				ValaSourceLocation begin = {0};
				ValaSourceLocation _tmp7_ = {0};
				gchar* id = NULL;
				gchar* _tmp8_ = NULL;
				ValaAttribute* attr = NULL;
				const gchar* _tmp9_ = NULL;
				ValaSourceLocation _tmp10_ = {0};
				ValaSourceReference* _tmp11_ = NULL;
				ValaSourceReference* _tmp12_ = NULL;
				ValaAttribute* _tmp13_ = NULL;
				ValaAttribute* _tmp14_ = NULL;
				gboolean _tmp15_ = FALSE;
				ValaArrayList* _tmp27_ = NULL;
				ValaAttribute* _tmp28_ = NULL;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gboolean _tmp6_ = FALSE;
					_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp6_) {
						break;
					}
				}
				_tmp4_ = FALSE;
				vala_genie_parser_get_location (self, &_tmp7_);
				begin = _tmp7_;
				_tmp8_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
				id = _tmp8_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (attrs);
						return NULL;
					} else {
						_vala_iterable_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp9_ = id;
				_tmp10_ = begin;
				_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = vala_attribute_new (_tmp9_, _tmp12_);
				_tmp14_ = _tmp13_;
				_vala_source_reference_unref0 (_tmp12_);
				attr = _tmp14_;
				_tmp15_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
				if (_tmp15_) {
					ValaGenieTokenType _tmp16_ = 0;
					_tmp16_ = vala_genie_parser_current (self);
					if (_tmp16_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
						{
							gboolean _tmp17_ = FALSE;
							_tmp17_ = TRUE;
							while (TRUE) {
								gboolean _tmp18_ = FALSE;
								gchar* _tmp20_ = NULL;
								gchar* _tmp21_ = NULL;
								gchar* _tmp22_ = NULL;
								gchar* _tmp23_ = NULL;
								ValaAttribute* _tmp24_ = NULL;
								const gchar* _tmp25_ = NULL;
								gchar* _tmp26_ = NULL;
								_tmp18_ = _tmp17_;
								if (!_tmp18_) {
									gboolean _tmp19_ = FALSE;
									_tmp19_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
									if (!_tmp19_) {
										break;
									}
								}
								_tmp17_ = FALSE;
								_tmp21_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
								_tmp20_ = _tmp21_;
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								_g_free0 (id);
								id = _tmp20_;
								vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								_tmp23_ = vala_genie_parser_parse_attribute_value (self, &_inner_error_);
								_tmp22_ = _tmp23_;
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_iterable_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								_tmp24_ = attr;
								_tmp25_ = id;
								_tmp26_ = _tmp22_;
								vala_attribute_add_argument (_tmp24_, _tmp25_, _tmp26_);
								_g_free0 (_tmp26_);
							}
						}
					}
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_iterable_unref0 (attrs);
							return NULL;
						} else {
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_iterable_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				_tmp27_ = attrs;
				_tmp28_ = attr;
				vala_collection_add ((ValaCollection*) _tmp27_, _tmp28_);
				_vala_code_node_unref0 (attr);
				_g_free0 (id);
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (attrs);
				return NULL;
			} else {
				_vala_iterable_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp29_ = parameter;
	if (!_tmp29_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (attrs);
				return NULL;
			} else {
				_vala_iterable_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) attrs;
	return result;
}


static void vala_genie_parser_set_attributes (ValaGenieParser* self, ValaCodeNode* node, ValaList* attributes) {
	ValaList* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = attributes;
	if (_tmp0_ != NULL) {
		{
			ValaList* _attr_list = NULL;
			ValaList* _tmp1_ = NULL;
			ValaList* _tmp2_ = NULL;
			gint _attr_size = 0;
			ValaList* _tmp3_ = NULL;
			gint _tmp4_ = 0;
			gint _tmp5_ = 0;
			gint _attr_index = 0;
			_tmp1_ = attributes;
			_tmp2_ = _vala_iterable_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, VALA_TYPE_LIST, ValaList));
			_attr_list = _tmp2_;
			_tmp3_ = _attr_list;
			_tmp4_ = vala_collection_get_size ((ValaCollection*) _tmp3_);
			_tmp5_ = _tmp4_;
			_attr_size = _tmp5_;
			_attr_index = -1;
			while (TRUE) {
				gint _tmp6_ = 0;
				gint _tmp7_ = 0;
				gint _tmp8_ = 0;
				ValaAttribute* attr = NULL;
				ValaList* _tmp9_ = NULL;
				gint _tmp10_ = 0;
				gpointer _tmp11_ = NULL;
				ValaCodeNode* _tmp12_ = NULL;
				ValaAttribute* _tmp13_ = NULL;
				const gchar* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				ValaAttribute* _tmp16_ = NULL;
				ValaAttribute* _tmp17_ = NULL;
				gboolean _tmp18_ = FALSE;
				ValaCodeNode* _tmp27_ = NULL;
				ValaAttribute* _tmp28_ = NULL;
				ValaAttribute* _tmp29_ = NULL;
				_tmp6_ = _attr_index;
				_attr_index = _tmp6_ + 1;
				_tmp7_ = _attr_index;
				_tmp8_ = _attr_size;
				if (!(_tmp7_ < _tmp8_)) {
					break;
				}
				_tmp9_ = _attr_list;
				_tmp10_ = _attr_index;
				_tmp11_ = vala_list_get (_tmp9_, _tmp10_);
				attr = (ValaAttribute*) _tmp11_;
				_tmp12_ = node;
				_tmp13_ = attr;
				_tmp14_ = vala_attribute_get_name (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = vala_code_node_get_attribute (_tmp12_, _tmp15_);
				_tmp17_ = _tmp16_;
				_tmp18_ = _tmp17_ != NULL;
				_vala_code_node_unref0 (_tmp17_);
				if (_tmp18_) {
					ValaAttribute* _tmp19_ = NULL;
					ValaSourceReference* _tmp20_ = NULL;
					ValaSourceReference* _tmp21_ = NULL;
					ValaAttribute* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					const gchar* _tmp24_ = NULL;
					gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					_tmp19_ = attr;
					_tmp20_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp19_);
					_tmp21_ = _tmp20_;
					_tmp22_ = attr;
					_tmp23_ = vala_attribute_get_name (_tmp22_);
					_tmp24_ = _tmp23_;
					_tmp25_ = g_strdup_printf ("duplicate attribute `%s`", _tmp24_);
					_tmp26_ = _tmp25_;
					vala_report_error (_tmp21_, _tmp26_);
					_g_free0 (_tmp26_);
				}
				_tmp27_ = node;
				_tmp28_ = attr;
				_tmp29_ = _vala_code_node_ref0 (_tmp28_);
				_tmp27_->attributes = g_list_append (_tmp27_->attributes, _tmp29_);
				_vala_code_node_unref0 (attr);
			}
			_vala_iterable_unref0 (_attr_list);
		}
	}
}


static ValaSymbol* vala_genie_parser_parse_declaration (ValaGenieParser* self, gboolean is_root, GError** error) {
	ValaSymbol* result = NULL;
	ValaGenieScanner* _tmp0_ = NULL;
	ValaComment* _tmp1_ = NULL;
	ValaList* attrs = NULL;
	ValaList* _tmp2_ = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp3_ = {0};
	ValaGenieTokenType _tmp4_ = 0;
	ValaGenieTokenType cur = 0;
	ValaGenieTokenType _tmp65_ = 0;
	ValaGenieTokenType pre = 0;
	ValaGenieParserTokenInfo* _tmp66_ = NULL;
	gint _tmp66__length1 = 0;
	gint _tmp67_ = 0;
	ValaGenieParserTokenInfo _tmp68_ = {0};
	ValaGenieTokenType _tmp69_ = 0;
	ValaGenieTokenType _tmp70_ = 0;
	const gchar* _tmp71_ = NULL;
	ValaGenieTokenType _tmp72_ = 0;
	const gchar* _tmp73_ = NULL;
	gchar* _tmp74_ = NULL;
	gchar* _tmp75_ = NULL;
	gchar* _tmp76_ = NULL;
	gchar* _tmp77_ = NULL;
	GError* _tmp78_ = NULL;
	GError* _tmp79_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->scanner;
	_tmp1_ = vala_genie_scanner_pop_comment (_tmp0_);
	_vala_comment_unref0 (self->priv->comment);
	self->priv->comment = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_attributes (self, FALSE, &_inner_error_);
	attrs = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_get_location (self, &_tmp3_);
	begin = _tmp3_;
	_tmp4_ = vala_genie_parser_current (self);
	switch (_tmp4_) {
		case VALA_GENIE_TOKEN_TYPE_CONST:
		{
			ValaConstant* _tmp5_ = NULL;
			ValaList* _tmp6_ = NULL;
			ValaConstant* _tmp7_ = NULL;
			_tmp6_ = attrs;
			_tmp7_ = vala_genie_parser_parse_constant_declaration (self, _tmp6_, &_inner_error_);
			_tmp5_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp5_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CONSTRUCT:
		{
			ValaCreationMethod* _tmp8_ = NULL;
			ValaList* _tmp9_ = NULL;
			ValaCreationMethod* _tmp10_ = NULL;
			_tmp9_ = attrs;
			_tmp10_ = vala_genie_parser_parse_creation_method_declaration (self, _tmp9_, &_inner_error_);
			_tmp8_ = _tmp10_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp8_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CLASS:
		{
			ValaSymbol* _tmp11_ = NULL;
			ValaList* _tmp12_ = NULL;
			ValaSymbol* _tmp13_ = NULL;
			_tmp12_ = attrs;
			_tmp13_ = vala_genie_parser_parse_class_declaration (self, _tmp12_, &_inner_error_);
			_tmp11_ = _tmp13_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp11_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INIT:
		{
			gboolean _tmp14_ = FALSE;
			ValaSourceLocation _tmp18_ = {0};
			ValaConstructor* _tmp19_ = NULL;
			ValaList* _tmp20_ = NULL;
			ValaConstructor* _tmp21_ = NULL;
			_tmp14_ = is_root;
			if (_tmp14_) {
				ValaMethod* _tmp15_ = NULL;
				ValaList* _tmp16_ = NULL;
				ValaMethod* _tmp17_ = NULL;
				_tmp16_ = attrs;
				_tmp17_ = vala_genie_parser_parse_main_method_declaration (self, _tmp16_, &_inner_error_);
				_tmp15_ = _tmp17_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (attrs);
						return NULL;
					} else {
						_vala_iterable_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				result = (ValaSymbol*) _tmp15_;
				_vala_iterable_unref0 (attrs);
				return result;
			}
			_tmp18_ = begin;
			vala_genie_parser_rollback (self, &_tmp18_);
			_tmp20_ = attrs;
			_tmp21_ = vala_genie_parser_parse_constructor_declaration (self, _tmp20_, &_inner_error_);
			_tmp19_ = _tmp21_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp19_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DELEGATE:
		{
			ValaSymbol* _tmp22_ = NULL;
			ValaList* _tmp23_ = NULL;
			ValaSymbol* _tmp24_ = NULL;
			_tmp23_ = attrs;
			_tmp24_ = vala_genie_parser_parse_delegate_declaration (self, _tmp23_, &_inner_error_);
			_tmp22_ = _tmp24_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp22_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DEF:
		{
			ValaMethod* _tmp25_ = NULL;
			ValaList* _tmp26_ = NULL;
			ValaMethod* _tmp27_ = NULL;
			_tmp26_ = attrs;
			_tmp27_ = vala_genie_parser_parse_method_declaration (self, _tmp26_, &_inner_error_);
			_tmp25_ = _tmp27_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp25_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ENUM:
		{
			ValaSymbol* _tmp28_ = NULL;
			ValaList* _tmp29_ = NULL;
			ValaSymbol* _tmp30_ = NULL;
			_tmp29_ = attrs;
			_tmp30_ = vala_genie_parser_parse_enum_declaration (self, _tmp29_, &_inner_error_);
			_tmp28_ = _tmp30_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp28_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
		{
			ValaSymbol* _tmp31_ = NULL;
			ValaList* _tmp32_ = NULL;
			ValaSymbol* _tmp33_ = NULL;
			_tmp32_ = attrs;
			_tmp33_ = vala_genie_parser_parse_errordomain_declaration (self, _tmp32_, &_inner_error_);
			_tmp31_ = _tmp33_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp31_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FINAL:
		{
			ValaDestructor* _tmp34_ = NULL;
			ValaList* _tmp35_ = NULL;
			ValaDestructor* _tmp36_ = NULL;
			_tmp35_ = attrs;
			_tmp36_ = vala_genie_parser_parse_destructor_declaration (self, _tmp35_, &_inner_error_);
			_tmp34_ = _tmp36_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp34_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INTERFACE:
		{
			ValaSymbol* _tmp37_ = NULL;
			ValaList* _tmp38_ = NULL;
			ValaSymbol* _tmp39_ = NULL;
			_tmp38_ = attrs;
			_tmp39_ = vala_genie_parser_parse_interface_declaration (self, _tmp38_, &_inner_error_);
			_tmp37_ = _tmp39_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp37_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
		{
			ValaNamespace* _tmp40_ = NULL;
			ValaList* _tmp41_ = NULL;
			ValaNamespace* _tmp42_ = NULL;
			_tmp41_ = attrs;
			_tmp42_ = vala_genie_parser_parse_namespace_declaration (self, _tmp41_, &_inner_error_);
			_tmp40_ = _tmp42_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp40_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PROP:
		{
			ValaProperty* _tmp43_ = NULL;
			ValaList* _tmp44_ = NULL;
			ValaProperty* _tmp45_ = NULL;
			_tmp44_ = attrs;
			_tmp45_ = vala_genie_parser_parse_property_declaration (self, _tmp44_, &_inner_error_);
			_tmp43_ = _tmp45_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp43_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_EVENT:
		{
			ValaSignal* _tmp46_ = NULL;
			ValaList* _tmp47_ = NULL;
			ValaSignal* _tmp48_ = NULL;
			_tmp47_ = attrs;
			_tmp48_ = vala_genie_parser_parse_signal_declaration (self, _tmp47_, &_inner_error_);
			_tmp46_ = _tmp48_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp46_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_STRUCT:
		{
			ValaSymbol* _tmp49_ = NULL;
			ValaList* _tmp50_ = NULL;
			ValaSymbol* _tmp51_ = NULL;
			_tmp50_ = attrs;
			_tmp51_ = vala_genie_parser_parse_struct_declaration (self, _tmp50_, &_inner_error_);
			_tmp49_ = _tmp51_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp49_;
			_vala_iterable_unref0 (attrs);
			return result;
		}
		default:
		{
			ValaSourceLocation _tmp64_ = {0};
			while (TRUE) {
				gboolean _tmp52_ = FALSE;
				gboolean _tmp53_ = FALSE;
				ValaGenieTokenType _tmp54_ = 0;
				gboolean _tmp56_ = FALSE;
				gboolean _tmp58_ = FALSE;
				ValaGenieTokenType _tmp59_ = 0;
				_tmp54_ = vala_genie_parser_current (self);
				if (_tmp54_ != VALA_GENIE_TOKEN_TYPE_EOL) {
					ValaGenieTokenType _tmp55_ = 0;
					_tmp55_ = vala_genie_parser_current (self);
					_tmp53_ = _tmp55_ != VALA_GENIE_TOKEN_TYPE_SEMICOLON;
				} else {
					_tmp53_ = FALSE;
				}
				_tmp56_ = _tmp53_;
				if (_tmp56_) {
					ValaGenieTokenType _tmp57_ = 0;
					_tmp57_ = vala_genie_parser_current (self);
					_tmp52_ = _tmp57_ != VALA_GENIE_TOKEN_TYPE_EOF;
				} else {
					_tmp52_ = FALSE;
				}
				_tmp58_ = _tmp52_;
				if (!_tmp58_) {
					break;
				}
				_tmp59_ = vala_genie_parser_current (self);
				if (_tmp59_ == VALA_GENIE_TOKEN_TYPE_COLON) {
					ValaSourceLocation _tmp60_ = {0};
					ValaField* _tmp61_ = NULL;
					ValaList* _tmp62_ = NULL;
					ValaField* _tmp63_ = NULL;
					_tmp60_ = begin;
					vala_genie_parser_rollback (self, &_tmp60_);
					_tmp62_ = attrs;
					_tmp63_ = vala_genie_parser_parse_field_declaration (self, _tmp62_, &_inner_error_);
					_tmp61_ = _tmp63_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_iterable_unref0 (attrs);
							return NULL;
						} else {
							_vala_iterable_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					result = (ValaSymbol*) _tmp61_;
					_vala_iterable_unref0 (attrs);
					return result;
				} else {
					vala_genie_parser_next (self);
				}
			}
			_tmp64_ = begin;
			vala_genie_parser_rollback (self, &_tmp64_);
			break;
		}
	}
	_tmp65_ = vala_genie_parser_current (self);
	cur = _tmp65_;
	_tmp66_ = self->priv->tokens;
	_tmp66__length1 = self->priv->tokens_length1;
	_tmp67_ = self->priv->index;
	_tmp68_ = _tmp66_[_tmp67_ - 1];
	_tmp69_ = _tmp68_.type;
	pre = _tmp69_;
	_tmp70_ = cur;
	_tmp71_ = vala_genie_token_type_to_string (_tmp70_);
	_tmp72_ = pre;
	_tmp73_ = vala_genie_token_type_to_string (_tmp72_);
	_tmp74_ = g_strdup_printf ("expected declaration  but got %s with previous %s", _tmp71_, _tmp73_);
	_tmp75_ = _tmp74_;
	_tmp76_ = vala_genie_parser_get_error (self, _tmp75_);
	_tmp77_ = _tmp76_;
	_tmp78_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp77_);
	_tmp79_ = _tmp78_;
	_g_free0 (_tmp77_);
	_g_free0 (_tmp75_);
	_inner_error_ = _tmp79_;
	if (_inner_error_->domain == VALA_PARSE_ERROR) {
		g_propagate_error (error, _inner_error_);
		_vala_iterable_unref0 (attrs);
		return NULL;
	} else {
		_vala_iterable_unref0 (attrs);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_vala_iterable_unref0 (attrs);
}


static void vala_genie_parser_parse_declarations (ValaGenieParser* self, ValaSymbol* parent, gboolean root, GError** error) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp16_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parent != NULL);
	_tmp0_ = root;
	if (!_tmp0_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		ValaGenieTokenType _tmp2_ = 0;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = vala_genie_parser_current (self);
		if (_tmp2_ != VALA_GENIE_TOKEN_TYPE_DEDENT) {
			ValaGenieTokenType _tmp3_ = 0;
			_tmp3_ = vala_genie_parser_current (self);
			_tmp1_ = _tmp3_ != VALA_GENIE_TOKEN_TYPE_EOF;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		if (!_tmp4_) {
			break;
		}
		{
			ValaSymbol* _tmp5_ = NULL;
			_tmp5_ = parent;
			if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, VALA_TYPE_NAMESPACE)) {
				ValaSymbol* _tmp6_ = NULL;
				_tmp6_ = parent;
				vala_genie_parser_parse_namespace_member (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, VALA_TYPE_NAMESPACE, ValaNamespace), &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch8_vala_parse_error;
					}
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			} else {
				ValaSymbol* _tmp7_ = NULL;
				_tmp7_ = parent;
				if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, VALA_TYPE_CLASS)) {
					ValaSymbol* _tmp8_ = NULL;
					_tmp8_ = parent;
					vala_genie_parser_parse_class_member (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp8_, VALA_TYPE_CLASS, ValaClass), &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch8_vala_parse_error;
						}
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				} else {
					ValaSymbol* _tmp9_ = NULL;
					_tmp9_ = parent;
					if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, VALA_TYPE_STRUCT)) {
						ValaSymbol* _tmp10_ = NULL;
						_tmp10_ = parent;
						vala_genie_parser_parse_struct_member (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp10_, VALA_TYPE_STRUCT, ValaStruct), &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch8_vala_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					} else {
						ValaSymbol* _tmp11_ = NULL;
						_tmp11_ = parent;
						if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, VALA_TYPE_INTERFACE)) {
							ValaSymbol* _tmp12_ = NULL;
							_tmp12_ = parent;
							vala_genie_parser_parse_interface_member (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp12_, VALA_TYPE_INTERFACE, ValaInterface), &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									goto __catch8_vala_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
					}
				}
			}
		}
		goto __finally8;
		__catch8_vala_parse_error:
		{
			GError* e = NULL;
			gint r = 0;
			gint _tmp15_ = 0;
			e = _inner_error_;
			_inner_error_ = NULL;
			while (TRUE) {
				ValaGenieParserRecoveryState _tmp13_ = 0;
				gint _tmp14_ = 0;
				_tmp13_ = vala_genie_parser_recover (self);
				r = (gint) _tmp13_;
				_tmp14_ = r;
				if (_tmp14_ == ((gint) VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN)) {
					vala_genie_parser_next (self);
				} else {
					break;
				}
			}
			_tmp15_ = r;
			if (_tmp15_ == ((gint) VALA_GENIE_PARSER_RECOVERY_STATE_EOF)) {
				_g_error_free0 (e);
				return;
			}
			_g_error_free0 (e);
		}
		__finally8:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	_tmp16_ = root;
	if (!_tmp16_) {
		gboolean _tmp17_ = FALSE;
		_tmp17_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DEDENT);
		if (!_tmp17_) {
			ValaCodeContext* _tmp18_ = NULL;
			ValaReport* _tmp19_ = NULL;
			ValaReport* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			_tmp18_ = self->priv->context;
			_tmp19_ = vala_code_context_get_report (_tmp18_);
			_tmp20_ = _tmp19_;
			_tmp21_ = vala_report_get_errors (_tmp20_);
			if (_tmp21_ == 0) {
				ValaSourceReference* _tmp22_ = NULL;
				ValaSourceReference* _tmp23_ = NULL;
				_tmp22_ = vala_genie_parser_get_current_src (self);
				_tmp23_ = _tmp22_;
				vala_report_error (_tmp23_, "expected dedent");
				_vala_source_reference_unref0 (_tmp23_);
			}
		}
	}
}


static ValaGenieParserRecoveryState vala_genie_parser_recover (ValaGenieParser* self) {
	ValaGenieParserRecoveryState result = 0;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		ValaGenieTokenType _tmp0_ = 0;
		ValaGenieTokenType _tmp1_ = 0;
		_tmp0_ = vala_genie_parser_current (self);
		if (!(_tmp0_ != VALA_GENIE_TOKEN_TYPE_EOF)) {
			break;
		}
		_tmp1_ = vala_genie_parser_current (self);
		switch (_tmp1_) {
			case VALA_GENIE_TOKEN_TYPE_CLASS:
			case VALA_GENIE_TOKEN_TYPE_CONST:
			case VALA_GENIE_TOKEN_TYPE_CONSTRUCT:
			case VALA_GENIE_TOKEN_TYPE_INIT:
			case VALA_GENIE_TOKEN_TYPE_DEF:
			case VALA_GENIE_TOKEN_TYPE_DELEGATE:
			case VALA_GENIE_TOKEN_TYPE_ENUM:
			case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
			case VALA_GENIE_TOKEN_TYPE_FINAL:
			case VALA_GENIE_TOKEN_TYPE_INTERFACE:
			case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
			case VALA_GENIE_TOKEN_TYPE_PROP:
			case VALA_GENIE_TOKEN_TYPE_EVENT:
			case VALA_GENIE_TOKEN_TYPE_STRUCT:
			{
				result = VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN;
				return result;
			}
			case VALA_GENIE_TOKEN_TYPE_BREAK:
			case VALA_GENIE_TOKEN_TYPE_CASE:
			case VALA_GENIE_TOKEN_TYPE_CONTINUE:
			case VALA_GENIE_TOKEN_TYPE_DELETE:
			case VALA_GENIE_TOKEN_TYPE_DO:
			case VALA_GENIE_TOKEN_TYPE_FOR:
			case VALA_GENIE_TOKEN_TYPE_IF:
			case VALA_GENIE_TOKEN_TYPE_LOCK:
			case VALA_GENIE_TOKEN_TYPE_RETURN:
			case VALA_GENIE_TOKEN_TYPE_RAISE:
			case VALA_GENIE_TOKEN_TYPE_TRY:
			case VALA_GENIE_TOKEN_TYPE_VAR:
			case VALA_GENIE_TOKEN_TYPE_WHILE:
			case VALA_GENIE_TOKEN_TYPE_YIELD:
			{
				result = VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN;
				return result;
			}
			default:
			{
				vala_genie_parser_next (self);
				break;
			}
		}
	}
	result = VALA_GENIE_PARSER_RECOVERY_STATE_EOF;
	return result;
}


static ValaNamespace* vala_genie_parser_parse_namespace_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaNamespace* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp1_ = NULL;
	ValaNamespace* ns = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaNamespace* _tmp8_ = NULL;
	ValaNamespace* _tmp9_ = NULL;
	ValaComment* _tmp10_ = NULL;
	ValaNamespace* _tmp13_ = NULL;
	ValaList* _tmp14_ = NULL;
	ValaNamespace* _tmp15_ = NULL;
	ValaNamespace* _result_ = NULL;
	ValaNamespace* _tmp16_ = NULL;
	ValaNamespace* _tmp17_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_NAMESPACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = sym;
	_tmp3_ = vala_symbol_get_name ((ValaSymbol*) _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = vala_namespace_new (_tmp4_, _tmp7_);
	_tmp9_ = _tmp8_;
	_vala_source_reference_unref0 (_tmp7_);
	ns = _tmp9_;
	_tmp10_ = self->priv->comment;
	if (_tmp10_ != NULL) {
		ValaNamespace* _tmp11_ = NULL;
		ValaComment* _tmp12_ = NULL;
		_tmp11_ = ns;
		_tmp12_ = self->priv->comment;
		vala_namespace_add_comment (_tmp11_, _tmp12_);
		_vala_comment_unref0 (self->priv->comment);
		self->priv->comment = NULL;
	}
	_tmp13_ = ns;
	_tmp14_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp13_, _tmp14_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp15_ = ns;
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) _tmp15_, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp16_ = ns;
	_tmp17_ = _vala_code_node_ref0 (_tmp16_);
	_result_ = _tmp17_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp18_ = NULL;
		ValaUnresolvedSymbol* _tmp19_ = NULL;
		ValaUnresolvedSymbol* _tmp20_ = NULL;
		ValaUnresolvedSymbol* _tmp21_ = NULL;
		ValaUnresolvedSymbol* _tmp22_ = NULL;
		ValaUnresolvedSymbol* _tmp23_ = NULL;
		ValaUnresolvedSymbol* _tmp24_ = NULL;
		ValaUnresolvedSymbol* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		ValaNamespace* _tmp28_ = NULL;
		ValaSourceReference* _tmp29_ = NULL;
		ValaSourceReference* _tmp30_ = NULL;
		ValaNamespace* _tmp31_ = NULL;
		ValaNamespace* _tmp32_ = NULL;
		ValaNamespace* _tmp33_ = NULL;
		ValaNamespace* _tmp34_ = NULL;
		ValaNamespace* _tmp35_ = NULL;
		_tmp18_ = sym;
		_tmp19_ = vala_unresolved_symbol_get_inner (_tmp18_);
		_tmp20_ = _tmp19_;
		if (!(_tmp20_ != NULL)) {
			break;
		}
		_tmp21_ = sym;
		_tmp22_ = vala_unresolved_symbol_get_inner (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = _vala_code_node_ref0 (_tmp23_);
		_vala_code_node_unref0 (sym);
		sym = _tmp24_;
		_tmp25_ = sym;
		_tmp26_ = vala_symbol_get_name ((ValaSymbol*) _tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = _result_;
		_tmp29_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = vala_namespace_new (_tmp27_, _tmp30_);
		_vala_code_node_unref0 (ns);
		ns = _tmp31_;
		_tmp32_ = ns;
		_tmp33_ = _result_;
		vala_symbol_add_namespace ((ValaSymbol*) _tmp32_, G_TYPE_CHECK_INSTANCE_CAST (_tmp33_, VALA_TYPE_NAMESPACE, ValaNamespace));
		_tmp34_ = ns;
		_tmp35_ = _vala_code_node_ref0 (_tmp34_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp35_;
	}
	result = _result_;
	_vala_code_node_unref0 (ns);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_namespace_member (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	ValaSymbol* sym = NULL;
	ValaNamespace* _tmp0_ = NULL;
	ValaCodeContext* _tmp1_ = NULL;
	ValaNamespace* _tmp2_ = NULL;
	ValaNamespace* _tmp3_ = NULL;
	ValaSymbol* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	_tmp0_ = ns;
	_tmp1_ = self->priv->context;
	_tmp2_ = vala_code_context_get_root (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_genie_parser_parse_declaration (self, _tmp0_ == _tmp3_, &_inner_error_);
	sym = _tmp4_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_NAMESPACE)) {
		ValaNamespace* _tmp5_ = NULL;
		_tmp5_ = ns;
		vala_symbol_add_namespace ((ValaSymbol*) _tmp5_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_NAMESPACE, ValaNamespace));
	} else {
		if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CLASS)) {
			ValaNamespace* _tmp6_ = NULL;
			_tmp6_ = ns;
			vala_symbol_add_class ((ValaSymbol*) _tmp6_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CLASS, ValaClass));
		} else {
			if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_INTERFACE)) {
				ValaNamespace* _tmp7_ = NULL;
				_tmp7_ = ns;
				vala_symbol_add_interface ((ValaSymbol*) _tmp7_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_INTERFACE, ValaInterface));
			} else {
				if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_STRUCT)) {
					ValaNamespace* _tmp8_ = NULL;
					_tmp8_ = ns;
					vala_symbol_add_struct ((ValaSymbol*) _tmp8_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_STRUCT, ValaStruct));
				} else {
					if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_ENUM)) {
						ValaNamespace* _tmp9_ = NULL;
						_tmp9_ = ns;
						vala_symbol_add_enum ((ValaSymbol*) _tmp9_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_ENUM, ValaEnum));
					} else {
						if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_ERROR_DOMAIN)) {
							ValaNamespace* _tmp10_ = NULL;
							_tmp10_ = ns;
							vala_symbol_add_error_domain ((ValaSymbol*) _tmp10_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_ERROR_DOMAIN, ValaErrorDomain));
						} else {
							if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_DELEGATE)) {
								ValaNamespace* _tmp11_ = NULL;
								_tmp11_ = ns;
								vala_symbol_add_delegate ((ValaSymbol*) _tmp11_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_DELEGATE, ValaDelegate));
							} else {
								if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_METHOD)) {
									ValaMethod* method = NULL;
									ValaMethod* _tmp12_ = NULL;
									ValaMethod* _tmp13_ = NULL;
									ValaMemberBinding _tmp14_ = 0;
									ValaMemberBinding _tmp15_ = 0;
									ValaNamespace* _tmp17_ = NULL;
									ValaMethod* _tmp18_ = NULL;
									_tmp12_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_METHOD, ValaMethod));
									method = _tmp12_;
									_tmp13_ = method;
									_tmp14_ = vala_method_get_binding (_tmp13_);
									_tmp15_ = _tmp14_;
									if (_tmp15_ == VALA_MEMBER_BINDING_INSTANCE) {
										ValaMethod* _tmp16_ = NULL;
										_tmp16_ = method;
										vala_method_set_binding (_tmp16_, VALA_MEMBER_BINDING_STATIC);
									}
									_tmp17_ = ns;
									_tmp18_ = method;
									vala_symbol_add_method ((ValaSymbol*) _tmp17_, _tmp18_);
									_vala_code_node_unref0 (method);
								} else {
									if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_FIELD)) {
										ValaField* field = NULL;
										ValaField* _tmp19_ = NULL;
										ValaField* _tmp20_ = NULL;
										ValaMemberBinding _tmp21_ = 0;
										ValaMemberBinding _tmp22_ = 0;
										ValaNamespace* _tmp24_ = NULL;
										ValaField* _tmp25_ = NULL;
										_tmp19_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_FIELD, ValaField));
										field = _tmp19_;
										_tmp20_ = field;
										_tmp21_ = vala_field_get_binding (_tmp20_);
										_tmp22_ = _tmp21_;
										if (_tmp22_ == VALA_MEMBER_BINDING_INSTANCE) {
											ValaField* _tmp23_ = NULL;
											_tmp23_ = field;
											vala_field_set_binding (_tmp23_, VALA_MEMBER_BINDING_STATIC);
										}
										_tmp24_ = ns;
										_tmp25_ = field;
										vala_symbol_add_field ((ValaSymbol*) _tmp24_, _tmp25_);
										_vala_code_node_unref0 (field);
									} else {
										if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CONSTANT)) {
											ValaNamespace* _tmp26_ = NULL;
											_tmp26_ = ns;
											vala_symbol_add_constant ((ValaSymbol*) _tmp26_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CONSTANT, ValaConstant));
										} else {
											ValaSourceReference* _tmp27_ = NULL;
											ValaSourceReference* _tmp28_ = NULL;
											_tmp27_ = vala_code_node_get_source_reference ((ValaCodeNode*) sym);
											_tmp28_ = _tmp27_;
											vala_report_error (_tmp28_, "unexpected declaration in namespace");
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static void vala_genie_parser_add_uses_clause (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp1_ = NULL;
	ValaUsingDirective* ns_ref = NULL;
	ValaSourceLocation _tmp2_ = {0};
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaUsingDirective* _tmp5_ = NULL;
	ValaUsingDirective* _tmp6_ = NULL;
	ValaGenieScanner* _tmp7_ = NULL;
	ValaSourceFile* _tmp8_ = NULL;
	ValaSourceFile* _tmp9_ = NULL;
	ValaUsingDirective* _tmp10_ = NULL;
	ValaNamespace* _tmp11_ = NULL;
	ValaUsingDirective* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = begin;
	_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_using_directive_new ((ValaSymbol*) sym, _tmp4_);
	_tmp6_ = _tmp5_;
	_vala_source_reference_unref0 (_tmp4_);
	ns_ref = _tmp6_;
	_tmp7_ = self->priv->scanner;
	_tmp8_ = vala_genie_scanner_get_source_file (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = ns_ref;
	vala_source_file_add_using_directive (_tmp9_, _tmp10_);
	_tmp11_ = ns;
	_tmp12_ = ns_ref;
	vala_namespace_add_using_directive (_tmp11_, _tmp12_);
	_vala_code_node_unref0 (ns_ref);
	_vala_code_node_unref0 (sym);
}


static void vala_genie_parser_parse_using_directives (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_USES);
		if (!_tmp0_) {
			break;
		}
		_tmp1_ = vala_genie_parser_accept_block (self);
		if (_tmp1_) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			while (TRUE) {
				gboolean _tmp2_ = FALSE;
				ValaGenieTokenType _tmp3_ = 0;
				gboolean _tmp5_ = FALSE;
				ValaNamespace* _tmp6_ = NULL;
				_tmp3_ = vala_genie_parser_current (self);
				if (_tmp3_ != VALA_GENIE_TOKEN_TYPE_DEDENT) {
					ValaGenieTokenType _tmp4_ = 0;
					_tmp4_ = vala_genie_parser_current (self);
					_tmp2_ = _tmp4_ != VALA_GENIE_TOKEN_TYPE_EOF;
				} else {
					_tmp2_ = FALSE;
				}
				_tmp5_ = _tmp2_;
				if (!_tmp5_) {
					break;
				}
				_tmp6_ = ns;
				vala_genie_parser_add_uses_clause (self, _tmp6_, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			{
				gboolean _tmp7_ = FALSE;
				_tmp7_ = TRUE;
				while (TRUE) {
					gboolean _tmp8_ = FALSE;
					ValaNamespace* _tmp10_ = NULL;
					_tmp8_ = _tmp7_;
					if (!_tmp8_) {
						gboolean _tmp9_ = FALSE;
						_tmp9_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp9_) {
							break;
						}
					}
					_tmp7_ = FALSE;
					_tmp10_ = ns;
					vala_genie_parser_add_uses_clause (self, _tmp10_, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
			vala_genie_parser_expect_terminator (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static ValaSymbol* vala_genie_parser_parse_class_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaList* type_param_list = NULL;
	ValaList* _tmp3_ = NULL;
	ValaArrayList* base_types = NULL;
	GEqualFunc _tmp4_ = NULL;
	ValaArrayList* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	ValaClass* cl = NULL;
	ValaUnresolvedSymbol* _tmp17_ = NULL;
	const gchar* _tmp18_ = NULL;
	const gchar* _tmp19_ = NULL;
	ValaSourceLocation _tmp20_ = {0};
	ValaSourceReference* _tmp21_ = NULL;
	ValaSourceReference* _tmp22_ = NULL;
	ValaComment* _tmp23_ = NULL;
	ValaClass* _tmp24_ = NULL;
	ValaClass* _tmp25_ = NULL;
	ValaGenieParserModifierFlags _tmp26_ = 0;
	ValaGenieParserModifierFlags _tmp34_ = 0;
	ValaClass* _tmp36_ = NULL;
	ValaList* _tmp37_ = NULL;
	ValaClass* _tmp64_ = NULL;
	const gchar* _tmp65_ = NULL;
	const gchar* _tmp66_ = NULL;
	gchar* _tmp67_ = NULL;
	ValaClass* _tmp68_ = NULL;
	gboolean _tmp69_ = FALSE;
	ValaGenieScanner* _tmp70_ = NULL;
	ValaSourceFile* _tmp71_ = NULL;
	ValaSourceFile* _tmp72_ = NULL;
	ValaSourceFileType _tmp73_ = 0;
	ValaSourceFileType _tmp74_ = 0;
	gboolean _tmp78_ = FALSE;
	ValaSymbol* _result_ = NULL;
	ValaClass* _tmp95_ = NULL;
	ValaSymbol* _tmp96_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLASS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	type_param_list = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = g_direct_equal;
	_tmp5_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp4_);
	base_types = _tmp5_;
	_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp6_) {
		ValaDataType* type1 = NULL;
		ValaDataType* _tmp7_ = NULL;
		ValaArrayList* _tmp8_ = NULL;
		ValaDataType* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		_tmp7_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		type1 = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (base_types);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_iterable_unref0 (base_types);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp8_ = base_types;
		_tmp9_ = type1;
		vala_collection_add ((ValaCollection*) _tmp8_, _tmp9_);
		_tmp10_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IMPLEMENTS);
		if (_tmp10_) {
			{
				gboolean _tmp11_ = FALSE;
				_tmp11_ = TRUE;
				while (TRUE) {
					gboolean _tmp12_ = FALSE;
					ValaDataType* type2 = NULL;
					ValaDataType* _tmp14_ = NULL;
					ValaArrayList* _tmp15_ = NULL;
					ValaDataType* _tmp16_ = NULL;
					_tmp12_ = _tmp11_;
					if (!_tmp12_) {
						gboolean _tmp13_ = FALSE;
						_tmp13_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp13_) {
							break;
						}
					}
					_tmp11_ = FALSE;
					_tmp14_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
					type2 = _tmp14_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (type1);
							_vala_iterable_unref0 (base_types);
							_vala_iterable_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							return NULL;
						} else {
							_vala_code_node_unref0 (type1);
							_vala_iterable_unref0 (base_types);
							_vala_iterable_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp15_ = base_types;
					_tmp16_ = type2;
					vala_collection_add ((ValaCollection*) _tmp15_, _tmp16_);
					_vala_code_node_unref0 (type2);
				}
			}
		}
		_vala_code_node_unref0 (type1);
	}
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	_tmp17_ = sym;
	_tmp18_ = vala_symbol_get_name ((ValaSymbol*) _tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = begin;
	_tmp21_ = vala_genie_parser_get_src (self, &_tmp20_);
	_tmp22_ = _tmp21_;
	_tmp23_ = self->priv->comment;
	_tmp24_ = vala_class_new (_tmp19_, _tmp22_, _tmp23_);
	_tmp25_ = _tmp24_;
	_vala_source_reference_unref0 (_tmp22_);
	cl = _tmp25_;
	_tmp26_ = flags;
	if ((_tmp26_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaClass* _tmp27_ = NULL;
		_tmp27_ = cl;
		vala_symbol_set_access ((ValaSymbol*) _tmp27_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaUnresolvedSymbol* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		gchar _tmp31_ = '\0';
		_tmp28_ = sym;
		_tmp29_ = vala_symbol_get_name ((ValaSymbol*) _tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = string_get (_tmp30_, (glong) 0);
		if (_tmp31_ == '_') {
			ValaClass* _tmp32_ = NULL;
			_tmp32_ = cl;
			vala_symbol_set_access ((ValaSymbol*) _tmp32_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
		} else {
			ValaClass* _tmp33_ = NULL;
			_tmp33_ = cl;
			vala_symbol_set_access ((ValaSymbol*) _tmp33_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		}
	}
	_tmp34_ = flags;
	if ((_tmp34_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		ValaClass* _tmp35_ = NULL;
		_tmp35_ = cl;
		vala_class_set_is_abstract (_tmp35_, TRUE);
	}
	_tmp36_ = cl;
	_tmp37_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp36_, _tmp37_);
	{
		ValaList* _type_param_list = NULL;
		ValaList* _tmp38_ = NULL;
		ValaList* _tmp39_ = NULL;
		gint _type_param_size = 0;
		ValaList* _tmp40_ = NULL;
		gint _tmp41_ = 0;
		gint _tmp42_ = 0;
		gint _type_param_index = 0;
		_tmp38_ = type_param_list;
		_tmp39_ = _vala_iterable_ref0 (_tmp38_);
		_type_param_list = _tmp39_;
		_tmp40_ = _type_param_list;
		_tmp41_ = vala_collection_get_size ((ValaCollection*) _tmp40_);
		_tmp42_ = _tmp41_;
		_type_param_size = _tmp42_;
		_type_param_index = -1;
		while (TRUE) {
			gint _tmp43_ = 0;
			gint _tmp44_ = 0;
			gint _tmp45_ = 0;
			ValaTypeParameter* type_param = NULL;
			ValaList* _tmp46_ = NULL;
			gint _tmp47_ = 0;
			gpointer _tmp48_ = NULL;
			ValaClass* _tmp49_ = NULL;
			ValaTypeParameter* _tmp50_ = NULL;
			_tmp43_ = _type_param_index;
			_type_param_index = _tmp43_ + 1;
			_tmp44_ = _type_param_index;
			_tmp45_ = _type_param_size;
			if (!(_tmp44_ < _tmp45_)) {
				break;
			}
			_tmp46_ = _type_param_list;
			_tmp47_ = _type_param_index;
			_tmp48_ = vala_list_get (_tmp46_, _tmp47_);
			type_param = (ValaTypeParameter*) _tmp48_;
			_tmp49_ = cl;
			_tmp50_ = type_param;
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) _tmp49_, _tmp50_);
			_vala_code_node_unref0 (type_param);
		}
		_vala_iterable_unref0 (_type_param_list);
	}
	{
		ValaArrayList* _base_type_list = NULL;
		ValaArrayList* _tmp51_ = NULL;
		ValaArrayList* _tmp52_ = NULL;
		gint _base_type_size = 0;
		ValaArrayList* _tmp53_ = NULL;
		gint _tmp54_ = 0;
		gint _tmp55_ = 0;
		gint _base_type_index = 0;
		_tmp51_ = base_types;
		_tmp52_ = _vala_iterable_ref0 (_tmp51_);
		_base_type_list = _tmp52_;
		_tmp53_ = _base_type_list;
		_tmp54_ = vala_collection_get_size ((ValaCollection*) _tmp53_);
		_tmp55_ = _tmp54_;
		_base_type_size = _tmp55_;
		_base_type_index = -1;
		while (TRUE) {
			gint _tmp56_ = 0;
			gint _tmp57_ = 0;
			gint _tmp58_ = 0;
			ValaDataType* base_type = NULL;
			ValaArrayList* _tmp59_ = NULL;
			gint _tmp60_ = 0;
			gpointer _tmp61_ = NULL;
			ValaClass* _tmp62_ = NULL;
			ValaDataType* _tmp63_ = NULL;
			_tmp56_ = _base_type_index;
			_base_type_index = _tmp56_ + 1;
			_tmp57_ = _base_type_index;
			_tmp58_ = _base_type_size;
			if (!(_tmp57_ < _tmp58_)) {
				break;
			}
			_tmp59_ = _base_type_list;
			_tmp60_ = _base_type_index;
			_tmp61_ = vala_list_get ((ValaList*) _tmp59_, _tmp60_);
			base_type = (ValaDataType*) _tmp61_;
			_tmp62_ = cl;
			_tmp63_ = base_type;
			vala_class_add_base_type (_tmp62_, _tmp63_);
			_vala_code_node_unref0 (base_type);
		}
		_vala_iterable_unref0 (_base_type_list);
	}
	_tmp64_ = cl;
	_tmp65_ = vala_symbol_get_name ((ValaSymbol*) _tmp64_);
	_tmp66_ = _tmp65_;
	_tmp67_ = g_strdup (_tmp66_);
	_g_free0 (self->priv->class_name);
	self->priv->class_name = _tmp67_;
	_tmp68_ = cl;
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) _tmp68_, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (cl);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (cl);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp70_ = self->priv->scanner;
	_tmp71_ = vala_genie_scanner_get_source_file (_tmp70_);
	_tmp72_ = _tmp71_;
	_tmp73_ = vala_source_file_get_file_type (_tmp72_);
	_tmp74_ = _tmp73_;
	if (_tmp74_ == VALA_SOURCE_FILE_TYPE_SOURCE) {
		ValaClass* _tmp75_ = NULL;
		ValaCreationMethod* _tmp76_ = NULL;
		ValaCreationMethod* _tmp77_ = NULL;
		_tmp75_ = cl;
		_tmp76_ = vala_class_get_default_construction_method (_tmp75_);
		_tmp77_ = _tmp76_;
		_tmp69_ = _tmp77_ == NULL;
	} else {
		_tmp69_ = FALSE;
	}
	_tmp78_ = _tmp69_;
	if (_tmp78_) {
		ValaCreationMethod* m = NULL;
		ValaClass* _tmp79_ = NULL;
		const gchar* _tmp80_ = NULL;
		const gchar* _tmp81_ = NULL;
		ValaClass* _tmp82_ = NULL;
		ValaSourceReference* _tmp83_ = NULL;
		ValaSourceReference* _tmp84_ = NULL;
		ValaCreationMethod* _tmp85_ = NULL;
		ValaCreationMethod* _tmp86_ = NULL;
		ValaCreationMethod* _tmp87_ = NULL;
		ValaClass* _tmp88_ = NULL;
		ValaSourceReference* _tmp89_ = NULL;
		ValaSourceReference* _tmp90_ = NULL;
		ValaBlock* _tmp91_ = NULL;
		ValaBlock* _tmp92_ = NULL;
		ValaClass* _tmp93_ = NULL;
		ValaCreationMethod* _tmp94_ = NULL;
		_tmp79_ = cl;
		_tmp80_ = vala_symbol_get_name ((ValaSymbol*) _tmp79_);
		_tmp81_ = _tmp80_;
		_tmp82_ = cl;
		_tmp83_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp82_);
		_tmp84_ = _tmp83_;
		_tmp85_ = vala_creation_method_new (_tmp81_, NULL, _tmp84_, NULL);
		m = _tmp85_;
		_tmp86_ = m;
		vala_symbol_set_access ((ValaSymbol*) _tmp86_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		_tmp87_ = m;
		_tmp88_ = cl;
		_tmp89_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp88_);
		_tmp90_ = _tmp89_;
		_tmp91_ = vala_block_new (_tmp90_);
		_tmp92_ = _tmp91_;
		vala_subroutine_set_body ((ValaSubroutine*) _tmp87_, _tmp92_);
		_vala_code_node_unref0 (_tmp92_);
		_tmp93_ = cl;
		_tmp94_ = m;
		vala_symbol_add_method ((ValaSymbol*) _tmp93_, (ValaMethod*) _tmp94_);
		_vala_code_node_unref0 (m);
	}
	_tmp95_ = cl;
	_tmp96_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp95_);
	_result_ = _tmp96_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp97_ = NULL;
		ValaUnresolvedSymbol* _tmp98_ = NULL;
		ValaUnresolvedSymbol* _tmp99_ = NULL;
		ValaUnresolvedSymbol* _tmp100_ = NULL;
		ValaUnresolvedSymbol* _tmp101_ = NULL;
		ValaUnresolvedSymbol* _tmp102_ = NULL;
		ValaUnresolvedSymbol* _tmp103_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp104_ = NULL;
		const gchar* _tmp105_ = NULL;
		const gchar* _tmp106_ = NULL;
		ValaClass* _tmp107_ = NULL;
		ValaSourceReference* _tmp108_ = NULL;
		ValaSourceReference* _tmp109_ = NULL;
		ValaNamespace* _tmp110_ = NULL;
		ValaSymbol* _tmp111_ = NULL;
		ValaNamespace* _tmp116_ = NULL;
		ValaSymbol* _tmp117_ = NULL;
		_tmp97_ = sym;
		_tmp98_ = vala_unresolved_symbol_get_inner (_tmp97_);
		_tmp99_ = _tmp98_;
		if (!(_tmp99_ != NULL)) {
			break;
		}
		_tmp100_ = sym;
		_tmp101_ = vala_unresolved_symbol_get_inner (_tmp100_);
		_tmp102_ = _tmp101_;
		_tmp103_ = _vala_code_node_ref0 (_tmp102_);
		_vala_code_node_unref0 (sym);
		sym = _tmp103_;
		_tmp104_ = sym;
		_tmp105_ = vala_symbol_get_name ((ValaSymbol*) _tmp104_);
		_tmp106_ = _tmp105_;
		_tmp107_ = cl;
		_tmp108_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp107_);
		_tmp109_ = _tmp108_;
		_tmp110_ = vala_namespace_new (_tmp106_, _tmp109_);
		ns = _tmp110_;
		_tmp111_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp111_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp112_ = NULL;
			ValaSymbol* _tmp113_ = NULL;
			_tmp112_ = ns;
			_tmp113_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp112_, G_TYPE_CHECK_INSTANCE_CAST (_tmp113_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp114_ = NULL;
			ValaSymbol* _tmp115_ = NULL;
			_tmp114_ = ns;
			_tmp115_ = _result_;
			vala_symbol_add_class ((ValaSymbol*) _tmp114_, G_TYPE_CHECK_INSTANCE_CAST (_tmp115_, VALA_TYPE_CLASS, ValaClass));
		}
		_tmp116_ = ns;
		_tmp117_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp116_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp117_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (cl);
	_vala_iterable_unref0 (base_types);
	_vala_iterable_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_class_member (ValaGenieParser* self, ValaClass* cl, GError** error) {
	ValaSymbol* sym = NULL;
	ValaSymbol* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cl != NULL);
	_tmp0_ = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	sym = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CLASS)) {
		ValaClass* _tmp1_ = NULL;
		_tmp1_ = cl;
		vala_symbol_add_class ((ValaSymbol*) _tmp1_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CLASS, ValaClass));
	} else {
		if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_STRUCT)) {
			ValaClass* _tmp2_ = NULL;
			_tmp2_ = cl;
			vala_symbol_add_struct ((ValaSymbol*) _tmp2_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_STRUCT, ValaStruct));
		} else {
			if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_ENUM)) {
				ValaClass* _tmp3_ = NULL;
				_tmp3_ = cl;
				vala_symbol_add_enum ((ValaSymbol*) _tmp3_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_ENUM, ValaEnum));
			} else {
				if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_DELEGATE)) {
					ValaClass* _tmp4_ = NULL;
					_tmp4_ = cl;
					vala_symbol_add_delegate ((ValaSymbol*) _tmp4_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_DELEGATE, ValaDelegate));
				} else {
					if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_METHOD)) {
						ValaClass* _tmp5_ = NULL;
						_tmp5_ = cl;
						vala_symbol_add_method ((ValaSymbol*) _tmp5_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_METHOD, ValaMethod));
					} else {
						if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_SIGNAL)) {
							ValaClass* _tmp6_ = NULL;
							_tmp6_ = cl;
							vala_symbol_add_signal ((ValaSymbol*) _tmp6_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_SIGNAL, ValaSignal));
						} else {
							if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_FIELD)) {
								ValaClass* _tmp7_ = NULL;
								_tmp7_ = cl;
								vala_symbol_add_field ((ValaSymbol*) _tmp7_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_FIELD, ValaField));
							} else {
								if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CONSTANT)) {
									ValaClass* _tmp8_ = NULL;
									_tmp8_ = cl;
									vala_symbol_add_constant ((ValaSymbol*) _tmp8_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CONSTANT, ValaConstant));
								} else {
									if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_PROPERTY)) {
										ValaClass* _tmp9_ = NULL;
										_tmp9_ = cl;
										vala_symbol_add_property ((ValaSymbol*) _tmp9_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_PROPERTY, ValaProperty));
									} else {
										if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CONSTRUCTOR)) {
											ValaConstructor* c = NULL;
											ValaConstructor* _tmp10_ = NULL;
											ValaConstructor* _tmp11_ = NULL;
											ValaMemberBinding _tmp12_ = 0;
											ValaMemberBinding _tmp13_ = 0;
											_tmp10_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CONSTRUCTOR, ValaConstructor));
											c = _tmp10_;
											_tmp11_ = c;
											_tmp12_ = vala_constructor_get_binding (_tmp11_);
											_tmp13_ = _tmp12_;
											if (_tmp13_ == VALA_MEMBER_BINDING_INSTANCE) {
												ValaClass* _tmp14_ = NULL;
												ValaConstructor* _tmp15_ = NULL;
												ValaConstructor* _tmp16_ = NULL;
												ValaClass* _tmp20_ = NULL;
												ValaConstructor* _tmp21_ = NULL;
												_tmp14_ = cl;
												_tmp15_ = vala_class_get_constructor (_tmp14_);
												_tmp16_ = _tmp15_;
												if (_tmp16_ != NULL) {
													ValaConstructor* _tmp17_ = NULL;
													ValaSourceReference* _tmp18_ = NULL;
													ValaSourceReference* _tmp19_ = NULL;
													_tmp17_ = c;
													_tmp18_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp17_);
													_tmp19_ = _tmp18_;
													vala_report_error (_tmp19_, "class already contains a constructor");
												}
												_tmp20_ = cl;
												_tmp21_ = c;
												vala_class_set_constructor (_tmp20_, _tmp21_);
											} else {
												ValaConstructor* _tmp22_ = NULL;
												ValaMemberBinding _tmp23_ = 0;
												ValaMemberBinding _tmp24_ = 0;
												_tmp22_ = c;
												_tmp23_ = vala_constructor_get_binding (_tmp22_);
												_tmp24_ = _tmp23_;
												if (_tmp24_ == VALA_MEMBER_BINDING_CLASS) {
													ValaClass* _tmp25_ = NULL;
													ValaConstructor* _tmp26_ = NULL;
													ValaConstructor* _tmp27_ = NULL;
													ValaClass* _tmp31_ = NULL;
													ValaConstructor* _tmp32_ = NULL;
													_tmp25_ = cl;
													_tmp26_ = vala_class_get_class_constructor (_tmp25_);
													_tmp27_ = _tmp26_;
													if (_tmp27_ != NULL) {
														ValaConstructor* _tmp28_ = NULL;
														ValaSourceReference* _tmp29_ = NULL;
														ValaSourceReference* _tmp30_ = NULL;
														_tmp28_ = c;
														_tmp29_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp28_);
														_tmp30_ = _tmp29_;
														vala_report_error (_tmp30_, "class already contains a class constructor");
													}
													_tmp31_ = cl;
													_tmp32_ = c;
													vala_class_set_class_constructor (_tmp31_, _tmp32_);
												} else {
													ValaClass* _tmp33_ = NULL;
													ValaConstructor* _tmp34_ = NULL;
													ValaConstructor* _tmp35_ = NULL;
													ValaClass* _tmp39_ = NULL;
													ValaConstructor* _tmp40_ = NULL;
													_tmp33_ = cl;
													_tmp34_ = vala_class_get_static_constructor (_tmp33_);
													_tmp35_ = _tmp34_;
													if (_tmp35_ != NULL) {
														ValaConstructor* _tmp36_ = NULL;
														ValaSourceReference* _tmp37_ = NULL;
														ValaSourceReference* _tmp38_ = NULL;
														_tmp36_ = c;
														_tmp37_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp36_);
														_tmp38_ = _tmp37_;
														vala_report_error (_tmp38_, "class already contains a static constructor");
													}
													_tmp39_ = cl;
													_tmp40_ = c;
													vala_class_set_static_constructor (_tmp39_, _tmp40_);
												}
											}
											_vala_code_node_unref0 (c);
										} else {
											if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_DESTRUCTOR)) {
												ValaDestructor* d = NULL;
												ValaDestructor* _tmp41_ = NULL;
												ValaDestructor* _tmp42_ = NULL;
												ValaMemberBinding _tmp43_ = 0;
												ValaMemberBinding _tmp44_ = 0;
												_tmp41_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_DESTRUCTOR, ValaDestructor));
												d = _tmp41_;
												_tmp42_ = d;
												_tmp43_ = vala_destructor_get_binding (_tmp42_);
												_tmp44_ = _tmp43_;
												if (_tmp44_ == VALA_MEMBER_BINDING_STATIC) {
													ValaClass* _tmp45_ = NULL;
													ValaDestructor* _tmp46_ = NULL;
													ValaDestructor* _tmp47_ = NULL;
													ValaClass* _tmp51_ = NULL;
													ValaDestructor* _tmp52_ = NULL;
													_tmp45_ = cl;
													_tmp46_ = vala_class_get_static_destructor (_tmp45_);
													_tmp47_ = _tmp46_;
													if (_tmp47_ != NULL) {
														ValaDestructor* _tmp48_ = NULL;
														ValaSourceReference* _tmp49_ = NULL;
														ValaSourceReference* _tmp50_ = NULL;
														_tmp48_ = d;
														_tmp49_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp48_);
														_tmp50_ = _tmp49_;
														vala_report_error (_tmp50_, "class already contains a static destructor");
													}
													_tmp51_ = cl;
													_tmp52_ = d;
													vala_class_set_static_destructor (_tmp51_, G_TYPE_CHECK_INSTANCE_CAST (_tmp52_, VALA_TYPE_DESTRUCTOR, ValaDestructor));
												} else {
													ValaDestructor* _tmp53_ = NULL;
													ValaMemberBinding _tmp54_ = 0;
													ValaMemberBinding _tmp55_ = 0;
													_tmp53_ = d;
													_tmp54_ = vala_destructor_get_binding (_tmp53_);
													_tmp55_ = _tmp54_;
													if (_tmp55_ == VALA_MEMBER_BINDING_CLASS) {
														ValaClass* _tmp56_ = NULL;
														ValaDestructor* _tmp57_ = NULL;
														ValaDestructor* _tmp58_ = NULL;
														ValaClass* _tmp62_ = NULL;
														ValaDestructor* _tmp63_ = NULL;
														_tmp56_ = cl;
														_tmp57_ = vala_class_get_class_destructor (_tmp56_);
														_tmp58_ = _tmp57_;
														if (_tmp58_ != NULL) {
															ValaDestructor* _tmp59_ = NULL;
															ValaSourceReference* _tmp60_ = NULL;
															ValaSourceReference* _tmp61_ = NULL;
															_tmp59_ = d;
															_tmp60_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp59_);
															_tmp61_ = _tmp60_;
															vala_report_error (_tmp61_, "class already contains a class destructor");
														}
														_tmp62_ = cl;
														_tmp63_ = d;
														vala_class_set_class_destructor (_tmp62_, G_TYPE_CHECK_INSTANCE_CAST (_tmp63_, VALA_TYPE_DESTRUCTOR, ValaDestructor));
													} else {
														ValaClass* _tmp64_ = NULL;
														ValaDestructor* _tmp65_ = NULL;
														ValaDestructor* _tmp66_ = NULL;
														ValaClass* _tmp70_ = NULL;
														ValaDestructor* _tmp71_ = NULL;
														_tmp64_ = cl;
														_tmp65_ = vala_class_get_destructor (_tmp64_);
														_tmp66_ = _tmp65_;
														if (_tmp66_ != NULL) {
															ValaDestructor* _tmp67_ = NULL;
															ValaSourceReference* _tmp68_ = NULL;
															ValaSourceReference* _tmp69_ = NULL;
															_tmp67_ = d;
															_tmp68_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp67_);
															_tmp69_ = _tmp68_;
															vala_report_error (_tmp69_, "class already contains a destructor");
														}
														_tmp70_ = cl;
														_tmp71_ = d;
														vala_class_set_destructor (_tmp70_, G_TYPE_CHECK_INSTANCE_CAST (_tmp71_, VALA_TYPE_DESTRUCTOR, ValaDestructor));
													}
												}
												_vala_code_node_unref0 (d);
											} else {
												ValaSourceReference* _tmp72_ = NULL;
												ValaSourceReference* _tmp73_ = NULL;
												_tmp72_ = vala_code_node_get_source_reference ((ValaCodeNode*) sym);
												_tmp73_ = _tmp72_;
												vala_report_error (_tmp73_, "unexpected declaration in class");
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaConstant* vala_genie_parser_parse_constant_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaConstant* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	gchar* id = NULL;
	gchar* _tmp2_ = NULL;
	ValaDataType* type = NULL;
	ValaDataType* _tmp3_ = NULL;
	ValaDataType* _tmp4_ = NULL;
	ValaDataType* _tmp5_ = NULL;
	ValaDataType* _tmp6_ = NULL;
	ValaExpression* initializer = NULL;
	gboolean _tmp7_ = FALSE;
	ValaArrayType* array_type = NULL;
	ValaDataType* _tmp10_ = NULL;
	ValaArrayType* _tmp11_ = NULL;
	ValaArrayType* _tmp12_ = NULL;
	ValaConstant* c = NULL;
	const gchar* _tmp16_ = NULL;
	ValaDataType* _tmp17_ = NULL;
	ValaExpression* _tmp18_ = NULL;
	ValaSourceLocation _tmp19_ = {0};
	ValaSourceReference* _tmp20_ = NULL;
	ValaSourceReference* _tmp21_ = NULL;
	ValaComment* _tmp22_ = NULL;
	ValaConstant* _tmp23_ = NULL;
	ValaConstant* _tmp24_ = NULL;
	ValaConstant* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	ValaSymbolAccessibility _tmp27_ = 0;
	gboolean _tmp28_ = FALSE;
	ValaGenieParserModifierFlags _tmp29_ = 0;
	gboolean _tmp35_ = FALSE;
	ValaGenieParserModifierFlags _tmp37_ = 0;
	ValaConstant* _tmp39_ = NULL;
	ValaList* _tmp40_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONST, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_type (self, FALSE, FALSE, &_inner_error_);
	type = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = type;
	_tmp6_ = vala_genie_parser_parse_inline_array_type (self, _tmp5_, &_inner_error_);
	_tmp4_ = _tmp6_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_vala_code_node_unref0 (type);
	type = _tmp4_;
	initializer = NULL;
	_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp7_) {
		ValaExpression* _tmp8_ = NULL;
		ValaExpression* _tmp9_ = NULL;
		_tmp9_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp8_ = _tmp9_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (initializer);
		initializer = _tmp8_;
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp10_ = type;
	_tmp11_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, VALA_TYPE_ARRAY_TYPE) ? ((ValaArrayType*) _tmp10_) : NULL);
	array_type = _tmp11_;
	_tmp12_ = array_type;
	if (_tmp12_ != NULL) {
		ValaArrayType* _tmp13_ = NULL;
		ValaDataType* _tmp14_ = NULL;
		ValaDataType* _tmp15_ = NULL;
		_tmp13_ = array_type;
		_tmp14_ = vala_array_type_get_element_type (_tmp13_);
		_tmp15_ = _tmp14_;
		vala_data_type_set_value_owned (_tmp15_, FALSE);
	}
	_tmp16_ = id;
	_tmp17_ = type;
	_tmp18_ = initializer;
	_tmp19_ = begin;
	_tmp20_ = vala_genie_parser_get_src (self, &_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = self->priv->comment;
	_tmp23_ = vala_constant_new (_tmp16_, _tmp17_, _tmp18_, _tmp21_, _tmp22_);
	_tmp24_ = _tmp23_;
	_vala_source_reference_unref0 (_tmp21_);
	c = _tmp24_;
	_tmp25_ = c;
	_tmp26_ = id;
	_tmp27_ = vala_genie_parser_get_access (self, _tmp26_);
	vala_symbol_set_access ((ValaSymbol*) _tmp25_, _tmp27_);
	_tmp29_ = flags;
	if ((_tmp29_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp28_ = TRUE;
	} else {
		ValaGenieScanner* _tmp30_ = NULL;
		ValaSourceFile* _tmp31_ = NULL;
		ValaSourceFile* _tmp32_ = NULL;
		ValaSourceFileType _tmp33_ = 0;
		ValaSourceFileType _tmp34_ = 0;
		_tmp30_ = self->priv->scanner;
		_tmp31_ = vala_genie_scanner_get_source_file (_tmp30_);
		_tmp32_ = _tmp31_;
		_tmp33_ = vala_source_file_get_file_type (_tmp32_);
		_tmp34_ = _tmp33_;
		_tmp28_ = _tmp34_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp35_ = _tmp28_;
	if (_tmp35_) {
		ValaConstant* _tmp36_ = NULL;
		_tmp36_ = c;
		vala_symbol_set_external ((ValaSymbol*) _tmp36_, TRUE);
	}
	_tmp37_ = flags;
	if ((_tmp37_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		ValaConstant* _tmp38_ = NULL;
		_tmp38_ = c;
		vala_symbol_set_hides ((ValaSymbol*) _tmp38_, TRUE);
	}
	_tmp39_ = c;
	_tmp40_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp39_, _tmp40_);
	result = c;
	_vala_code_node_unref0 (array_type);
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaField* vala_genie_parser_parse_field_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaField* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gchar* id = NULL;
	gchar* _tmp1_ = NULL;
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp2_ = 0;
	ValaDataType* type = NULL;
	ValaDataType* _tmp3_ = NULL;
	ValaDataType* _tmp4_ = NULL;
	ValaDataType* _tmp5_ = NULL;
	ValaDataType* _tmp6_ = NULL;
	ValaField* f = NULL;
	const gchar* _tmp7_ = NULL;
	ValaDataType* _tmp8_ = NULL;
	ValaSourceLocation _tmp9_ = {0};
	ValaSourceReference* _tmp10_ = NULL;
	ValaSourceReference* _tmp11_ = NULL;
	ValaComment* _tmp12_ = NULL;
	ValaField* _tmp13_ = NULL;
	ValaField* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_ = FALSE;
	ValaGenieParserModifierFlags _tmp17_ = 0;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp21_ = FALSE;
	ValaGenieParserModifierFlags _tmp25_ = 0;
	ValaField* _tmp30_ = NULL;
	ValaList* _tmp31_ = NULL;
	gboolean _tmp32_ = FALSE;
	ValaGenieParserModifierFlags _tmp33_ = 0;
	gboolean _tmp39_ = FALSE;
	ValaGenieParserModifierFlags _tmp41_ = 0;
	gboolean _tmp43_ = FALSE;
	ValaGenieParserModifierFlags _tmp48_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp2_;
	_tmp3_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
	type = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = type;
	_tmp6_ = vala_genie_parser_parse_inline_array_type (self, _tmp5_, &_inner_error_);
	_tmp4_ = _tmp6_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_vala_code_node_unref0 (type);
	type = _tmp4_;
	_tmp7_ = id;
	_tmp8_ = type;
	_tmp9_ = begin;
	_tmp10_ = vala_genie_parser_get_src (self, &_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = self->priv->comment;
	_tmp13_ = vala_field_new (_tmp7_, _tmp8_, NULL, _tmp11_, _tmp12_);
	_tmp14_ = _tmp13_;
	_vala_source_reference_unref0 (_tmp11_);
	f = _tmp14_;
	_tmp17_ = flags;
	if ((_tmp17_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		_tmp16_ = TRUE;
	} else {
		ValaGenieParserModifierFlags _tmp18_ = 0;
		_tmp18_ = flags;
		_tmp16_ = (_tmp18_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
	}
	_tmp19_ = _tmp16_;
	if (_tmp19_) {
		_tmp15_ = TRUE;
	} else {
		ValaGenieParserModifierFlags _tmp20_ = 0;
		_tmp20_ = flags;
		_tmp15_ = (_tmp20_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
	}
	_tmp21_ = _tmp15_;
	if (_tmp21_) {
		ValaField* _tmp22_ = NULL;
		ValaSourceReference* _tmp23_ = NULL;
		ValaSourceReference* _tmp24_ = NULL;
		_tmp22_ = f;
		_tmp23_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp22_);
		_tmp24_ = _tmp23_;
		vala_report_error (_tmp24_, "abstract, virtual, and override modifiers are not applicable to fields");
	}
	_tmp25_ = flags;
	if ((_tmp25_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaField* _tmp26_ = NULL;
		_tmp26_ = f;
		vala_symbol_set_access ((ValaSymbol*) _tmp26_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaField* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		ValaSymbolAccessibility _tmp29_ = 0;
		_tmp27_ = f;
		_tmp28_ = id;
		_tmp29_ = vala_genie_parser_get_access (self, _tmp28_);
		vala_symbol_set_access ((ValaSymbol*) _tmp27_, _tmp29_);
	}
	_tmp30_ = f;
	_tmp31_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp30_, _tmp31_);
	_tmp33_ = flags;
	if ((_tmp33_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp32_ = TRUE;
	} else {
		ValaGenieScanner* _tmp34_ = NULL;
		ValaSourceFile* _tmp35_ = NULL;
		ValaSourceFile* _tmp36_ = NULL;
		ValaSourceFileType _tmp37_ = 0;
		ValaSourceFileType _tmp38_ = 0;
		_tmp34_ = self->priv->scanner;
		_tmp35_ = vala_genie_scanner_get_source_file (_tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = vala_source_file_get_file_type (_tmp36_);
		_tmp38_ = _tmp37_;
		_tmp32_ = _tmp38_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp39_ = _tmp32_;
	if (_tmp39_) {
		ValaField* _tmp40_ = NULL;
		_tmp40_ = f;
		vala_symbol_set_external ((ValaSymbol*) _tmp40_, TRUE);
	}
	_tmp41_ = flags;
	if ((_tmp41_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		ValaField* _tmp42_ = NULL;
		_tmp42_ = f;
		vala_symbol_set_hides ((ValaSymbol*) _tmp42_, TRUE);
	}
	_tmp43_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp43_) {
		ValaExpression* _tmp44_ = NULL;
		ValaExpression* _tmp45_ = NULL;
		ValaField* _tmp46_ = NULL;
		ValaExpression* _tmp47_ = NULL;
		_tmp45_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp44_ = _tmp45_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (f);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (f);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp46_ = f;
		_tmp47_ = _tmp44_;
		vala_variable_set_initializer ((ValaVariable*) _tmp46_, _tmp47_);
		_vala_code_node_unref0 (_tmp47_);
	}
	_tmp48_ = flags;
	if ((_tmp48_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		ValaField* _tmp49_ = NULL;
		_tmp49_ = f;
		vala_field_set_binding (_tmp49_, VALA_MEMBER_BINDING_STATIC);
	} else {
		ValaGenieParserModifierFlags _tmp50_ = 0;
		_tmp50_ = flags;
		if ((_tmp50_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			ValaField* _tmp51_ = NULL;
			_tmp51_ = f;
			vala_field_set_binding (_tmp51_, VALA_MEMBER_BINDING_CLASS);
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (f);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (f);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = f;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaInitializerList* vala_genie_parser_parse_initializer (ValaGenieParser* self, GError** error) {
	ValaInitializerList* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	ValaInitializerList* initializer = NULL;
	ValaSourceLocation _tmp2_ = {0};
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaInitializerList* _tmp5_ = NULL;
	ValaInitializerList* _tmp6_ = NULL;
	ValaGenieTokenType _tmp7_ = 0;
	gboolean _tmp14_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	if (!_tmp1_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp2_ = begin;
	_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_initializer_list_new (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_source_reference_unref0 (_tmp4_);
	initializer = _tmp6_;
	_tmp7_ = vala_genie_parser_current (self);
	if (_tmp7_ != VALA_GENIE_TOKEN_TYPE_DEDENT) {
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				gboolean _tmp9_ = FALSE;
				ValaExpression* init = NULL;
				ValaExpression* _tmp11_ = NULL;
				ValaInitializerList* _tmp12_ = NULL;
				ValaExpression* _tmp13_ = NULL;
				_tmp9_ = _tmp8_;
				if (!_tmp9_) {
					gboolean _tmp10_ = FALSE;
					_tmp10_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp10_) {
						break;
					}
				}
				_tmp8_ = FALSE;
				_tmp11_ = vala_genie_parser_parse_argument (self, &_inner_error_);
				init = _tmp11_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (initializer);
						return NULL;
					} else {
						_vala_code_node_unref0 (initializer);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp12_ = initializer;
				_tmp13_ = init;
				vala_initializer_list_append (_tmp12_, _tmp13_);
				_vala_code_node_unref0 (init);
			}
		}
	}
	_tmp14_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS);
	if (!_tmp14_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = initializer;
	return result;
}


static ValaMethod* vala_genie_parser_parse_main_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaMethod* result = NULL;
	gchar* id = NULL;
	gchar* _tmp0_ = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp1_ = {0};
	ValaDataType* type = NULL;
	ValaVoidType* _tmp2_ = NULL;
	ValaMethod* method = NULL;
	const gchar* _tmp3_ = NULL;
	ValaDataType* _tmp4_ = NULL;
	ValaSourceLocation _tmp5_ = {0};
	ValaSourceReference* _tmp6_ = NULL;
	ValaSourceReference* _tmp7_ = NULL;
	ValaComment* _tmp8_ = NULL;
	ValaMethod* _tmp9_ = NULL;
	ValaMethod* _tmp10_ = NULL;
	ValaMethod* _tmp11_ = NULL;
	ValaMethod* _tmp12_ = NULL;
	ValaList* _tmp13_ = NULL;
	ValaMethod* _tmp14_ = NULL;
	ValaUnresolvedSymbol* sym = NULL;
	ValaSourceLocation _tmp15_ = {0};
	ValaSourceReference* _tmp16_ = NULL;
	ValaSourceReference* _tmp17_ = NULL;
	ValaUnresolvedSymbol* _tmp18_ = NULL;
	ValaUnresolvedSymbol* _tmp19_ = NULL;
	ValaUnresolvedSymbol* _tmp20_ = NULL;
	ValaSourceLocation _tmp21_ = {0};
	ValaSourceReference* _tmp22_ = NULL;
	ValaSourceReference* _tmp23_ = NULL;
	ValaUnresolvedType* _tmp24_ = NULL;
	ValaDataType* _tmp25_ = NULL;
	ValaDataType* _tmp26_ = NULL;
	ValaSourceLocation _tmp27_ = {0};
	ValaSourceReference* _tmp28_ = NULL;
	ValaSourceReference* _tmp29_ = NULL;
	ValaArrayType* _tmp30_ = NULL;
	ValaDataType* _tmp31_ = NULL;
	ValaParameter* param = NULL;
	ValaDataType* _tmp32_ = NULL;
	ValaSourceLocation _tmp33_ = {0};
	ValaSourceReference* _tmp34_ = NULL;
	ValaSourceReference* _tmp35_ = NULL;
	ValaParameter* _tmp36_ = NULL;
	ValaParameter* _tmp37_ = NULL;
	ValaMethod* _tmp38_ = NULL;
	ValaParameter* _tmp39_ = NULL;
	gboolean _tmp40_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("main");
	id = _tmp0_;
	vala_genie_parser_get_location (self, &_tmp1_);
	begin = _tmp1_;
	_tmp2_ = vala_void_type_new (NULL);
	type = (ValaDataType*) _tmp2_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INIT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = id;
	_tmp4_ = type;
	_tmp5_ = begin;
	_tmp6_ = vala_genie_parser_get_src (self, &_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = self->priv->comment;
	_tmp9_ = vala_method_new (_tmp3_, _tmp4_, _tmp7_, _tmp8_);
	_tmp10_ = _tmp9_;
	_vala_source_reference_unref0 (_tmp7_);
	method = _tmp10_;
	_tmp11_ = method;
	vala_symbol_set_access ((ValaSymbol*) _tmp11_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
	_tmp12_ = method;
	_tmp13_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp12_, _tmp13_);
	_tmp14_ = method;
	vala_method_set_binding (_tmp14_, VALA_MEMBER_BINDING_STATIC);
	_tmp15_ = begin;
	_tmp16_ = vala_genie_parser_get_src (self, &_tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = vala_unresolved_symbol_new (NULL, "string", _tmp17_);
	_tmp19_ = _tmp18_;
	_vala_source_reference_unref0 (_tmp17_);
	sym = _tmp19_;
	_tmp20_ = sym;
	_tmp21_ = begin;
	_tmp22_ = vala_genie_parser_get_src (self, &_tmp21_);
	_tmp23_ = _tmp22_;
	_tmp24_ = vala_unresolved_type_new_from_symbol (_tmp20_, _tmp23_);
	_vala_code_node_unref0 (type);
	type = (ValaDataType*) _tmp24_;
	_vala_source_reference_unref0 (_tmp23_);
	_tmp25_ = type;
	vala_data_type_set_value_owned (_tmp25_, TRUE);
	_tmp26_ = type;
	_tmp27_ = begin;
	_tmp28_ = vala_genie_parser_get_src (self, &_tmp27_);
	_tmp29_ = _tmp28_;
	_tmp30_ = vala_array_type_new (_tmp26_, 1, _tmp29_);
	_vala_code_node_unref0 (type);
	type = (ValaDataType*) _tmp30_;
	_vala_source_reference_unref0 (_tmp29_);
	_tmp31_ = type;
	vala_data_type_set_nullable (_tmp31_, FALSE);
	_tmp32_ = type;
	_tmp33_ = begin;
	_tmp34_ = vala_genie_parser_get_src (self, &_tmp33_);
	_tmp35_ = _tmp34_;
	_tmp36_ = vala_parameter_new ("args", _tmp32_, _tmp35_);
	_tmp37_ = _tmp36_;
	_vala_source_reference_unref0 (_tmp35_);
	param = _tmp37_;
	_tmp38_ = method;
	_tmp39_ = param;
	vala_method_add_parameter (_tmp38_, _tmp39_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (param);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (param);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp40_ = vala_genie_parser_accept_block (self);
	if (_tmp40_) {
		ValaBlock* _tmp41_ = NULL;
		ValaBlock* _tmp42_ = NULL;
		ValaMethod* _tmp43_ = NULL;
		ValaBlock* _tmp44_ = NULL;
		_tmp42_ = vala_genie_parser_parse_block (self, &_inner_error_);
		_tmp41_ = _tmp42_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp43_ = method;
		_tmp44_ = _tmp41_;
		vala_subroutine_set_body ((ValaSubroutine*) _tmp43_, _tmp44_);
		_vala_code_node_unref0 (_tmp44_);
	}
	result = method;
	_vala_code_node_unref0 (param);
	_vala_code_node_unref0 (sym);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaMethod* vala_genie_parser_parse_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaMethod* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	ValaVoidType* _tmp1_ = NULL;
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp2_ = 0;
	gchar* id = NULL;
	gchar* _tmp3_ = NULL;
	ValaArrayList* params = NULL;
	GEqualFunc _tmp4_ = NULL;
	ValaArrayList* _tmp5_ = NULL;
	ValaGenieTokenType _tmp6_ = 0;
	gboolean _tmp13_ = FALSE;
	ValaList* type_param_list = NULL;
	ValaList* _tmp16_ = NULL;
	ValaMethod* method = NULL;
	const gchar* _tmp17_ = NULL;
	ValaDataType* _tmp18_ = NULL;
	ValaSourceLocation _tmp19_ = {0};
	ValaSourceReference* _tmp20_ = NULL;
	ValaSourceReference* _tmp21_ = NULL;
	ValaComment* _tmp22_ = NULL;
	ValaMethod* _tmp23_ = NULL;
	ValaMethod* _tmp24_ = NULL;
	ValaGenieParserModifierFlags _tmp25_ = 0;
	ValaMethod* _tmp30_ = NULL;
	ValaList* _tmp31_ = NULL;
	gboolean _tmp58_ = FALSE;
	gboolean _tmp66_ = FALSE;
	ValaGenieParserModifierFlags _tmp67_ = 0;
	gboolean _tmp69_ = FALSE;
	ValaGenieParserModifierFlags _tmp73_ = 0;
	ValaGenieParserModifierFlags _tmp75_ = 0;
	ValaMethod* _tmp77_ = NULL;
	ValaMemberBinding _tmp78_ = 0;
	ValaMemberBinding _tmp79_ = 0;
	ValaGenieParserModifierFlags _tmp129_ = 0;
	ValaGenieParserModifierFlags _tmp131_ = 0;
	ValaSourceLocation body_location = {0};
	ValaSourceLocation _tmp133_ = {0};
	gboolean _tmp134_ = FALSE;
	ValaSourceLocation _tmp163_ = {0};
	gboolean _tmp164_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_void_type_new (NULL);
	type = (ValaDataType*) _tmp1_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp2_;
	_tmp3_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = g_direct_equal;
	_tmp5_ = vala_array_list_new (VALA_TYPE_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp4_);
	params = _tmp5_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp6_ = vala_genie_parser_current (self);
	if (_tmp6_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_ = FALSE;
				ValaParameter* param = NULL;
				ValaParameter* _tmp10_ = NULL;
				ValaArrayList* _tmp11_ = NULL;
				ValaParameter* _tmp12_ = NULL;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gboolean _tmp9_ = FALSE;
					_tmp9_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp9_) {
						break;
					}
				}
				_tmp7_ = FALSE;
				_tmp10_ = vala_genie_parser_parse_parameter (self, &_inner_error_);
				param = _tmp10_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp11_ = params;
				_tmp12_ = param;
				vala_collection_add ((ValaCollection*) _tmp11_, _tmp12_);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp13_) {
		ValaDataType* _tmp14_ = NULL;
		ValaDataType* _tmp15_ = NULL;
		_tmp15_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		_tmp14_ = _tmp15_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (type);
		type = _tmp14_;
	}
	_tmp16_ = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	type_param_list = _tmp16_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp17_ = id;
	_tmp18_ = type;
	_tmp19_ = begin;
	_tmp20_ = vala_genie_parser_get_src (self, &_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = self->priv->comment;
	_tmp23_ = vala_method_new (_tmp17_, _tmp18_, _tmp21_, _tmp22_);
	_tmp24_ = _tmp23_;
	_vala_source_reference_unref0 (_tmp21_);
	method = _tmp24_;
	_tmp25_ = flags;
	if ((_tmp25_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaMethod* _tmp26_ = NULL;
		_tmp26_ = method;
		vala_symbol_set_access ((ValaSymbol*) _tmp26_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaMethod* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		ValaSymbolAccessibility _tmp29_ = 0;
		_tmp27_ = method;
		_tmp28_ = id;
		_tmp29_ = vala_genie_parser_get_access (self, _tmp28_);
		vala_symbol_set_access ((ValaSymbol*) _tmp27_, _tmp29_);
	}
	_tmp30_ = method;
	_tmp31_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp30_, _tmp31_);
	{
		ValaList* _type_param_list = NULL;
		ValaList* _tmp32_ = NULL;
		ValaList* _tmp33_ = NULL;
		gint _type_param_size = 0;
		ValaList* _tmp34_ = NULL;
		gint _tmp35_ = 0;
		gint _tmp36_ = 0;
		gint _type_param_index = 0;
		_tmp32_ = type_param_list;
		_tmp33_ = _vala_iterable_ref0 (_tmp32_);
		_type_param_list = _tmp33_;
		_tmp34_ = _type_param_list;
		_tmp35_ = vala_collection_get_size ((ValaCollection*) _tmp34_);
		_tmp36_ = _tmp35_;
		_type_param_size = _tmp36_;
		_type_param_index = -1;
		while (TRUE) {
			gint _tmp37_ = 0;
			gint _tmp38_ = 0;
			gint _tmp39_ = 0;
			ValaTypeParameter* type_param = NULL;
			ValaList* _tmp40_ = NULL;
			gint _tmp41_ = 0;
			gpointer _tmp42_ = NULL;
			ValaMethod* _tmp43_ = NULL;
			ValaTypeParameter* _tmp44_ = NULL;
			_tmp37_ = _type_param_index;
			_type_param_index = _tmp37_ + 1;
			_tmp38_ = _type_param_index;
			_tmp39_ = _type_param_size;
			if (!(_tmp38_ < _tmp39_)) {
				break;
			}
			_tmp40_ = _type_param_list;
			_tmp41_ = _type_param_index;
			_tmp42_ = vala_list_get (_tmp40_, _tmp41_);
			type_param = (ValaTypeParameter*) _tmp42_;
			_tmp43_ = method;
			_tmp44_ = type_param;
			vala_method_add_type_parameter (_tmp43_, _tmp44_);
			_vala_code_node_unref0 (type_param);
		}
		_vala_iterable_unref0 (_type_param_list);
	}
	{
		ValaArrayList* _param_list = NULL;
		ValaArrayList* _tmp45_ = NULL;
		ValaArrayList* _tmp46_ = NULL;
		gint _param_size = 0;
		ValaArrayList* _tmp47_ = NULL;
		gint _tmp48_ = 0;
		gint _tmp49_ = 0;
		gint _param_index = 0;
		_tmp45_ = params;
		_tmp46_ = _vala_iterable_ref0 (_tmp45_);
		_param_list = _tmp46_;
		_tmp47_ = _param_list;
		_tmp48_ = vala_collection_get_size ((ValaCollection*) _tmp47_);
		_tmp49_ = _tmp48_;
		_param_size = _tmp49_;
		_param_index = -1;
		while (TRUE) {
			gint _tmp50_ = 0;
			gint _tmp51_ = 0;
			gint _tmp52_ = 0;
			ValaParameter* param = NULL;
			ValaArrayList* _tmp53_ = NULL;
			gint _tmp54_ = 0;
			gpointer _tmp55_ = NULL;
			ValaMethod* _tmp56_ = NULL;
			ValaParameter* _tmp57_ = NULL;
			_tmp50_ = _param_index;
			_param_index = _tmp50_ + 1;
			_tmp51_ = _param_index;
			_tmp52_ = _param_size;
			if (!(_tmp51_ < _tmp52_)) {
				break;
			}
			_tmp53_ = _param_list;
			_tmp54_ = _param_index;
			_tmp55_ = vala_list_get ((ValaList*) _tmp53_, _tmp54_);
			param = (ValaParameter*) _tmp55_;
			_tmp56_ = method;
			_tmp57_ = param;
			vala_method_add_parameter (_tmp56_, _tmp57_);
			_vala_code_node_unref0 (param);
		}
		_vala_iterable_unref0 (_param_list);
	}
	_tmp58_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES);
	if (_tmp58_) {
		{
			gboolean _tmp59_ = FALSE;
			_tmp59_ = TRUE;
			while (TRUE) {
				gboolean _tmp60_ = FALSE;
				ValaDataType* _tmp62_ = NULL;
				ValaDataType* _tmp63_ = NULL;
				ValaMethod* _tmp64_ = NULL;
				ValaDataType* _tmp65_ = NULL;
				_tmp60_ = _tmp59_;
				if (!_tmp60_) {
					gboolean _tmp61_ = FALSE;
					_tmp61_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp61_) {
						break;
					}
				}
				_tmp59_ = FALSE;
				_tmp63_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				_tmp62_ = _tmp63_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp64_ = method;
				_tmp65_ = _tmp62_;
				vala_code_node_add_error_type ((ValaCodeNode*) _tmp64_, _tmp65_);
				_vala_code_node_unref0 (_tmp65_);
			}
		}
	}
	_tmp67_ = flags;
	if ((_tmp67_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		_tmp66_ = TRUE;
	} else {
		const gchar* _tmp68_ = NULL;
		_tmp68_ = id;
		_tmp66_ = g_strcmp0 (_tmp68_, "main") == 0;
	}
	_tmp69_ = _tmp66_;
	if (_tmp69_) {
		ValaMethod* _tmp70_ = NULL;
		_tmp70_ = method;
		vala_method_set_binding (_tmp70_, VALA_MEMBER_BINDING_STATIC);
	} else {
		ValaGenieParserModifierFlags _tmp71_ = 0;
		_tmp71_ = flags;
		if ((_tmp71_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			ValaMethod* _tmp72_ = NULL;
			_tmp72_ = method;
			vala_method_set_binding (_tmp72_, VALA_MEMBER_BINDING_CLASS);
		}
	}
	_tmp73_ = flags;
	if ((_tmp73_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) {
		ValaMethod* _tmp74_ = NULL;
		_tmp74_ = method;
		vala_method_set_coroutine (_tmp74_, TRUE);
	}
	_tmp75_ = flags;
	if ((_tmp75_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		ValaMethod* _tmp76_ = NULL;
		_tmp76_ = method;
		vala_symbol_set_hides ((ValaSymbol*) _tmp76_, TRUE);
	}
	_tmp77_ = method;
	_tmp78_ = vala_method_get_binding (_tmp77_);
	_tmp79_ = _tmp78_;
	if (_tmp79_ == VALA_MEMBER_BINDING_INSTANCE) {
		ValaGenieParserModifierFlags _tmp80_ = 0;
		ValaGenieParserModifierFlags _tmp82_ = 0;
		ValaGenieParserModifierFlags _tmp84_ = 0;
		gboolean _tmp86_ = FALSE;
		gboolean _tmp87_ = FALSE;
		gboolean _tmp88_ = FALSE;
		ValaMethod* _tmp89_ = NULL;
		gboolean _tmp90_ = FALSE;
		gboolean _tmp91_ = FALSE;
		gboolean _tmp95_ = FALSE;
		gboolean _tmp104_ = FALSE;
		gboolean _tmp113_ = FALSE;
		_tmp80_ = flags;
		if ((_tmp80_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			ValaMethod* _tmp81_ = NULL;
			_tmp81_ = method;
			vala_method_set_is_abstract (_tmp81_, TRUE);
		}
		_tmp82_ = flags;
		if ((_tmp82_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
			ValaMethod* _tmp83_ = NULL;
			_tmp83_ = method;
			vala_method_set_is_virtual (_tmp83_, TRUE);
		}
		_tmp84_ = flags;
		if ((_tmp84_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) {
			ValaMethod* _tmp85_ = NULL;
			_tmp85_ = method;
			vala_method_set_overrides (_tmp85_, TRUE);
		}
		_tmp89_ = method;
		_tmp90_ = vala_method_get_is_abstract (_tmp89_);
		_tmp91_ = _tmp90_;
		if (_tmp91_) {
			ValaMethod* _tmp92_ = NULL;
			gboolean _tmp93_ = FALSE;
			gboolean _tmp94_ = FALSE;
			_tmp92_ = method;
			_tmp93_ = vala_method_get_is_virtual (_tmp92_);
			_tmp94_ = _tmp93_;
			_tmp88_ = _tmp94_;
		} else {
			_tmp88_ = FALSE;
		}
		_tmp95_ = _tmp88_;
		if (_tmp95_) {
			_tmp87_ = TRUE;
		} else {
			gboolean _tmp96_ = FALSE;
			ValaMethod* _tmp97_ = NULL;
			gboolean _tmp98_ = FALSE;
			gboolean _tmp99_ = FALSE;
			gboolean _tmp103_ = FALSE;
			_tmp97_ = method;
			_tmp98_ = vala_method_get_is_abstract (_tmp97_);
			_tmp99_ = _tmp98_;
			if (_tmp99_) {
				ValaMethod* _tmp100_ = NULL;
				gboolean _tmp101_ = FALSE;
				gboolean _tmp102_ = FALSE;
				_tmp100_ = method;
				_tmp101_ = vala_method_get_overrides (_tmp100_);
				_tmp102_ = _tmp101_;
				_tmp96_ = _tmp102_;
			} else {
				_tmp96_ = FALSE;
			}
			_tmp103_ = _tmp96_;
			_tmp87_ = _tmp103_;
		}
		_tmp104_ = _tmp87_;
		if (_tmp104_) {
			_tmp86_ = TRUE;
		} else {
			gboolean _tmp105_ = FALSE;
			ValaMethod* _tmp106_ = NULL;
			gboolean _tmp107_ = FALSE;
			gboolean _tmp108_ = FALSE;
			gboolean _tmp112_ = FALSE;
			_tmp106_ = method;
			_tmp107_ = vala_method_get_is_virtual (_tmp106_);
			_tmp108_ = _tmp107_;
			if (_tmp108_) {
				ValaMethod* _tmp109_ = NULL;
				gboolean _tmp110_ = FALSE;
				gboolean _tmp111_ = FALSE;
				_tmp109_ = method;
				_tmp110_ = vala_method_get_overrides (_tmp109_);
				_tmp111_ = _tmp110_;
				_tmp105_ = _tmp111_;
			} else {
				_tmp105_ = FALSE;
			}
			_tmp112_ = _tmp105_;
			_tmp86_ = _tmp112_;
		}
		_tmp113_ = _tmp86_;
		if (_tmp113_) {
			gchar* _tmp114_ = NULL;
			gchar* _tmp115_ = NULL;
			GError* _tmp116_ = NULL;
			GError* _tmp117_ = NULL;
			_tmp114_ = vala_genie_parser_get_error (self, "only one of `abstract', `virtual', or `override' may be specified");
			_tmp115_ = _tmp114_;
			_tmp116_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp115_);
			_tmp117_ = _tmp116_;
			_g_free0 (_tmp115_);
			_inner_error_ = _tmp117_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		gboolean _tmp118_ = FALSE;
		gboolean _tmp119_ = FALSE;
		ValaGenieParserModifierFlags _tmp120_ = 0;
		gboolean _tmp122_ = FALSE;
		gboolean _tmp124_ = FALSE;
		_tmp120_ = flags;
		if ((_tmp120_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			_tmp119_ = TRUE;
		} else {
			ValaGenieParserModifierFlags _tmp121_ = 0;
			_tmp121_ = flags;
			_tmp119_ = (_tmp121_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
		}
		_tmp122_ = _tmp119_;
		if (_tmp122_) {
			_tmp118_ = TRUE;
		} else {
			ValaGenieParserModifierFlags _tmp123_ = 0;
			_tmp123_ = flags;
			_tmp118_ = (_tmp123_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
		}
		_tmp124_ = _tmp118_;
		if (_tmp124_) {
			gchar* _tmp125_ = NULL;
			gchar* _tmp126_ = NULL;
			GError* _tmp127_ = NULL;
			GError* _tmp128_ = NULL;
			_tmp125_ = vala_genie_parser_get_error (self, "the modifiers `abstract', `virtual', and `override' are not valid for " \
"static methods");
			_tmp126_ = _tmp125_;
			_tmp127_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp126_);
			_tmp128_ = _tmp127_;
			_g_free0 (_tmp126_);
			_inner_error_ = _tmp128_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp129_ = flags;
	if ((_tmp129_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE) {
		ValaMethod* _tmp130_ = NULL;
		_tmp130_ = method;
		vala_method_set_is_inline (_tmp130_, TRUE);
	}
	_tmp131_ = flags;
	if ((_tmp131_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		ValaMethod* _tmp132_ = NULL;
		_tmp132_ = method;
		vala_symbol_set_external ((ValaSymbol*) _tmp132_, TRUE);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_iterable_unref0 (type_param_list);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_iterable_unref0 (type_param_list);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_get_location (self, &_tmp133_);
	body_location = _tmp133_;
	_tmp134_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
	if (_tmp134_) {
		gboolean _tmp135_ = FALSE;
		gboolean _tmp149_ = FALSE;
		_tmp135_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REQUIRES);
		if (_tmp135_) {
			gboolean _tmp136_ = FALSE;
			gboolean _tmp137_ = FALSE;
			gboolean _tmp139_ = FALSE;
			_tmp137_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
			if (_tmp137_) {
				gboolean _tmp138_ = FALSE;
				_tmp138_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
				_tmp136_ = _tmp138_;
			} else {
				_tmp136_ = FALSE;
			}
			_tmp139_ = _tmp136_;
			if (_tmp139_) {
				while (TRUE) {
					ValaGenieTokenType _tmp140_ = 0;
					ValaExpression* _tmp141_ = NULL;
					ValaExpression* _tmp142_ = NULL;
					ValaMethod* _tmp143_ = NULL;
					ValaExpression* _tmp144_ = NULL;
					_tmp140_ = vala_genie_parser_current (self);
					if (!(_tmp140_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
						break;
					}
					_tmp142_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					_tmp141_ = _tmp142_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp143_ = method;
					_tmp144_ = _tmp141_;
					vala_method_add_precondition (_tmp143_, _tmp144_);
					_vala_code_node_unref0 (_tmp144_);
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_genie_parser_accept_terminator (self);
			} else {
				ValaExpression* _tmp145_ = NULL;
				ValaExpression* _tmp146_ = NULL;
				ValaMethod* _tmp147_ = NULL;
				ValaExpression* _tmp148_ = NULL;
				_tmp146_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				_tmp145_ = _tmp146_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp147_ = method;
				_tmp148_ = _tmp145_;
				vala_method_add_precondition (_tmp147_, _tmp148_);
				_vala_code_node_unref0 (_tmp148_);
				vala_genie_parser_expect_terminator (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
		_tmp149_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ENSURES);
		if (_tmp149_) {
			gboolean _tmp150_ = FALSE;
			gboolean _tmp151_ = FALSE;
			gboolean _tmp153_ = FALSE;
			_tmp151_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
			if (_tmp151_) {
				gboolean _tmp152_ = FALSE;
				_tmp152_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
				_tmp150_ = _tmp152_;
			} else {
				_tmp150_ = FALSE;
			}
			_tmp153_ = _tmp150_;
			if (_tmp153_) {
				while (TRUE) {
					ValaGenieTokenType _tmp154_ = 0;
					ValaExpression* _tmp155_ = NULL;
					ValaExpression* _tmp156_ = NULL;
					ValaMethod* _tmp157_ = NULL;
					ValaExpression* _tmp158_ = NULL;
					_tmp154_ = vala_genie_parser_current (self);
					if (!(_tmp154_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
						break;
					}
					_tmp156_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					_tmp155_ = _tmp156_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp157_ = method;
					_tmp158_ = _tmp155_;
					vala_method_add_postcondition (_tmp157_, _tmp158_);
					_vala_code_node_unref0 (_tmp158_);
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_iterable_unref0 (type_param_list);
							_vala_iterable_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_genie_parser_accept_terminator (self);
			} else {
				ValaExpression* _tmp159_ = NULL;
				ValaExpression* _tmp160_ = NULL;
				ValaMethod* _tmp161_ = NULL;
				ValaExpression* _tmp162_ = NULL;
				_tmp160_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				_tmp159_ = _tmp160_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp161_ = method;
				_tmp162_ = _tmp159_;
				vala_method_add_postcondition (_tmp161_, _tmp162_);
				_vala_code_node_unref0 (_tmp162_);
				vala_genie_parser_expect_terminator (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_iterable_unref0 (type_param_list);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
	}
	_tmp163_ = body_location;
	vala_genie_parser_rollback (self, &_tmp163_);
	_tmp164_ = vala_genie_parser_accept_block (self);
	if (_tmp164_) {
		ValaBlock* _tmp165_ = NULL;
		ValaBlock* _tmp166_ = NULL;
		ValaMethod* _tmp167_ = NULL;
		ValaBlock* _tmp168_ = NULL;
		_tmp166_ = vala_genie_parser_parse_block (self, &_inner_error_);
		_tmp165_ = _tmp166_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_iterable_unref0 (type_param_list);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp167_ = method;
		_tmp168_ = _tmp165_;
		vala_subroutine_set_body ((ValaSubroutine*) _tmp167_, _tmp168_);
		_vala_code_node_unref0 (_tmp168_);
	} else {
		ValaGenieScanner* _tmp169_ = NULL;
		ValaSourceFile* _tmp170_ = NULL;
		ValaSourceFile* _tmp171_ = NULL;
		ValaSourceFileType _tmp172_ = 0;
		ValaSourceFileType _tmp173_ = 0;
		_tmp169_ = self->priv->scanner;
		_tmp170_ = vala_genie_scanner_get_source_file (_tmp169_);
		_tmp171_ = _tmp170_;
		_tmp172_ = vala_source_file_get_file_type (_tmp171_);
		_tmp173_ = _tmp172_;
		if (_tmp173_ == VALA_SOURCE_FILE_TYPE_PACKAGE) {
			ValaMethod* _tmp174_ = NULL;
			_tmp174_ = method;
			vala_symbol_set_external ((ValaSymbol*) _tmp174_, TRUE);
		}
	}
	result = method;
	_vala_iterable_unref0 (type_param_list);
	_vala_iterable_unref0 (params);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaProperty* vala_genie_parser_parse_property_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaProperty* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean readonly = FALSE;
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	gchar* id = NULL;
	gchar* _tmp3_ = NULL;
	ValaDataType* type = NULL;
	ValaDataType* _tmp4_ = NULL;
	ValaProperty* prop = NULL;
	const gchar* _tmp5_ = NULL;
	ValaDataType* _tmp6_ = NULL;
	ValaSourceLocation _tmp7_ = {0};
	ValaSourceReference* _tmp8_ = NULL;
	ValaSourceReference* _tmp9_ = NULL;
	ValaComment* _tmp10_ = NULL;
	ValaProperty* _tmp11_ = NULL;
	ValaProperty* _tmp12_ = NULL;
	ValaGenieParserModifierFlags _tmp13_ = 0;
	ValaProperty* _tmp18_ = NULL;
	ValaList* _tmp19_ = NULL;
	ValaGenieParserModifierFlags _tmp20_ = 0;
	ValaGenieParserModifierFlags _tmp24_ = 0;
	ValaGenieParserModifierFlags _tmp26_ = 0;
	ValaGenieParserModifierFlags _tmp28_ = 0;
	ValaGenieParserModifierFlags _tmp30_ = 0;
	gboolean _tmp32_ = FALSE;
	ValaGenieParserModifierFlags _tmp33_ = 0;
	gboolean _tmp39_ = FALSE;
	ValaGenieParserModifierFlags _tmp41_ = 0;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp50_ = FALSE;
	gboolean _tmp153_ = FALSE;
	ValaProperty* _tmp154_ = NULL;
	gboolean _tmp155_ = FALSE;
	gboolean _tmp156_ = FALSE;
	gboolean _tmp162_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	readonly = FALSE;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_PROP, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_READONLY);
	readonly = _tmp2_;
	_tmp3_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
	type = _tmp4_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = id;
	_tmp6_ = type;
	_tmp7_ = begin;
	_tmp8_ = vala_genie_parser_get_src (self, &_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = self->priv->comment;
	_tmp11_ = vala_property_new (_tmp5_, _tmp6_, NULL, NULL, _tmp9_, _tmp10_);
	_tmp12_ = _tmp11_;
	_vala_source_reference_unref0 (_tmp9_);
	prop = _tmp12_;
	_tmp13_ = flags;
	if ((_tmp13_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaProperty* _tmp14_ = NULL;
		_tmp14_ = prop;
		vala_symbol_set_access ((ValaSymbol*) _tmp14_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaProperty* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		ValaSymbolAccessibility _tmp17_ = 0;
		_tmp15_ = prop;
		_tmp16_ = id;
		_tmp17_ = vala_genie_parser_get_access (self, _tmp16_);
		vala_symbol_set_access ((ValaSymbol*) _tmp15_, _tmp17_);
	}
	_tmp18_ = prop;
	_tmp19_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp18_, _tmp19_);
	_tmp20_ = flags;
	if ((_tmp20_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		ValaProperty* _tmp21_ = NULL;
		_tmp21_ = prop;
		vala_property_set_binding (_tmp21_, VALA_MEMBER_BINDING_STATIC);
	} else {
		ValaGenieParserModifierFlags _tmp22_ = 0;
		_tmp22_ = flags;
		if ((_tmp22_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			ValaProperty* _tmp23_ = NULL;
			_tmp23_ = prop;
			vala_property_set_binding (_tmp23_, VALA_MEMBER_BINDING_CLASS);
		}
	}
	_tmp24_ = flags;
	if ((_tmp24_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		ValaProperty* _tmp25_ = NULL;
		_tmp25_ = prop;
		vala_property_set_is_abstract (_tmp25_, TRUE);
	}
	_tmp26_ = flags;
	if ((_tmp26_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		ValaProperty* _tmp27_ = NULL;
		_tmp27_ = prop;
		vala_property_set_is_virtual (_tmp27_, TRUE);
	}
	_tmp28_ = flags;
	if ((_tmp28_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) {
		ValaProperty* _tmp29_ = NULL;
		_tmp29_ = prop;
		vala_property_set_overrides (_tmp29_, TRUE);
	}
	_tmp30_ = flags;
	if ((_tmp30_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		ValaProperty* _tmp31_ = NULL;
		_tmp31_ = prop;
		vala_symbol_set_hides ((ValaSymbol*) _tmp31_, TRUE);
	}
	_tmp33_ = flags;
	if ((_tmp33_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp32_ = TRUE;
	} else {
		ValaGenieScanner* _tmp34_ = NULL;
		ValaSourceFile* _tmp35_ = NULL;
		ValaSourceFile* _tmp36_ = NULL;
		ValaSourceFileType _tmp37_ = 0;
		ValaSourceFileType _tmp38_ = 0;
		_tmp34_ = self->priv->scanner;
		_tmp35_ = vala_genie_scanner_get_source_file (_tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = vala_source_file_get_file_type (_tmp36_);
		_tmp38_ = _tmp37_;
		_tmp32_ = _tmp38_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp39_ = _tmp32_;
	if (_tmp39_) {
		ValaProperty* _tmp40_ = NULL;
		_tmp40_ = prop;
		vala_symbol_set_external ((ValaSymbol*) _tmp40_, TRUE);
	}
	_tmp41_ = flags;
	if ((_tmp41_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) {
		ValaProperty* _tmp42_ = NULL;
		ValaSourceReference* _tmp43_ = NULL;
		ValaSourceReference* _tmp44_ = NULL;
		_tmp42_ = prop;
		_tmp43_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp42_);
		_tmp44_ = _tmp43_;
		vala_report_error (_tmp44_, "async properties are not supported yet");
	}
	_tmp45_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp45_) {
		ValaExpression* _tmp46_ = NULL;
		ValaExpression* _tmp47_ = NULL;
		ValaProperty* _tmp48_ = NULL;
		ValaExpression* _tmp49_ = NULL;
		_tmp47_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp46_ = _tmp47_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp48_ = prop;
		_tmp49_ = _tmp46_;
		vala_property_set_initializer (_tmp48_, _tmp49_);
		_vala_code_node_unref0 (_tmp49_);
	}
	_tmp50_ = vala_genie_parser_accept_block (self);
	if (_tmp50_) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		while (TRUE) {
			ValaGenieTokenType _tmp51_ = 0;
			ValaSourceLocation accessor_begin = {0};
			ValaSourceLocation _tmp52_ = {0};
			ValaList* attribs = NULL;
			ValaList* _tmp53_ = NULL;
			ValaDataType* value_type = NULL;
			ValaDataType* _tmp54_ = NULL;
			ValaDataType* _tmp55_ = NULL;
			ValaDataType* _tmp56_ = NULL;
			gboolean _tmp57_ = FALSE;
			gboolean _tmp58_ = FALSE;
			_tmp51_ = vala_genie_parser_current (self);
			if (!(_tmp51_ != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
				break;
			}
			vala_genie_parser_get_location (self, &_tmp52_);
			accessor_begin = _tmp52_;
			_tmp53_ = vala_genie_parser_parse_attributes (self, FALSE, &_inner_error_);
			attribs = _tmp53_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp54_ = type;
			_tmp55_ = vala_data_type_copy (_tmp54_);
			value_type = _tmp55_;
			_tmp56_ = value_type;
			_tmp57_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED);
			vala_data_type_set_value_owned (_tmp56_, _tmp57_);
			_tmp58_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_GET);
			if (_tmp58_) {
				ValaProperty* _tmp59_ = NULL;
				ValaPropertyAccessor* _tmp60_ = NULL;
				ValaPropertyAccessor* _tmp61_ = NULL;
				ValaBlock* block = NULL;
				gboolean _tmp66_ = FALSE;
				ValaProperty* _tmp70_ = NULL;
				ValaDataType* _tmp71_ = NULL;
				ValaBlock* _tmp72_ = NULL;
				ValaSourceLocation _tmp73_ = {0};
				ValaSourceReference* _tmp74_ = NULL;
				ValaSourceReference* _tmp75_ = NULL;
				ValaPropertyAccessor* _tmp76_ = NULL;
				ValaPropertyAccessor* _tmp77_ = NULL;
				ValaProperty* _tmp78_ = NULL;
				ValaPropertyAccessor* _tmp79_ = NULL;
				ValaPropertyAccessor* _tmp80_ = NULL;
				ValaList* _tmp81_ = NULL;
				ValaProperty* _tmp82_ = NULL;
				ValaPropertyAccessor* _tmp83_ = NULL;
				ValaPropertyAccessor* _tmp84_ = NULL;
				_tmp59_ = prop;
				_tmp60_ = vala_property_get_get_accessor (_tmp59_);
				_tmp61_ = _tmp60_;
				if (_tmp61_ != NULL) {
					gchar* _tmp62_ = NULL;
					gchar* _tmp63_ = NULL;
					GError* _tmp64_ = NULL;
					GError* _tmp65_ = NULL;
					_tmp62_ = vala_genie_parser_get_error (self, "property get accessor already defined");
					_tmp63_ = _tmp62_;
					_tmp64_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp63_);
					_tmp65_ = _tmp64_;
					_g_free0 (_tmp63_);
					_inner_error_ = _tmp65_;
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (value_type);
						_vala_iterable_unref0 (attribs);
						_vala_code_node_unref0 (prop);
						_vala_code_node_unref0 (type);
						_g_free0 (id);
						return NULL;
					} else {
						_vala_code_node_unref0 (value_type);
						_vala_iterable_unref0 (attribs);
						_vala_code_node_unref0 (prop);
						_vala_code_node_unref0 (type);
						_g_free0 (id);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				block = NULL;
				_tmp66_ = vala_genie_parser_accept_block (self);
				if (_tmp66_) {
					ValaBlock* _tmp67_ = NULL;
					ValaBlock* _tmp68_ = NULL;
					ValaProperty* _tmp69_ = NULL;
					_tmp68_ = vala_genie_parser_parse_block (self, &_inner_error_);
					_tmp67_ = _tmp68_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_vala_code_node_unref0 (block);
					block = _tmp67_;
					_tmp69_ = prop;
					vala_symbol_set_external ((ValaSymbol*) _tmp69_, FALSE);
				}
				_tmp70_ = prop;
				_tmp71_ = value_type;
				_tmp72_ = block;
				_tmp73_ = accessor_begin;
				_tmp74_ = vala_genie_parser_get_src (self, &_tmp73_);
				_tmp75_ = _tmp74_;
				_tmp76_ = vala_property_accessor_new (TRUE, FALSE, FALSE, _tmp71_, _tmp72_, _tmp75_, NULL);
				_tmp77_ = _tmp76_;
				vala_property_set_get_accessor (_tmp70_, _tmp77_);
				_vala_code_node_unref0 (_tmp77_);
				_vala_source_reference_unref0 (_tmp75_);
				_tmp78_ = prop;
				_tmp79_ = vala_property_get_get_accessor (_tmp78_);
				_tmp80_ = _tmp79_;
				_tmp81_ = attribs;
				vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp80_, _tmp81_);
				_tmp82_ = prop;
				_tmp83_ = vala_property_get_get_accessor (_tmp82_);
				_tmp84_ = _tmp83_;
				vala_symbol_set_access ((ValaSymbol*) _tmp84_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
				_vala_code_node_unref0 (block);
			} else {
				gboolean _construct = FALSE;
				gboolean _tmp85_ = FALSE;
				ValaProperty* _tmp98_ = NULL;
				ValaPropertyAccessor* _tmp99_ = NULL;
				ValaPropertyAccessor* _tmp100_ = NULL;
				ValaBlock* block = NULL;
				gboolean _tmp105_ = FALSE;
				ValaProperty* _tmp109_ = NULL;
				gboolean _tmp110_ = FALSE;
				gboolean _tmp111_ = FALSE;
				ValaDataType* _tmp112_ = NULL;
				ValaBlock* _tmp113_ = NULL;
				ValaSourceLocation _tmp114_ = {0};
				ValaSourceReference* _tmp115_ = NULL;
				ValaSourceReference* _tmp116_ = NULL;
				ValaPropertyAccessor* _tmp117_ = NULL;
				ValaPropertyAccessor* _tmp118_ = NULL;
				ValaProperty* _tmp119_ = NULL;
				ValaPropertyAccessor* _tmp120_ = NULL;
				ValaPropertyAccessor* _tmp121_ = NULL;
				ValaList* _tmp122_ = NULL;
				ValaProperty* _tmp123_ = NULL;
				ValaPropertyAccessor* _tmp124_ = NULL;
				ValaPropertyAccessor* _tmp125_ = NULL;
				_construct = FALSE;
				_tmp85_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SET);
				if (_tmp85_) {
					gboolean _tmp86_ = FALSE;
					gboolean _tmp91_ = FALSE;
					_tmp86_ = readonly;
					if (_tmp86_) {
						gchar* _tmp87_ = NULL;
						gchar* _tmp88_ = NULL;
						GError* _tmp89_ = NULL;
						GError* _tmp90_ = NULL;
						_tmp87_ = vala_genie_parser_get_error (self, "set block not allowed for a read only property");
						_tmp88_ = _tmp87_;
						_tmp89_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp88_);
						_tmp90_ = _tmp89_;
						_g_free0 (_tmp88_);
						_inner_error_ = _tmp90_;
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_tmp91_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT);
					_construct = _tmp91_;
				} else {
					gboolean _tmp92_ = FALSE;
					_tmp92_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT);
					if (_tmp92_) {
						_construct = TRUE;
					} else {
						gboolean _tmp93_ = FALSE;
						_tmp93_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
						if (!_tmp93_) {
							gchar* _tmp94_ = NULL;
							gchar* _tmp95_ = NULL;
							GError* _tmp96_ = NULL;
							GError* _tmp97_ = NULL;
							_tmp94_ = vala_genie_parser_get_error (self, "expected get, set, or construct");
							_tmp95_ = _tmp94_;
							_tmp96_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp95_);
							_tmp97_ = _tmp96_;
							_g_free0 (_tmp95_);
							_inner_error_ = _tmp97_;
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (value_type);
								_vala_iterable_unref0 (attribs);
								_vala_code_node_unref0 (prop);
								_vala_code_node_unref0 (type);
								_g_free0 (id);
								return NULL;
							} else {
								_vala_code_node_unref0 (value_type);
								_vala_iterable_unref0 (attribs);
								_vala_code_node_unref0 (prop);
								_vala_code_node_unref0 (type);
								_g_free0 (id);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
					}
				}
				_tmp98_ = prop;
				_tmp99_ = vala_property_get_set_accessor (_tmp98_);
				_tmp100_ = _tmp99_;
				if (_tmp100_ != NULL) {
					gchar* _tmp101_ = NULL;
					gchar* _tmp102_ = NULL;
					GError* _tmp103_ = NULL;
					GError* _tmp104_ = NULL;
					_tmp101_ = vala_genie_parser_get_error (self, "property set accessor already defined");
					_tmp102_ = _tmp101_;
					_tmp103_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp102_);
					_tmp104_ = _tmp103_;
					_g_free0 (_tmp102_);
					_inner_error_ = _tmp104_;
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (value_type);
						_vala_iterable_unref0 (attribs);
						_vala_code_node_unref0 (prop);
						_vala_code_node_unref0 (type);
						_g_free0 (id);
						return NULL;
					} else {
						_vala_code_node_unref0 (value_type);
						_vala_iterable_unref0 (attribs);
						_vala_code_node_unref0 (prop);
						_vala_code_node_unref0 (type);
						_g_free0 (id);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				block = NULL;
				_tmp105_ = vala_genie_parser_accept_block (self);
				if (_tmp105_) {
					ValaBlock* _tmp106_ = NULL;
					ValaBlock* _tmp107_ = NULL;
					ValaProperty* _tmp108_ = NULL;
					_tmp107_ = vala_genie_parser_parse_block (self, &_inner_error_);
					_tmp106_ = _tmp107_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_iterable_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_vala_code_node_unref0 (block);
					block = _tmp106_;
					_tmp108_ = prop;
					vala_symbol_set_external ((ValaSymbol*) _tmp108_, FALSE);
				}
				_tmp109_ = prop;
				_tmp110_ = readonly;
				_tmp111_ = _construct;
				_tmp112_ = value_type;
				_tmp113_ = block;
				_tmp114_ = accessor_begin;
				_tmp115_ = vala_genie_parser_get_src (self, &_tmp114_);
				_tmp116_ = _tmp115_;
				_tmp117_ = vala_property_accessor_new (FALSE, !_tmp110_, _tmp111_, _tmp112_, _tmp113_, _tmp116_, NULL);
				_tmp118_ = _tmp117_;
				vala_property_set_set_accessor (_tmp109_, _tmp118_);
				_vala_code_node_unref0 (_tmp118_);
				_vala_source_reference_unref0 (_tmp116_);
				_tmp119_ = prop;
				_tmp120_ = vala_property_get_set_accessor (_tmp119_);
				_tmp121_ = _tmp120_;
				_tmp122_ = attribs;
				vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp121_, _tmp122_);
				_tmp123_ = prop;
				_tmp124_ = vala_property_get_set_accessor (_tmp123_);
				_tmp125_ = _tmp124_;
				vala_symbol_set_access ((ValaSymbol*) _tmp125_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
				_vala_code_node_unref0 (block);
			}
			_vala_code_node_unref0 (value_type);
			_vala_iterable_unref0 (attribs);
		}
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		ValaDataType* value_type = NULL;
		ValaDataType* _tmp126_ = NULL;
		ValaDataType* _tmp127_ = NULL;
		ValaDataType* _tmp128_ = NULL;
		ValaProperty* _tmp129_ = NULL;
		ValaDataType* _tmp130_ = NULL;
		ValaSourceLocation _tmp131_ = {0};
		ValaSourceReference* _tmp132_ = NULL;
		ValaSourceReference* _tmp133_ = NULL;
		ValaPropertyAccessor* _tmp134_ = NULL;
		ValaPropertyAccessor* _tmp135_ = NULL;
		ValaProperty* _tmp136_ = NULL;
		ValaPropertyAccessor* _tmp137_ = NULL;
		ValaPropertyAccessor* _tmp138_ = NULL;
		gboolean _tmp139_ = FALSE;
		_tmp126_ = type;
		_tmp127_ = vala_data_type_copy (_tmp126_);
		value_type = _tmp127_;
		_tmp128_ = value_type;
		vala_data_type_set_value_owned (_tmp128_, FALSE);
		_tmp129_ = prop;
		_tmp130_ = value_type;
		_tmp131_ = begin;
		_tmp132_ = vala_genie_parser_get_src (self, &_tmp131_);
		_tmp133_ = _tmp132_;
		_tmp134_ = vala_property_accessor_new (TRUE, FALSE, FALSE, _tmp130_, NULL, _tmp133_, NULL);
		_tmp135_ = _tmp134_;
		vala_property_set_get_accessor (_tmp129_, _tmp135_);
		_vala_code_node_unref0 (_tmp135_);
		_vala_source_reference_unref0 (_tmp133_);
		_tmp136_ = prop;
		_tmp137_ = vala_property_get_get_accessor (_tmp136_);
		_tmp138_ = _tmp137_;
		vala_symbol_set_access ((ValaSymbol*) _tmp138_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		_tmp139_ = readonly;
		if (!_tmp139_) {
			ValaDataType* _tmp140_ = NULL;
			ValaDataType* _tmp141_ = NULL;
			ValaDataType* _tmp142_ = NULL;
			ValaProperty* _tmp143_ = NULL;
			ValaDataType* _tmp144_ = NULL;
			ValaSourceLocation _tmp145_ = {0};
			ValaSourceReference* _tmp146_ = NULL;
			ValaSourceReference* _tmp147_ = NULL;
			ValaPropertyAccessor* _tmp148_ = NULL;
			ValaPropertyAccessor* _tmp149_ = NULL;
			ValaProperty* _tmp150_ = NULL;
			ValaPropertyAccessor* _tmp151_ = NULL;
			ValaPropertyAccessor* _tmp152_ = NULL;
			_tmp140_ = type;
			_tmp141_ = vala_data_type_copy (_tmp140_);
			_vala_code_node_unref0 (value_type);
			value_type = _tmp141_;
			_tmp142_ = value_type;
			vala_data_type_set_value_owned (_tmp142_, FALSE);
			_tmp143_ = prop;
			_tmp144_ = value_type;
			_tmp145_ = begin;
			_tmp146_ = vala_genie_parser_get_src (self, &_tmp145_);
			_tmp147_ = _tmp146_;
			_tmp148_ = vala_property_accessor_new (FALSE, TRUE, FALSE, _tmp144_, NULL, _tmp147_, NULL);
			_tmp149_ = _tmp148_;
			vala_property_set_set_accessor (_tmp143_, _tmp149_);
			_vala_code_node_unref0 (_tmp149_);
			_vala_source_reference_unref0 (_tmp147_);
			_tmp150_ = prop;
			_tmp151_ = vala_property_get_set_accessor (_tmp150_);
			_tmp152_ = _tmp151_;
			vala_symbol_set_access ((ValaSymbol*) _tmp152_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		}
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (value_type);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (value_type);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (value_type);
	}
	_tmp154_ = prop;
	_tmp155_ = vala_property_get_is_abstract (_tmp154_);
	_tmp156_ = _tmp155_;
	if (!_tmp156_) {
		ValaGenieScanner* _tmp157_ = NULL;
		ValaSourceFile* _tmp158_ = NULL;
		ValaSourceFile* _tmp159_ = NULL;
		ValaSourceFileType _tmp160_ = 0;
		ValaSourceFileType _tmp161_ = 0;
		_tmp157_ = self->priv->scanner;
		_tmp158_ = vala_genie_scanner_get_source_file (_tmp157_);
		_tmp159_ = _tmp158_;
		_tmp160_ = vala_source_file_get_file_type (_tmp159_);
		_tmp161_ = _tmp160_;
		_tmp153_ = _tmp161_ == VALA_SOURCE_FILE_TYPE_SOURCE;
	} else {
		_tmp153_ = FALSE;
	}
	_tmp162_ = _tmp153_;
	if (_tmp162_) {
		gboolean _tmp163_ = FALSE;
		gboolean _tmp164_ = FALSE;
		gboolean needs_var = FALSE;
		gboolean _tmp175_ = FALSE;
		gboolean _tmp176_ = FALSE;
		gboolean _tmp199_ = FALSE;
		_tmp164_ = readonly;
		if (_tmp164_) {
			gboolean _tmp165_ = FALSE;
			ValaProperty* _tmp166_ = NULL;
			ValaPropertyAccessor* _tmp167_ = NULL;
			ValaPropertyAccessor* _tmp168_ = NULL;
			gboolean _tmp174_ = FALSE;
			_tmp166_ = prop;
			_tmp167_ = vala_property_get_get_accessor (_tmp166_);
			_tmp168_ = _tmp167_;
			if (_tmp168_ != NULL) {
				ValaProperty* _tmp169_ = NULL;
				ValaPropertyAccessor* _tmp170_ = NULL;
				ValaPropertyAccessor* _tmp171_ = NULL;
				ValaBlock* _tmp172_ = NULL;
				ValaBlock* _tmp173_ = NULL;
				_tmp169_ = prop;
				_tmp170_ = vala_property_get_get_accessor (_tmp169_);
				_tmp171_ = _tmp170_;
				_tmp172_ = vala_subroutine_get_body ((ValaSubroutine*) _tmp171_);
				_tmp173_ = _tmp172_;
				_tmp165_ = _tmp173_ == NULL;
			} else {
				_tmp165_ = FALSE;
			}
			_tmp174_ = _tmp165_;
			_tmp163_ = _tmp174_;
		} else {
			_tmp163_ = FALSE;
		}
		_tmp175_ = _tmp163_;
		needs_var = _tmp175_;
		_tmp176_ = needs_var;
		if (!_tmp176_) {
			gboolean _tmp177_ = FALSE;
			gboolean _tmp178_ = FALSE;
			ValaProperty* _tmp179_ = NULL;
			ValaPropertyAccessor* _tmp180_ = NULL;
			ValaPropertyAccessor* _tmp181_ = NULL;
			gboolean _tmp187_ = FALSE;
			gboolean _tmp198_ = FALSE;
			_tmp179_ = prop;
			_tmp180_ = vala_property_get_get_accessor (_tmp179_);
			_tmp181_ = _tmp180_;
			if (_tmp181_ != NULL) {
				ValaProperty* _tmp182_ = NULL;
				ValaPropertyAccessor* _tmp183_ = NULL;
				ValaPropertyAccessor* _tmp184_ = NULL;
				ValaBlock* _tmp185_ = NULL;
				ValaBlock* _tmp186_ = NULL;
				_tmp182_ = prop;
				_tmp183_ = vala_property_get_get_accessor (_tmp182_);
				_tmp184_ = _tmp183_;
				_tmp185_ = vala_subroutine_get_body ((ValaSubroutine*) _tmp184_);
				_tmp186_ = _tmp185_;
				_tmp178_ = _tmp186_ == NULL;
			} else {
				_tmp178_ = FALSE;
			}
			_tmp187_ = _tmp178_;
			if (_tmp187_) {
				_tmp177_ = TRUE;
			} else {
				gboolean _tmp188_ = FALSE;
				ValaProperty* _tmp189_ = NULL;
				ValaPropertyAccessor* _tmp190_ = NULL;
				ValaPropertyAccessor* _tmp191_ = NULL;
				gboolean _tmp197_ = FALSE;
				_tmp189_ = prop;
				_tmp190_ = vala_property_get_set_accessor (_tmp189_);
				_tmp191_ = _tmp190_;
				if (_tmp191_ != NULL) {
					ValaProperty* _tmp192_ = NULL;
					ValaPropertyAccessor* _tmp193_ = NULL;
					ValaPropertyAccessor* _tmp194_ = NULL;
					ValaBlock* _tmp195_ = NULL;
					ValaBlock* _tmp196_ = NULL;
					_tmp192_ = prop;
					_tmp193_ = vala_property_get_set_accessor (_tmp192_);
					_tmp194_ = _tmp193_;
					_tmp195_ = vala_subroutine_get_body ((ValaSubroutine*) _tmp194_);
					_tmp196_ = _tmp195_;
					_tmp188_ = _tmp196_ == NULL;
				} else {
					_tmp188_ = FALSE;
				}
				_tmp197_ = _tmp188_;
				_tmp177_ = _tmp197_;
			}
			_tmp198_ = _tmp177_;
			needs_var = _tmp198_;
		}
		_tmp199_ = needs_var;
		if (_tmp199_) {
			ValaDataType* variable_type = NULL;
			ValaProperty* _tmp200_ = NULL;
			ValaDataType* _tmp201_ = NULL;
			ValaDataType* _tmp202_ = NULL;
			ValaDataType* _tmp203_ = NULL;
			ValaProperty* _tmp204_ = NULL;
			ValaProperty* _tmp205_ = NULL;
			const gchar* _tmp206_ = NULL;
			const gchar* _tmp207_ = NULL;
			gchar* _tmp208_ = NULL;
			gchar* _tmp209_ = NULL;
			ValaDataType* _tmp210_ = NULL;
			ValaProperty* _tmp211_ = NULL;
			ValaExpression* _tmp212_ = NULL;
			ValaExpression* _tmp213_ = NULL;
			ValaProperty* _tmp214_ = NULL;
			ValaSourceReference* _tmp215_ = NULL;
			ValaSourceReference* _tmp216_ = NULL;
			ValaField* _tmp217_ = NULL;
			ValaField* _tmp218_ = NULL;
			ValaProperty* _tmp219_ = NULL;
			ValaField* _tmp220_ = NULL;
			ValaField* _tmp221_ = NULL;
			ValaProperty* _tmp222_ = NULL;
			ValaField* _tmp223_ = NULL;
			ValaField* _tmp224_ = NULL;
			ValaProperty* _tmp225_ = NULL;
			ValaMemberBinding _tmp226_ = 0;
			ValaMemberBinding _tmp227_ = 0;
			_tmp200_ = prop;
			_tmp201_ = vala_property_get_property_type (_tmp200_);
			_tmp202_ = _tmp201_;
			_tmp203_ = vala_data_type_copy (_tmp202_);
			variable_type = _tmp203_;
			_tmp204_ = prop;
			_tmp205_ = prop;
			_tmp206_ = vala_symbol_get_name ((ValaSymbol*) _tmp205_);
			_tmp207_ = _tmp206_;
			_tmp208_ = g_strdup_printf ("_%s", _tmp207_);
			_tmp209_ = _tmp208_;
			_tmp210_ = variable_type;
			_tmp211_ = prop;
			_tmp212_ = vala_property_get_initializer (_tmp211_);
			_tmp213_ = _tmp212_;
			_tmp214_ = prop;
			_tmp215_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp214_);
			_tmp216_ = _tmp215_;
			_tmp217_ = vala_field_new (_tmp209_, _tmp210_, _tmp213_, _tmp216_, NULL);
			_tmp218_ = _tmp217_;
			vala_property_set_field (_tmp204_, _tmp218_);
			_vala_code_node_unref0 (_tmp218_);
			_g_free0 (_tmp209_);
			_tmp219_ = prop;
			_tmp220_ = vala_property_get_field (_tmp219_);
			_tmp221_ = _tmp220_;
			vala_symbol_set_access ((ValaSymbol*) _tmp221_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
			_tmp222_ = prop;
			_tmp223_ = vala_property_get_field (_tmp222_);
			_tmp224_ = _tmp223_;
			_tmp225_ = prop;
			_tmp226_ = vala_property_get_binding (_tmp225_);
			_tmp227_ = _tmp226_;
			vala_field_set_binding (_tmp224_, _tmp227_);
			_vala_code_node_unref0 (variable_type);
		}
	}
	result = prop;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaSignal* vala_genie_parser_parse_signal_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSignal* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	gchar* id = NULL;
	gchar* _tmp2_ = NULL;
	ValaArrayList* params = NULL;
	GEqualFunc _tmp3_ = NULL;
	ValaArrayList* _tmp4_ = NULL;
	ValaGenieTokenType _tmp5_ = 0;
	gboolean _tmp12_ = FALSE;
	ValaSignal* sig = NULL;
	const gchar* _tmp16_ = NULL;
	ValaDataType* _tmp17_ = NULL;
	ValaSourceLocation _tmp18_ = {0};
	ValaSourceReference* _tmp19_ = NULL;
	ValaSourceReference* _tmp20_ = NULL;
	ValaComment* _tmp21_ = NULL;
	ValaSignal* _tmp22_ = NULL;
	ValaSignal* _tmp23_ = NULL;
	ValaGenieParserModifierFlags _tmp24_ = 0;
	ValaGenieParserModifierFlags _tmp29_ = 0;
	ValaGenieParserModifierFlags _tmp31_ = 0;
	ValaGenieParserModifierFlags _tmp33_ = 0;
	ValaSignal* _tmp43_ = NULL;
	ValaList* _tmp44_ = NULL;
	gboolean _tmp58_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EVENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = g_direct_equal;
	_tmp4_ = vala_array_list_new (VALA_TYPE_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp3_);
	params = _tmp4_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = vala_genie_parser_current (self);
	if (_tmp5_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_ = FALSE;
				ValaParameter* param = NULL;
				ValaParameter* _tmp9_ = NULL;
				ValaArrayList* _tmp10_ = NULL;
				ValaParameter* _tmp11_ = NULL;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gboolean _tmp8_ = FALSE;
					_tmp8_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp8_) {
						break;
					}
				}
				_tmp6_ = FALSE;
				_tmp9_ = vala_genie_parser_parse_parameter (self, &_inner_error_);
				param = _tmp9_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_iterable_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp10_ = params;
				_tmp11_ = param;
				vala_collection_add ((ValaCollection*) _tmp10_, _tmp11_);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp12_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp12_) {
		ValaDataType* _tmp13_ = NULL;
		ValaDataType* _tmp14_ = NULL;
		_tmp14_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		_tmp13_ = _tmp14_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (type);
		type = _tmp13_;
	} else {
		ValaVoidType* _tmp15_ = NULL;
		_tmp15_ = vala_void_type_new (NULL);
		_vala_code_node_unref0 (type);
		type = (ValaDataType*) _tmp15_;
	}
	_tmp16_ = id;
	_tmp17_ = type;
	_tmp18_ = begin;
	_tmp19_ = vala_genie_parser_get_src (self, &_tmp18_);
	_tmp20_ = _tmp19_;
	_tmp21_ = self->priv->comment;
	_tmp22_ = vala_signal_new (_tmp16_, _tmp17_, _tmp20_, _tmp21_);
	_tmp23_ = _tmp22_;
	_vala_source_reference_unref0 (_tmp20_);
	sig = _tmp23_;
	_tmp24_ = flags;
	if ((_tmp24_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaSignal* _tmp25_ = NULL;
		_tmp25_ = sig;
		vala_symbol_set_access ((ValaSymbol*) _tmp25_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaSignal* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		ValaSymbolAccessibility _tmp28_ = 0;
		_tmp26_ = sig;
		_tmp27_ = id;
		_tmp28_ = vala_genie_parser_get_access (self, _tmp27_);
		vala_symbol_set_access ((ValaSymbol*) _tmp26_, _tmp28_);
	}
	_tmp29_ = flags;
	if ((_tmp29_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		ValaSignal* _tmp30_ = NULL;
		_tmp30_ = sig;
		vala_signal_set_is_virtual (_tmp30_, TRUE);
	}
	_tmp31_ = flags;
	if ((_tmp31_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		ValaSignal* _tmp32_ = NULL;
		_tmp32_ = sig;
		vala_symbol_set_hides ((ValaSymbol*) _tmp32_, TRUE);
	}
	_tmp33_ = flags;
	if ((_tmp33_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_ = NULL;
		GError* _tmp36_ = NULL;
		GError* _tmp37_ = NULL;
		_tmp34_ = vala_genie_parser_get_error (self, "`static' modifier not allowed on signals");
		_tmp35_ = _tmp34_;
		_tmp36_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp35_);
		_tmp37_ = _tmp36_;
		_g_free0 (_tmp35_);
		_inner_error_ = _tmp37_;
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sig);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sig);
			_vala_iterable_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		ValaGenieParserModifierFlags _tmp38_ = 0;
		_tmp38_ = flags;
		if ((_tmp38_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			gchar* _tmp39_ = NULL;
			gchar* _tmp40_ = NULL;
			GError* _tmp41_ = NULL;
			GError* _tmp42_ = NULL;
			_tmp39_ = vala_genie_parser_get_error (self, "`class' modifier not allowed on signals");
			_tmp40_ = _tmp39_;
			_tmp41_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp40_);
			_tmp42_ = _tmp41_;
			_g_free0 (_tmp40_);
			_inner_error_ = _tmp42_;
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	_tmp43_ = sig;
	_tmp44_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp43_, _tmp44_);
	{
		ValaArrayList* _formal_param_list = NULL;
		ValaArrayList* _tmp45_ = NULL;
		ValaArrayList* _tmp46_ = NULL;
		gint _formal_param_size = 0;
		ValaArrayList* _tmp47_ = NULL;
		gint _tmp48_ = 0;
		gint _tmp49_ = 0;
		gint _formal_param_index = 0;
		_tmp45_ = params;
		_tmp46_ = _vala_iterable_ref0 (_tmp45_);
		_formal_param_list = _tmp46_;
		_tmp47_ = _formal_param_list;
		_tmp48_ = vala_collection_get_size ((ValaCollection*) _tmp47_);
		_tmp49_ = _tmp48_;
		_formal_param_size = _tmp49_;
		_formal_param_index = -1;
		while (TRUE) {
			gint _tmp50_ = 0;
			gint _tmp51_ = 0;
			gint _tmp52_ = 0;
			ValaParameter* formal_param = NULL;
			ValaArrayList* _tmp53_ = NULL;
			gint _tmp54_ = 0;
			gpointer _tmp55_ = NULL;
			ValaSignal* _tmp56_ = NULL;
			ValaParameter* _tmp57_ = NULL;
			_tmp50_ = _formal_param_index;
			_formal_param_index = _tmp50_ + 1;
			_tmp51_ = _formal_param_index;
			_tmp52_ = _formal_param_size;
			if (!(_tmp51_ < _tmp52_)) {
				break;
			}
			_tmp53_ = _formal_param_list;
			_tmp54_ = _formal_param_index;
			_tmp55_ = vala_list_get ((ValaList*) _tmp53_, _tmp54_);
			formal_param = (ValaParameter*) _tmp55_;
			_tmp56_ = sig;
			_tmp57_ = formal_param;
			vala_signal_add_parameter (_tmp56_, _tmp57_);
			_vala_code_node_unref0 (formal_param);
		}
		_vala_iterable_unref0 (_formal_param_list);
	}
	_tmp58_ = vala_genie_parser_accept_terminator (self);
	if (!_tmp58_) {
		ValaBlock* _tmp59_ = NULL;
		ValaBlock* _tmp60_ = NULL;
		ValaSignal* _tmp61_ = NULL;
		ValaBlock* _tmp62_ = NULL;
		_tmp60_ = vala_genie_parser_parse_block (self, &_inner_error_);
		_tmp59_ = _tmp60_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_vala_iterable_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp61_ = sig;
		_tmp62_ = _tmp59_;
		vala_signal_set_body (_tmp61_, _tmp62_);
		_vala_code_node_unref0 (_tmp62_);
	}
	result = sig;
	_vala_iterable_unref0 (params);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaConstructor* vala_genie_parser_parse_constructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaConstructor* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaConstructor* c = NULL;
	ValaSourceLocation _tmp2_ = {0};
	ValaSourceReference* _tmp3_ = NULL;
	ValaSourceReference* _tmp4_ = NULL;
	ValaConstructor* _tmp5_ = NULL;
	ValaConstructor* _tmp6_ = NULL;
	ValaGenieParserModifierFlags _tmp7_ = 0;
	ValaBlock* _tmp11_ = NULL;
	ValaBlock* _tmp12_ = NULL;
	ValaConstructor* _tmp13_ = NULL;
	ValaBlock* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INIT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = begin;
	_tmp3_ = vala_genie_parser_get_src (self, &_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_constructor_new (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_source_reference_unref0 (_tmp4_);
	c = _tmp6_;
	_tmp7_ = flags;
	if ((_tmp7_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		ValaConstructor* _tmp8_ = NULL;
		_tmp8_ = c;
		vala_constructor_set_binding (_tmp8_, VALA_MEMBER_BINDING_STATIC);
	} else {
		ValaGenieParserModifierFlags _tmp9_ = 0;
		_tmp9_ = flags;
		if ((_tmp9_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			ValaConstructor* _tmp10_ = NULL;
			_tmp10_ = c;
			vala_constructor_set_binding (_tmp10_, VALA_MEMBER_BINDING_CLASS);
		}
	}
	vala_genie_parser_accept_block (self);
	_tmp12_ = vala_genie_parser_parse_block (self, &_inner_error_);
	_tmp11_ = _tmp12_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (c);
			return NULL;
		} else {
			_vala_code_node_unref0 (c);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp13_ = c;
	_tmp14_ = _tmp11_;
	vala_subroutine_set_body ((ValaSubroutine*) _tmp13_, _tmp14_);
	_vala_code_node_unref0 (_tmp14_);
	result = c;
	return result;
}


static ValaDestructor* vala_genie_parser_parse_destructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaDestructor* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDestructor* d = NULL;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceReference* _tmp2_ = NULL;
	ValaSourceReference* _tmp3_ = NULL;
	ValaDestructor* _tmp4_ = NULL;
	ValaDestructor* _tmp5_ = NULL;
	ValaBlock* _tmp6_ = NULL;
	ValaBlock* _tmp7_ = NULL;
	ValaDestructor* _tmp8_ = NULL;
	ValaBlock* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FINAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = begin;
	_tmp2_ = vala_genie_parser_get_src (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_destructor_new (_tmp3_);
	_tmp5_ = _tmp4_;
	_vala_source_reference_unref0 (_tmp3_);
	d = _tmp5_;
	vala_genie_parser_accept_block (self);
	_tmp7_ = vala_genie_parser_parse_block (self, &_inner_error_);
	_tmp6_ = _tmp7_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = d;
	_tmp9_ = _tmp6_;
	vala_subroutine_set_body ((ValaSubroutine*) _tmp8_, _tmp9_);
	_vala_code_node_unref0 (_tmp9_);
	result = d;
	return result;
}


static ValaSymbol* vala_genie_parser_parse_struct_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaList* type_param_list = NULL;
	ValaList* _tmp3_ = NULL;
	ValaDataType* base_type = NULL;
	gboolean _tmp4_ = FALSE;
	ValaStruct* st = NULL;
	ValaUnresolvedSymbol* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	ValaSourceLocation _tmp10_ = {0};
	ValaSourceReference* _tmp11_ = NULL;
	ValaSourceReference* _tmp12_ = NULL;
	ValaComment* _tmp13_ = NULL;
	ValaStruct* _tmp14_ = NULL;
	ValaStruct* _tmp15_ = NULL;
	ValaGenieParserModifierFlags _tmp16_ = 0;
	ValaStruct* _tmp23_ = NULL;
	ValaList* _tmp24_ = NULL;
	ValaDataType* _tmp38_ = NULL;
	ValaStruct* _tmp41_ = NULL;
	ValaSymbol* _result_ = NULL;
	ValaStruct* _tmp42_ = NULL;
	ValaSymbol* _tmp43_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_STRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	type_param_list = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_type = NULL;
	_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp4_) {
		ValaDataType* _tmp5_ = NULL;
		ValaDataType* _tmp6_ = NULL;
		_tmp6_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		_tmp5_ = _tmp6_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_type);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_type);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (base_type);
		base_type = _tmp5_;
	}
	_tmp7_ = sym;
	_tmp8_ = vala_symbol_get_name ((ValaSymbol*) _tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = begin;
	_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = self->priv->comment;
	_tmp14_ = vala_struct_new (_tmp9_, _tmp12_, _tmp13_);
	_tmp15_ = _tmp14_;
	_vala_source_reference_unref0 (_tmp12_);
	st = _tmp15_;
	_tmp16_ = flags;
	if ((_tmp16_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaStruct* _tmp17_ = NULL;
		_tmp17_ = st;
		vala_symbol_set_access ((ValaSymbol*) _tmp17_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaStruct* _tmp18_ = NULL;
		ValaUnresolvedSymbol* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		ValaSymbolAccessibility _tmp22_ = 0;
		_tmp18_ = st;
		_tmp19_ = sym;
		_tmp20_ = vala_symbol_get_name ((ValaSymbol*) _tmp19_);
		_tmp21_ = _tmp20_;
		_tmp22_ = vala_genie_parser_get_access (self, _tmp21_);
		vala_symbol_set_access ((ValaSymbol*) _tmp18_, _tmp22_);
	}
	_tmp23_ = st;
	_tmp24_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp23_, _tmp24_);
	{
		ValaList* _type_param_list = NULL;
		ValaList* _tmp25_ = NULL;
		ValaList* _tmp26_ = NULL;
		gint _type_param_size = 0;
		ValaList* _tmp27_ = NULL;
		gint _tmp28_ = 0;
		gint _tmp29_ = 0;
		gint _type_param_index = 0;
		_tmp25_ = type_param_list;
		_tmp26_ = _vala_iterable_ref0 (_tmp25_);
		_type_param_list = _tmp26_;
		_tmp27_ = _type_param_list;
		_tmp28_ = vala_collection_get_size ((ValaCollection*) _tmp27_);
		_tmp29_ = _tmp28_;
		_type_param_size = _tmp29_;
		_type_param_index = -1;
		while (TRUE) {
			gint _tmp30_ = 0;
			gint _tmp31_ = 0;
			gint _tmp32_ = 0;
			ValaTypeParameter* type_param = NULL;
			ValaList* _tmp33_ = NULL;
			gint _tmp34_ = 0;
			gpointer _tmp35_ = NULL;
			ValaStruct* _tmp36_ = NULL;
			ValaTypeParameter* _tmp37_ = NULL;
			_tmp30_ = _type_param_index;
			_type_param_index = _tmp30_ + 1;
			_tmp31_ = _type_param_index;
			_tmp32_ = _type_param_size;
			if (!(_tmp31_ < _tmp32_)) {
				break;
			}
			_tmp33_ = _type_param_list;
			_tmp34_ = _type_param_index;
			_tmp35_ = vala_list_get (_tmp33_, _tmp34_);
			type_param = (ValaTypeParameter*) _tmp35_;
			_tmp36_ = st;
			_tmp37_ = type_param;
			vala_struct_add_type_parameter (_tmp36_, _tmp37_);
			_vala_code_node_unref0 (type_param);
		}
		_vala_iterable_unref0 (_type_param_list);
	}
	_tmp38_ = base_type;
	if (_tmp38_ != NULL) {
		ValaStruct* _tmp39_ = NULL;
		ValaDataType* _tmp40_ = NULL;
		_tmp39_ = st;
		_tmp40_ = base_type;
		vala_struct_set_base_type (_tmp39_, _tmp40_);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp41_ = st;
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) _tmp41_, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp42_ = st;
	_tmp43_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp42_);
	_result_ = _tmp43_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp44_ = NULL;
		ValaUnresolvedSymbol* _tmp45_ = NULL;
		ValaUnresolvedSymbol* _tmp46_ = NULL;
		ValaUnresolvedSymbol* _tmp47_ = NULL;
		ValaUnresolvedSymbol* _tmp48_ = NULL;
		ValaUnresolvedSymbol* _tmp49_ = NULL;
		ValaUnresolvedSymbol* _tmp50_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp51_ = NULL;
		const gchar* _tmp52_ = NULL;
		const gchar* _tmp53_ = NULL;
		ValaStruct* _tmp54_ = NULL;
		ValaSourceReference* _tmp55_ = NULL;
		ValaSourceReference* _tmp56_ = NULL;
		ValaNamespace* _tmp57_ = NULL;
		ValaSymbol* _tmp58_ = NULL;
		ValaNamespace* _tmp63_ = NULL;
		ValaSymbol* _tmp64_ = NULL;
		_tmp44_ = sym;
		_tmp45_ = vala_unresolved_symbol_get_inner (_tmp44_);
		_tmp46_ = _tmp45_;
		if (!(_tmp46_ != NULL)) {
			break;
		}
		_tmp47_ = sym;
		_tmp48_ = vala_unresolved_symbol_get_inner (_tmp47_);
		_tmp49_ = _tmp48_;
		_tmp50_ = _vala_code_node_ref0 (_tmp49_);
		_vala_code_node_unref0 (sym);
		sym = _tmp50_;
		_tmp51_ = sym;
		_tmp52_ = vala_symbol_get_name ((ValaSymbol*) _tmp51_);
		_tmp53_ = _tmp52_;
		_tmp54_ = st;
		_tmp55_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp54_);
		_tmp56_ = _tmp55_;
		_tmp57_ = vala_namespace_new (_tmp53_, _tmp56_);
		ns = _tmp57_;
		_tmp58_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp58_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp59_ = NULL;
			ValaSymbol* _tmp60_ = NULL;
			_tmp59_ = ns;
			_tmp60_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp59_, G_TYPE_CHECK_INSTANCE_CAST (_tmp60_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp61_ = NULL;
			ValaSymbol* _tmp62_ = NULL;
			_tmp61_ = ns;
			_tmp62_ = _result_;
			vala_symbol_add_struct ((ValaSymbol*) _tmp61_, G_TYPE_CHECK_INSTANCE_CAST (_tmp62_, VALA_TYPE_STRUCT, ValaStruct));
		}
		_tmp63_ = ns;
		_tmp64_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp63_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp64_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (st);
	_vala_code_node_unref0 (base_type);
	_vala_iterable_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_struct_member (ValaGenieParser* self, ValaStruct* st, GError** error) {
	ValaSymbol* sym = NULL;
	ValaSymbol* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (st != NULL);
	_tmp0_ = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	sym = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_METHOD)) {
		ValaStruct* _tmp1_ = NULL;
		_tmp1_ = st;
		vala_symbol_add_method ((ValaSymbol*) _tmp1_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_METHOD, ValaMethod));
	} else {
		if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_FIELD)) {
			ValaStruct* _tmp2_ = NULL;
			_tmp2_ = st;
			vala_symbol_add_field ((ValaSymbol*) _tmp2_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_FIELD, ValaField));
		} else {
			if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CONSTANT)) {
				ValaStruct* _tmp3_ = NULL;
				_tmp3_ = st;
				vala_symbol_add_constant ((ValaSymbol*) _tmp3_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CONSTANT, ValaConstant));
			} else {
				if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_PROPERTY)) {
					ValaStruct* _tmp4_ = NULL;
					_tmp4_ = st;
					vala_symbol_add_property ((ValaSymbol*) _tmp4_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_PROPERTY, ValaProperty));
				} else {
					ValaSourceReference* _tmp5_ = NULL;
					ValaSourceReference* _tmp6_ = NULL;
					_tmp5_ = vala_code_node_get_source_reference ((ValaCodeNode*) sym);
					_tmp6_ = _tmp5_;
					vala_report_error (_tmp6_, "unexpected declaration in struct");
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_genie_parser_parse_interface_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaList* type_param_list = NULL;
	ValaList* _tmp3_ = NULL;
	ValaArrayList* base_types = NULL;
	GEqualFunc _tmp4_ = NULL;
	ValaArrayList* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	ValaInterface* iface = NULL;
	ValaUnresolvedSymbol* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	ValaSourceLocation _tmp16_ = {0};
	ValaSourceReference* _tmp17_ = NULL;
	ValaSourceReference* _tmp18_ = NULL;
	ValaComment* _tmp19_ = NULL;
	ValaInterface* _tmp20_ = NULL;
	ValaInterface* _tmp21_ = NULL;
	ValaGenieParserModifierFlags _tmp22_ = 0;
	gboolean _tmp29_ = FALSE;
	ValaGenieParserModifierFlags _tmp30_ = 0;
	gboolean _tmp36_ = FALSE;
	ValaInterface* _tmp38_ = NULL;
	ValaList* _tmp39_ = NULL;
	ValaInterface* _tmp66_ = NULL;
	ValaSymbol* _result_ = NULL;
	ValaInterface* _tmp67_ = NULL;
	ValaSymbol* _tmp68_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INTERFACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	type_param_list = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = g_direct_equal;
	_tmp5_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp4_);
	base_types = _tmp5_;
	_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp6_) {
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_ = FALSE;
				ValaDataType* type = NULL;
				ValaDataType* _tmp10_ = NULL;
				ValaArrayList* _tmp11_ = NULL;
				ValaDataType* _tmp12_ = NULL;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gboolean _tmp9_ = FALSE;
					_tmp9_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp9_) {
						break;
					}
				}
				_tmp7_ = FALSE;
				_tmp10_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				type = _tmp10_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (base_types);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_iterable_unref0 (base_types);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp11_ = base_types;
				_tmp12_ = type;
				vala_collection_add ((ValaCollection*) _tmp11_, _tmp12_);
				_vala_code_node_unref0 (type);
			}
		}
	}
	_tmp13_ = sym;
	_tmp14_ = vala_symbol_get_name ((ValaSymbol*) _tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = begin;
	_tmp17_ = vala_genie_parser_get_src (self, &_tmp16_);
	_tmp18_ = _tmp17_;
	_tmp19_ = self->priv->comment;
	_tmp20_ = vala_interface_new (_tmp15_, _tmp18_, _tmp19_);
	_tmp21_ = _tmp20_;
	_vala_source_reference_unref0 (_tmp18_);
	iface = _tmp21_;
	_tmp22_ = flags;
	if ((_tmp22_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaInterface* _tmp23_ = NULL;
		_tmp23_ = iface;
		vala_symbol_set_access ((ValaSymbol*) _tmp23_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaInterface* _tmp24_ = NULL;
		ValaUnresolvedSymbol* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		ValaSymbolAccessibility _tmp28_ = 0;
		_tmp24_ = iface;
		_tmp25_ = sym;
		_tmp26_ = vala_symbol_get_name ((ValaSymbol*) _tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = vala_genie_parser_get_access (self, _tmp27_);
		vala_symbol_set_access ((ValaSymbol*) _tmp24_, _tmp28_);
	}
	_tmp30_ = flags;
	if ((_tmp30_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp29_ = TRUE;
	} else {
		ValaGenieScanner* _tmp31_ = NULL;
		ValaSourceFile* _tmp32_ = NULL;
		ValaSourceFile* _tmp33_ = NULL;
		ValaSourceFileType _tmp34_ = 0;
		ValaSourceFileType _tmp35_ = 0;
		_tmp31_ = self->priv->scanner;
		_tmp32_ = vala_genie_scanner_get_source_file (_tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = vala_source_file_get_file_type (_tmp33_);
		_tmp35_ = _tmp34_;
		_tmp29_ = _tmp35_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp36_ = _tmp29_;
	if (_tmp36_) {
		ValaInterface* _tmp37_ = NULL;
		_tmp37_ = iface;
		vala_symbol_set_external ((ValaSymbol*) _tmp37_, TRUE);
	}
	_tmp38_ = iface;
	_tmp39_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp38_, _tmp39_);
	{
		ValaList* _type_param_list = NULL;
		ValaList* _tmp40_ = NULL;
		ValaList* _tmp41_ = NULL;
		gint _type_param_size = 0;
		ValaList* _tmp42_ = NULL;
		gint _tmp43_ = 0;
		gint _tmp44_ = 0;
		gint _type_param_index = 0;
		_tmp40_ = type_param_list;
		_tmp41_ = _vala_iterable_ref0 (_tmp40_);
		_type_param_list = _tmp41_;
		_tmp42_ = _type_param_list;
		_tmp43_ = vala_collection_get_size ((ValaCollection*) _tmp42_);
		_tmp44_ = _tmp43_;
		_type_param_size = _tmp44_;
		_type_param_index = -1;
		while (TRUE) {
			gint _tmp45_ = 0;
			gint _tmp46_ = 0;
			gint _tmp47_ = 0;
			ValaTypeParameter* type_param = NULL;
			ValaList* _tmp48_ = NULL;
			gint _tmp49_ = 0;
			gpointer _tmp50_ = NULL;
			ValaInterface* _tmp51_ = NULL;
			ValaTypeParameter* _tmp52_ = NULL;
			_tmp45_ = _type_param_index;
			_type_param_index = _tmp45_ + 1;
			_tmp46_ = _type_param_index;
			_tmp47_ = _type_param_size;
			if (!(_tmp46_ < _tmp47_)) {
				break;
			}
			_tmp48_ = _type_param_list;
			_tmp49_ = _type_param_index;
			_tmp50_ = vala_list_get (_tmp48_, _tmp49_);
			type_param = (ValaTypeParameter*) _tmp50_;
			_tmp51_ = iface;
			_tmp52_ = type_param;
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) _tmp51_, _tmp52_);
			_vala_code_node_unref0 (type_param);
		}
		_vala_iterable_unref0 (_type_param_list);
	}
	{
		ValaArrayList* _base_type_list = NULL;
		ValaArrayList* _tmp53_ = NULL;
		ValaArrayList* _tmp54_ = NULL;
		gint _base_type_size = 0;
		ValaArrayList* _tmp55_ = NULL;
		gint _tmp56_ = 0;
		gint _tmp57_ = 0;
		gint _base_type_index = 0;
		_tmp53_ = base_types;
		_tmp54_ = _vala_iterable_ref0 (_tmp53_);
		_base_type_list = _tmp54_;
		_tmp55_ = _base_type_list;
		_tmp56_ = vala_collection_get_size ((ValaCollection*) _tmp55_);
		_tmp57_ = _tmp56_;
		_base_type_size = _tmp57_;
		_base_type_index = -1;
		while (TRUE) {
			gint _tmp58_ = 0;
			gint _tmp59_ = 0;
			gint _tmp60_ = 0;
			ValaDataType* base_type = NULL;
			ValaArrayList* _tmp61_ = NULL;
			gint _tmp62_ = 0;
			gpointer _tmp63_ = NULL;
			ValaInterface* _tmp64_ = NULL;
			ValaDataType* _tmp65_ = NULL;
			_tmp58_ = _base_type_index;
			_base_type_index = _tmp58_ + 1;
			_tmp59_ = _base_type_index;
			_tmp60_ = _base_type_size;
			if (!(_tmp59_ < _tmp60_)) {
				break;
			}
			_tmp61_ = _base_type_list;
			_tmp62_ = _base_type_index;
			_tmp63_ = vala_list_get ((ValaList*) _tmp61_, _tmp62_);
			base_type = (ValaDataType*) _tmp63_;
			_tmp64_ = iface;
			_tmp65_ = base_type;
			vala_interface_add_prerequisite (_tmp64_, _tmp65_);
			_vala_code_node_unref0 (base_type);
		}
		_vala_iterable_unref0 (_base_type_list);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (iface);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (iface);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp66_ = iface;
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) _tmp66_, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (iface);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (iface);
			_vala_iterable_unref0 (base_types);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp67_ = iface;
	_tmp68_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp67_);
	_result_ = _tmp68_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp69_ = NULL;
		ValaUnresolvedSymbol* _tmp70_ = NULL;
		ValaUnresolvedSymbol* _tmp71_ = NULL;
		ValaUnresolvedSymbol* _tmp72_ = NULL;
		ValaUnresolvedSymbol* _tmp73_ = NULL;
		ValaUnresolvedSymbol* _tmp74_ = NULL;
		ValaUnresolvedSymbol* _tmp75_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp76_ = NULL;
		const gchar* _tmp77_ = NULL;
		const gchar* _tmp78_ = NULL;
		ValaInterface* _tmp79_ = NULL;
		ValaSourceReference* _tmp80_ = NULL;
		ValaSourceReference* _tmp81_ = NULL;
		ValaNamespace* _tmp82_ = NULL;
		ValaSymbol* _tmp83_ = NULL;
		ValaNamespace* _tmp88_ = NULL;
		ValaSymbol* _tmp89_ = NULL;
		_tmp69_ = sym;
		_tmp70_ = vala_unresolved_symbol_get_inner (_tmp69_);
		_tmp71_ = _tmp70_;
		if (!(_tmp71_ != NULL)) {
			break;
		}
		_tmp72_ = sym;
		_tmp73_ = vala_unresolved_symbol_get_inner (_tmp72_);
		_tmp74_ = _tmp73_;
		_tmp75_ = _vala_code_node_ref0 (_tmp74_);
		_vala_code_node_unref0 (sym);
		sym = _tmp75_;
		_tmp76_ = sym;
		_tmp77_ = vala_symbol_get_name ((ValaSymbol*) _tmp76_);
		_tmp78_ = _tmp77_;
		_tmp79_ = iface;
		_tmp80_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp79_);
		_tmp81_ = _tmp80_;
		_tmp82_ = vala_namespace_new (_tmp78_, _tmp81_);
		ns = _tmp82_;
		_tmp83_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp83_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp84_ = NULL;
			ValaSymbol* _tmp85_ = NULL;
			_tmp84_ = ns;
			_tmp85_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp84_, G_TYPE_CHECK_INSTANCE_CAST (_tmp85_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp86_ = NULL;
			ValaSymbol* _tmp87_ = NULL;
			_tmp86_ = ns;
			_tmp87_ = _result_;
			vala_symbol_add_interface ((ValaSymbol*) _tmp86_, G_TYPE_CHECK_INSTANCE_CAST (_tmp87_, VALA_TYPE_INTERFACE, ValaInterface));
		}
		_tmp88_ = ns;
		_tmp89_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp88_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp89_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (iface);
	_vala_iterable_unref0 (base_types);
	_vala_iterable_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_interface_member (ValaGenieParser* self, ValaInterface* iface, GError** error) {
	ValaSymbol* sym = NULL;
	ValaSymbol* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iface != NULL);
	_tmp0_ = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	sym = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CLASS)) {
		ValaInterface* _tmp1_ = NULL;
		_tmp1_ = iface;
		vala_symbol_add_class ((ValaSymbol*) _tmp1_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CLASS, ValaClass));
	} else {
		if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_STRUCT)) {
			ValaInterface* _tmp2_ = NULL;
			_tmp2_ = iface;
			vala_symbol_add_struct ((ValaSymbol*) _tmp2_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_STRUCT, ValaStruct));
		} else {
			if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_ENUM)) {
				ValaInterface* _tmp3_ = NULL;
				_tmp3_ = iface;
				vala_symbol_add_enum ((ValaSymbol*) _tmp3_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_ENUM, ValaEnum));
			} else {
				if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_DELEGATE)) {
					ValaInterface* _tmp4_ = NULL;
					_tmp4_ = iface;
					vala_symbol_add_delegate ((ValaSymbol*) _tmp4_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_DELEGATE, ValaDelegate));
				} else {
					if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_METHOD)) {
						ValaInterface* _tmp5_ = NULL;
						_tmp5_ = iface;
						vala_symbol_add_method ((ValaSymbol*) _tmp5_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_METHOD, ValaMethod));
					} else {
						if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_SIGNAL)) {
							ValaInterface* _tmp6_ = NULL;
							_tmp6_ = iface;
							vala_symbol_add_signal ((ValaSymbol*) _tmp6_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_SIGNAL, ValaSignal));
						} else {
							if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_FIELD)) {
								ValaInterface* _tmp7_ = NULL;
								_tmp7_ = iface;
								vala_symbol_add_field ((ValaSymbol*) _tmp7_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_FIELD, ValaField));
							} else {
								if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_CONSTANT)) {
									ValaInterface* _tmp8_ = NULL;
									_tmp8_ = iface;
									vala_symbol_add_constant ((ValaSymbol*) _tmp8_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_CONSTANT, ValaConstant));
								} else {
									if (G_TYPE_CHECK_INSTANCE_TYPE (sym, VALA_TYPE_PROPERTY)) {
										ValaInterface* _tmp9_ = NULL;
										_tmp9_ = iface;
										vala_symbol_add_property ((ValaSymbol*) _tmp9_, G_TYPE_CHECK_INSTANCE_CAST (sym, VALA_TYPE_PROPERTY, ValaProperty));
									} else {
										ValaSourceReference* _tmp10_ = NULL;
										ValaSourceReference* _tmp11_ = NULL;
										_tmp10_ = vala_code_node_get_source_reference ((ValaCodeNode*) sym);
										_tmp11_ = _tmp10_;
										vala_report_error (_tmp11_, "unexpected declaration in interface");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_genie_parser_parse_enum_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaEnum* en = NULL;
	ValaUnresolvedSymbol* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	ValaSourceLocation _tmp6_ = {0};
	ValaSourceReference* _tmp7_ = NULL;
	ValaSourceReference* _tmp8_ = NULL;
	ValaComment* _tmp9_ = NULL;
	ValaEnum* _tmp10_ = NULL;
	ValaEnum* _tmp11_ = NULL;
	ValaGenieParserModifierFlags _tmp12_ = 0;
	gboolean _tmp19_ = FALSE;
	ValaGenieParserModifierFlags _tmp20_ = 0;
	gboolean _tmp26_ = FALSE;
	ValaEnum* _tmp28_ = NULL;
	ValaList* _tmp29_ = NULL;
	ValaSymbol* _result_ = NULL;
	ValaEnum* _tmp59_ = NULL;
	ValaSymbol* _tmp60_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ENUM, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = sym;
	_tmp4_ = vala_symbol_get_name ((ValaSymbol*) _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = begin;
	_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = self->priv->comment;
	_tmp10_ = vala_enum_new (_tmp5_, _tmp8_, _tmp9_);
	_tmp11_ = _tmp10_;
	_vala_source_reference_unref0 (_tmp8_);
	en = _tmp11_;
	_tmp12_ = flags;
	if ((_tmp12_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaEnum* _tmp13_ = NULL;
		_tmp13_ = en;
		vala_symbol_set_access ((ValaSymbol*) _tmp13_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaEnum* _tmp14_ = NULL;
		ValaUnresolvedSymbol* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		ValaSymbolAccessibility _tmp18_ = 0;
		_tmp14_ = en;
		_tmp15_ = sym;
		_tmp16_ = vala_symbol_get_name ((ValaSymbol*) _tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = vala_genie_parser_get_access (self, _tmp17_);
		vala_symbol_set_access ((ValaSymbol*) _tmp14_, _tmp18_);
	}
	_tmp20_ = flags;
	if ((_tmp20_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp19_ = TRUE;
	} else {
		ValaGenieScanner* _tmp21_ = NULL;
		ValaSourceFile* _tmp22_ = NULL;
		ValaSourceFile* _tmp23_ = NULL;
		ValaSourceFileType _tmp24_ = 0;
		ValaSourceFileType _tmp25_ = 0;
		_tmp21_ = self->priv->scanner;
		_tmp22_ = vala_genie_scanner_get_source_file (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = vala_source_file_get_file_type (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp19_ = _tmp25_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp26_ = _tmp19_;
	if (_tmp26_) {
		ValaEnum* _tmp27_ = NULL;
		_tmp27_ = en;
		vala_symbol_set_external ((ValaSymbol*) _tmp27_, TRUE);
	}
	_tmp28_ = en;
	_tmp29_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp28_, _tmp29_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp30_ = FALSE;
		ValaGenieTokenType _tmp31_ = 0;
		gboolean _tmp37_ = FALSE;
		ValaList* value_attrs = NULL;
		ValaList* _tmp38_ = NULL;
		ValaSourceLocation value_begin = {0};
		ValaSourceLocation _tmp39_ = {0};
		gchar* id = NULL;
		gchar* _tmp40_ = NULL;
		ValaGenieScanner* _tmp41_ = NULL;
		ValaComment* _tmp42_ = NULL;
		ValaExpression* value = NULL;
		gboolean _tmp43_ = FALSE;
		ValaEnumValue* ev = NULL;
		const gchar* _tmp46_ = NULL;
		ValaExpression* _tmp47_ = NULL;
		ValaSourceLocation _tmp48_ = {0};
		ValaSourceReference* _tmp49_ = NULL;
		ValaSourceReference* _tmp50_ = NULL;
		ValaComment* _tmp51_ = NULL;
		ValaEnumValue* _tmp52_ = NULL;
		ValaEnumValue* _tmp53_ = NULL;
		ValaEnumValue* _tmp54_ = NULL;
		ValaEnumValue* _tmp55_ = NULL;
		ValaList* _tmp56_ = NULL;
		ValaEnum* _tmp57_ = NULL;
		ValaEnumValue* _tmp58_ = NULL;
		_tmp31_ = vala_genie_parser_current (self);
		if (_tmp31_ == VALA_GENIE_TOKEN_TYPE_DEDENT) {
			ValaEnum* _tmp32_ = NULL;
			ValaList* _tmp33_ = NULL;
			ValaList* _tmp34_ = NULL;
			gint _tmp35_ = 0;
			gint _tmp36_ = 0;
			_tmp32_ = en;
			_tmp33_ = vala_enum_get_values (_tmp32_);
			_tmp34_ = _tmp33_;
			_tmp35_ = vala_collection_get_size ((ValaCollection*) _tmp34_);
			_tmp36_ = _tmp35_;
			_tmp30_ = _tmp36_ > 0;
			_vala_iterable_unref0 (_tmp34_);
		} else {
			_tmp30_ = FALSE;
		}
		_tmp37_ = _tmp30_;
		if (_tmp37_) {
			break;
		}
		_tmp38_ = vala_genie_parser_parse_attributes (self, FALSE, &_inner_error_);
		value_attrs = _tmp38_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_get_location (self, &_tmp39_);
		value_begin = _tmp39_;
		_tmp40_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		id = _tmp40_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_iterable_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp41_ = self->priv->scanner;
		_tmp42_ = vala_genie_scanner_pop_comment (_tmp41_);
		_vala_comment_unref0 (self->priv->comment);
		self->priv->comment = _tmp42_;
		value = NULL;
		_tmp43_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
		if (_tmp43_) {
			ValaExpression* _tmp44_ = NULL;
			ValaExpression* _tmp45_ = NULL;
			_tmp45_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			_tmp44_ = _tmp45_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (value);
					_g_free0 (id);
					_vala_iterable_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (value);
					_g_free0 (id);
					_vala_iterable_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (value);
			value = _tmp44_;
		}
		_tmp46_ = id;
		_tmp47_ = value;
		_tmp48_ = value_begin;
		_tmp49_ = vala_genie_parser_get_src (self, &_tmp48_);
		_tmp50_ = _tmp49_;
		_tmp51_ = self->priv->comment;
		_tmp52_ = vala_enum_value_new (_tmp46_, _tmp47_, _tmp50_, _tmp51_);
		_tmp53_ = _tmp52_;
		_vala_source_reference_unref0 (_tmp50_);
		ev = _tmp53_;
		_tmp54_ = ev;
		vala_symbol_set_access ((ValaSymbol*) _tmp54_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		_tmp55_ = ev;
		_tmp56_ = value_attrs;
		vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp55_, _tmp56_);
		_tmp57_ = en;
		_tmp58_ = ev;
		vala_enum_add_value (_tmp57_, _tmp58_);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (ev);
				_vala_code_node_unref0 (value);
				_g_free0 (id);
				_vala_iterable_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (ev);
				_vala_code_node_unref0 (value);
				_g_free0 (id);
				_vala_iterable_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (ev);
		_vala_code_node_unref0 (value);
		_g_free0 (id);
		_vala_iterable_unref0 (value_attrs);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp59_ = en;
	_tmp60_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp59_);
	_result_ = _tmp60_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp61_ = NULL;
		ValaUnresolvedSymbol* _tmp62_ = NULL;
		ValaUnresolvedSymbol* _tmp63_ = NULL;
		ValaUnresolvedSymbol* _tmp64_ = NULL;
		ValaUnresolvedSymbol* _tmp65_ = NULL;
		ValaUnresolvedSymbol* _tmp66_ = NULL;
		ValaUnresolvedSymbol* _tmp67_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp68_ = NULL;
		const gchar* _tmp69_ = NULL;
		const gchar* _tmp70_ = NULL;
		ValaEnum* _tmp71_ = NULL;
		ValaSourceReference* _tmp72_ = NULL;
		ValaSourceReference* _tmp73_ = NULL;
		ValaNamespace* _tmp74_ = NULL;
		ValaSymbol* _tmp75_ = NULL;
		ValaNamespace* _tmp80_ = NULL;
		ValaSymbol* _tmp81_ = NULL;
		_tmp61_ = sym;
		_tmp62_ = vala_unresolved_symbol_get_inner (_tmp61_);
		_tmp63_ = _tmp62_;
		if (!(_tmp63_ != NULL)) {
			break;
		}
		_tmp64_ = sym;
		_tmp65_ = vala_unresolved_symbol_get_inner (_tmp64_);
		_tmp66_ = _tmp65_;
		_tmp67_ = _vala_code_node_ref0 (_tmp66_);
		_vala_code_node_unref0 (sym);
		sym = _tmp67_;
		_tmp68_ = sym;
		_tmp69_ = vala_symbol_get_name ((ValaSymbol*) _tmp68_);
		_tmp70_ = _tmp69_;
		_tmp71_ = en;
		_tmp72_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp71_);
		_tmp73_ = _tmp72_;
		_tmp74_ = vala_namespace_new (_tmp70_, _tmp73_);
		ns = _tmp74_;
		_tmp75_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp75_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp76_ = NULL;
			ValaSymbol* _tmp77_ = NULL;
			_tmp76_ = ns;
			_tmp77_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp76_, G_TYPE_CHECK_INSTANCE_CAST (_tmp77_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp78_ = NULL;
			ValaSymbol* _tmp79_ = NULL;
			_tmp78_ = ns;
			_tmp79_ = _result_;
			vala_symbol_add_enum ((ValaSymbol*) _tmp78_, G_TYPE_CHECK_INSTANCE_CAST (_tmp79_, VALA_TYPE_ENUM, ValaEnum));
		}
		_tmp80_ = ns;
		_tmp81_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp80_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp81_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (en);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaSymbol* vala_genie_parser_parse_errordomain_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaErrorDomain* ed = NULL;
	ValaUnresolvedSymbol* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	ValaSourceLocation _tmp6_ = {0};
	ValaSourceReference* _tmp7_ = NULL;
	ValaSourceReference* _tmp8_ = NULL;
	ValaComment* _tmp9_ = NULL;
	ValaErrorDomain* _tmp10_ = NULL;
	ValaErrorDomain* _tmp11_ = NULL;
	ValaGenieParserModifierFlags _tmp12_ = 0;
	ValaErrorDomain* _tmp19_ = NULL;
	ValaList* _tmp20_ = NULL;
	ValaSymbol* _result_ = NULL;
	ValaErrorDomain* _tmp50_ = NULL;
	ValaSymbol* _tmp51_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_type_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = sym;
	_tmp4_ = vala_symbol_get_name ((ValaSymbol*) _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = begin;
	_tmp7_ = vala_genie_parser_get_src (self, &_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = self->priv->comment;
	_tmp10_ = vala_error_domain_new (_tmp5_, _tmp8_, _tmp9_);
	_tmp11_ = _tmp10_;
	_vala_source_reference_unref0 (_tmp8_);
	ed = _tmp11_;
	_tmp12_ = flags;
	if ((_tmp12_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaErrorDomain* _tmp13_ = NULL;
		_tmp13_ = ed;
		vala_symbol_set_access ((ValaSymbol*) _tmp13_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaErrorDomain* _tmp14_ = NULL;
		ValaUnresolvedSymbol* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		ValaSymbolAccessibility _tmp18_ = 0;
		_tmp14_ = ed;
		_tmp15_ = sym;
		_tmp16_ = vala_symbol_get_name ((ValaSymbol*) _tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = vala_genie_parser_get_access (self, _tmp17_);
		vala_symbol_set_access ((ValaSymbol*) _tmp14_, _tmp18_);
	}
	_tmp19_ = ed;
	_tmp20_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp19_, _tmp20_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		gboolean _tmp21_ = FALSE;
		ValaGenieTokenType _tmp22_ = 0;
		gboolean _tmp28_ = FALSE;
		ValaList* code_attrs = NULL;
		ValaList* _tmp29_ = NULL;
		ValaSourceLocation code_begin = {0};
		ValaSourceLocation _tmp30_ = {0};
		gchar* id = NULL;
		gchar* _tmp31_ = NULL;
		ValaGenieScanner* _tmp32_ = NULL;
		ValaComment* _tmp33_ = NULL;
		ValaErrorCode* ec = NULL;
		const gchar* _tmp34_ = NULL;
		ValaSourceLocation _tmp35_ = {0};
		ValaSourceReference* _tmp36_ = NULL;
		ValaSourceReference* _tmp37_ = NULL;
		ValaComment* _tmp38_ = NULL;
		ValaErrorCode* _tmp39_ = NULL;
		ValaErrorCode* _tmp40_ = NULL;
		ValaErrorCode* _tmp41_ = NULL;
		ValaList* _tmp42_ = NULL;
		gboolean _tmp43_ = FALSE;
		ValaErrorDomain* _tmp48_ = NULL;
		ValaErrorCode* _tmp49_ = NULL;
		_tmp22_ = vala_genie_parser_current (self);
		if (_tmp22_ == VALA_GENIE_TOKEN_TYPE_DEDENT) {
			ValaErrorDomain* _tmp23_ = NULL;
			ValaList* _tmp24_ = NULL;
			ValaList* _tmp25_ = NULL;
			gint _tmp26_ = 0;
			gint _tmp27_ = 0;
			_tmp23_ = ed;
			_tmp24_ = vala_error_domain_get_codes (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = vala_collection_get_size ((ValaCollection*) _tmp25_);
			_tmp27_ = _tmp26_;
			_tmp21_ = _tmp27_ > 0;
			_vala_iterable_unref0 (_tmp25_);
		} else {
			_tmp21_ = FALSE;
		}
		_tmp28_ = _tmp21_;
		if (_tmp28_) {
			break;
		}
		_tmp29_ = vala_genie_parser_parse_attributes (self, FALSE, &_inner_error_);
		code_attrs = _tmp29_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_get_location (self, &_tmp30_);
		code_begin = _tmp30_;
		_tmp31_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		id = _tmp31_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (code_attrs);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_iterable_unref0 (code_attrs);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp32_ = self->priv->scanner;
		_tmp33_ = vala_genie_scanner_pop_comment (_tmp32_);
		_vala_comment_unref0 (self->priv->comment);
		self->priv->comment = _tmp33_;
		_tmp34_ = id;
		_tmp35_ = code_begin;
		_tmp36_ = vala_genie_parser_get_src (self, &_tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = self->priv->comment;
		_tmp39_ = vala_error_code_new (_tmp34_, _tmp37_, _tmp38_);
		_tmp40_ = _tmp39_;
		_vala_source_reference_unref0 (_tmp37_);
		ec = _tmp40_;
		_tmp41_ = ec;
		_tmp42_ = code_attrs;
		vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp41_, _tmp42_);
		_tmp43_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
		if (_tmp43_) {
			ValaExpression* _tmp44_ = NULL;
			ValaExpression* _tmp45_ = NULL;
			ValaErrorCode* _tmp46_ = NULL;
			ValaExpression* _tmp47_ = NULL;
			_tmp45_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			_tmp44_ = _tmp45_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (ec);
					_g_free0 (id);
					_vala_iterable_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (ec);
					_g_free0 (id);
					_vala_iterable_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp46_ = ec;
			_tmp47_ = _tmp44_;
			vala_error_code_set_value (_tmp46_, _tmp47_);
			_vala_code_node_unref0 (_tmp47_);
		}
		_tmp48_ = ed;
		_tmp49_ = ec;
		vala_error_domain_add_code (_tmp48_, _tmp49_);
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		_vala_code_node_unref0 (ec);
		_g_free0 (id);
		_vala_iterable_unref0 (code_attrs);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp50_ = ed;
	_tmp51_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp50_);
	_result_ = _tmp51_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp52_ = NULL;
		ValaUnresolvedSymbol* _tmp53_ = NULL;
		ValaUnresolvedSymbol* _tmp54_ = NULL;
		ValaUnresolvedSymbol* _tmp55_ = NULL;
		ValaUnresolvedSymbol* _tmp56_ = NULL;
		ValaUnresolvedSymbol* _tmp57_ = NULL;
		ValaUnresolvedSymbol* _tmp58_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp59_ = NULL;
		const gchar* _tmp60_ = NULL;
		const gchar* _tmp61_ = NULL;
		ValaErrorDomain* _tmp62_ = NULL;
		ValaSourceReference* _tmp63_ = NULL;
		ValaSourceReference* _tmp64_ = NULL;
		ValaNamespace* _tmp65_ = NULL;
		ValaSymbol* _tmp66_ = NULL;
		ValaNamespace* _tmp71_ = NULL;
		ValaSymbol* _tmp72_ = NULL;
		_tmp52_ = sym;
		_tmp53_ = vala_unresolved_symbol_get_inner (_tmp52_);
		_tmp54_ = _tmp53_;
		if (!(_tmp54_ != NULL)) {
			break;
		}
		_tmp55_ = sym;
		_tmp56_ = vala_unresolved_symbol_get_inner (_tmp55_);
		_tmp57_ = _tmp56_;
		_tmp58_ = _vala_code_node_ref0 (_tmp57_);
		_vala_code_node_unref0 (sym);
		sym = _tmp58_;
		_tmp59_ = sym;
		_tmp60_ = vala_symbol_get_name ((ValaSymbol*) _tmp59_);
		_tmp61_ = _tmp60_;
		_tmp62_ = ed;
		_tmp63_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp62_);
		_tmp64_ = _tmp63_;
		_tmp65_ = vala_namespace_new (_tmp61_, _tmp64_);
		ns = _tmp65_;
		_tmp66_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp66_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp67_ = NULL;
			ValaSymbol* _tmp68_ = NULL;
			_tmp67_ = ns;
			_tmp68_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp67_, G_TYPE_CHECK_INSTANCE_CAST (_tmp68_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp69_ = NULL;
			ValaSymbol* _tmp70_ = NULL;
			_tmp69_ = ns;
			_tmp70_ = _result_;
			vala_symbol_add_error_domain ((ValaSymbol*) _tmp69_, G_TYPE_CHECK_INSTANCE_CAST (_tmp70_, VALA_TYPE_ERROR_DOMAIN, ValaErrorDomain));
		}
		_tmp71_ = ns;
		_tmp72_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp71_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp72_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (ed);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaGenieParserModifierFlags vala_genie_parser_parse_type_declaration_modifiers (ValaGenieParser* self) {
	ValaGenieParserModifierFlags result = 0;
	ValaGenieParserModifierFlags flags = 0;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		ValaGenieTokenType _tmp0_ = 0;
		_tmp0_ = vala_genie_parser_current (self);
		switch (_tmp0_) {
			case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
			{
				ValaGenieParserModifierFlags _tmp1_ = 0;
				vala_genie_parser_next (self);
				_tmp1_ = flags;
				flags = _tmp1_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_EXTERN:
			{
				ValaGenieParserModifierFlags _tmp2_ = 0;
				vala_genie_parser_next (self);
				_tmp2_ = flags;
				flags = _tmp2_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_STATIC:
			{
				ValaGenieParserModifierFlags _tmp3_ = 0;
				vala_genie_parser_next (self);
				_tmp3_ = flags;
				flags = _tmp3_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_PRIVATE:
			{
				ValaGenieParserModifierFlags _tmp4_ = 0;
				vala_genie_parser_next (self);
				_tmp4_ = flags;
				flags = _tmp4_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaGenieParserModifierFlags vala_genie_parser_parse_member_declaration_modifiers (ValaGenieParser* self) {
	ValaGenieParserModifierFlags result = 0;
	ValaGenieParserModifierFlags flags = 0;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		ValaGenieTokenType _tmp0_ = 0;
		_tmp0_ = vala_genie_parser_current (self);
		switch (_tmp0_) {
			case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
			{
				ValaGenieParserModifierFlags _tmp1_ = 0;
				vala_genie_parser_next (self);
				_tmp1_ = flags;
				flags = _tmp1_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_ASYNC:
			{
				ValaGenieParserModifierFlags _tmp2_ = 0;
				vala_genie_parser_next (self);
				_tmp2_ = flags;
				flags = _tmp2_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_CLASS:
			{
				ValaGenieParserModifierFlags _tmp3_ = 0;
				vala_genie_parser_next (self);
				_tmp3_ = flags;
				flags = _tmp3_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_EXTERN:
			{
				ValaGenieParserModifierFlags _tmp4_ = 0;
				vala_genie_parser_next (self);
				_tmp4_ = flags;
				flags = _tmp4_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_INLINE:
			{
				ValaGenieParserModifierFlags _tmp5_ = 0;
				vala_genie_parser_next (self);
				_tmp5_ = flags;
				flags = _tmp5_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_NEW:
			{
				ValaGenieParserModifierFlags _tmp6_ = 0;
				vala_genie_parser_next (self);
				_tmp6_ = flags;
				flags = _tmp6_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OVERRIDE:
			{
				ValaGenieParserModifierFlags _tmp7_ = 0;
				vala_genie_parser_next (self);
				_tmp7_ = flags;
				flags = _tmp7_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_SEALED:
			{
				ValaGenieParserModifierFlags _tmp8_ = 0;
				vala_genie_parser_next (self);
				_tmp8_ = flags;
				flags = _tmp8_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_SEALED;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_STATIC:
			{
				ValaGenieParserModifierFlags _tmp9_ = 0;
				vala_genie_parser_next (self);
				_tmp9_ = flags;
				flags = _tmp9_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_VIRTUAL:
			{
				ValaGenieParserModifierFlags _tmp10_ = 0;
				vala_genie_parser_next (self);
				_tmp10_ = flags;
				flags = _tmp10_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_PRIVATE:
			{
				ValaGenieParserModifierFlags _tmp11_ = 0;
				vala_genie_parser_next (self);
				_tmp11_ = flags;
				flags = _tmp11_ | VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaParameter* vala_genie_parser_parse_parameter (ValaGenieParser* self, GError** error) {
	ValaParameter* result = NULL;
	ValaList* attrs = NULL;
	ValaList* _tmp0_ = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	gboolean params_array = FALSE;
	gboolean _tmp8_ = FALSE;
	ValaParameterDirection direction = 0;
	gboolean _tmp9_ = FALSE;
	gchar* id = NULL;
	gchar* _tmp11_ = NULL;
	ValaDataType* type = NULL;
	ValaParameterDirection _tmp12_ = 0;
	ValaParameter* param = NULL;
	const gchar* _tmp20_ = NULL;
	ValaDataType* _tmp21_ = NULL;
	ValaSourceLocation _tmp22_ = {0};
	ValaSourceReference* _tmp23_ = NULL;
	ValaSourceReference* _tmp24_ = NULL;
	ValaParameter* _tmp25_ = NULL;
	ValaParameter* _tmp26_ = NULL;
	ValaParameter* _tmp27_ = NULL;
	ValaList* _tmp28_ = NULL;
	ValaParameter* _tmp29_ = NULL;
	ValaParameterDirection _tmp30_ = 0;
	ValaParameter* _tmp31_ = NULL;
	gboolean _tmp32_ = FALSE;
	gboolean _tmp33_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_parse_attributes (self, TRUE, &_inner_error_);
	attrs = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_get_location (self, &_tmp1_);
	begin = _tmp1_;
	_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ELLIPSIS);
	if (_tmp2_) {
		ValaSourceLocation _tmp3_ = {0};
		ValaSourceReference* _tmp4_ = NULL;
		ValaSourceReference* _tmp5_ = NULL;
		ValaParameter* _tmp6_ = NULL;
		ValaParameter* _tmp7_ = NULL;
		_tmp3_ = begin;
		_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = vala_parameter_new_with_ellipsis (_tmp5_);
		_tmp7_ = _tmp6_;
		_vala_source_reference_unref0 (_tmp5_);
		result = _tmp7_;
		_vala_iterable_unref0 (attrs);
		return result;
	}
	_tmp8_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_PARAMS);
	params_array = _tmp8_;
	direction = VALA_PARAMETER_DIRECTION_IN;
	_tmp9_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OUT);
	if (_tmp9_) {
		direction = VALA_PARAMETER_DIRECTION_OUT;
	} else {
		gboolean _tmp10_ = FALSE;
		_tmp10_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REF);
		if (_tmp10_) {
			direction = VALA_PARAMETER_DIRECTION_REF;
		}
	}
	_tmp11_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
	id = _tmp11_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (attrs);
			return NULL;
		} else {
			_vala_iterable_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_iterable_unref0 (attrs);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_iterable_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp12_ = direction;
	if (_tmp12_ == VALA_PARAMETER_DIRECTION_IN) {
		ValaDataType* _tmp13_ = NULL;
		ValaDataType* _tmp14_ = NULL;
		_tmp14_ = vala_genie_parser_parse_type (self, FALSE, FALSE, &_inner_error_);
		_tmp13_ = _tmp14_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_iterable_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_iterable_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (type);
		type = _tmp13_;
	} else {
		ValaParameterDirection _tmp15_ = 0;
		_tmp15_ = direction;
		if (_tmp15_ == VALA_PARAMETER_DIRECTION_REF) {
			ValaDataType* _tmp16_ = NULL;
			ValaDataType* _tmp17_ = NULL;
			_tmp17_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			_tmp16_ = _tmp17_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (type);
			type = _tmp16_;
		} else {
			ValaDataType* _tmp18_ = NULL;
			ValaDataType* _tmp19_ = NULL;
			_tmp19_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
			_tmp18_ = _tmp19_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					_vala_iterable_unref0 (attrs);
					return NULL;
				} else {
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					_vala_iterable_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_vala_code_node_unref0 (type);
			type = _tmp18_;
		}
	}
	_tmp20_ = id;
	_tmp21_ = type;
	_tmp22_ = begin;
	_tmp23_ = vala_genie_parser_get_src (self, &_tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = vala_parameter_new (_tmp20_, _tmp21_, _tmp24_);
	_tmp26_ = _tmp25_;
	_vala_source_reference_unref0 (_tmp24_);
	param = _tmp26_;
	_tmp27_ = param;
	_tmp28_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp27_, _tmp28_);
	_tmp29_ = param;
	_tmp30_ = direction;
	vala_parameter_set_direction (_tmp29_, _tmp30_);
	_tmp31_ = param;
	_tmp32_ = params_array;
	vala_parameter_set_params_array (_tmp31_, _tmp32_);
	_tmp33_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN);
	if (_tmp33_) {
		ValaExpression* _tmp34_ = NULL;
		ValaExpression* _tmp35_ = NULL;
		ValaParameter* _tmp36_ = NULL;
		ValaExpression* _tmp37_ = NULL;
		_tmp35_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		_tmp34_ = _tmp35_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_iterable_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_iterable_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp36_ = param;
		_tmp37_ = _tmp34_;
		vala_variable_set_initializer ((ValaVariable*) _tmp36_, _tmp37_);
		_vala_code_node_unref0 (_tmp37_);
	}
	result = param;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	_vala_iterable_unref0 (attrs);
	return result;
}


static ValaCreationMethod* vala_genie_parser_parse_creation_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaCreationMethod* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaCreationMethod* method = NULL;
	gboolean _tmp1_ = FALSE;
	ValaGenieTokenType _tmp46_ = 0;
	gboolean _tmp53_ = FALSE;
	ValaCreationMethod* _tmp61_ = NULL;
	ValaCreationMethod* _tmp62_ = NULL;
	ValaList* _tmp63_ = NULL;
	ValaCreationMethod* _tmp64_ = NULL;
	gboolean _tmp65_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_parse_member_declaration_modifiers (self);
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	if (_tmp1_) {
		const gchar* _tmp2_ = NULL;
		ValaSourceLocation _tmp3_ = {0};
		ValaSourceReference* _tmp4_ = NULL;
		ValaSourceReference* _tmp5_ = NULL;
		ValaComment* _tmp6_ = NULL;
		ValaCreationMethod* _tmp7_ = NULL;
		_tmp2_ = self->priv->class_name;
		_tmp3_ = begin;
		_tmp4_ = vala_genie_parser_get_src (self, &_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = self->priv->comment;
		_tmp7_ = vala_creation_method_new (_tmp2_, NULL, _tmp5_, _tmp6_);
		_vala_code_node_unref0 (method);
		method = _tmp7_;
		_vala_source_reference_unref0 (_tmp5_);
	} else {
		ValaUnresolvedSymbol* sym = NULL;
		ValaUnresolvedSymbol* _tmp8_ = NULL;
		ValaUnresolvedSymbol* _tmp9_ = NULL;
		ValaUnresolvedSymbol* _tmp10_ = NULL;
		ValaUnresolvedSymbol* _tmp11_ = NULL;
		_tmp8_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
		sym = _tmp8_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp9_ = sym;
		_tmp10_ = vala_unresolved_symbol_get_inner (_tmp9_);
		_tmp11_ = _tmp10_;
		if (_tmp11_ == NULL) {
			ValaUnresolvedSymbol* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp12_ = sym;
			_tmp13_ = vala_symbol_get_name ((ValaSymbol*) _tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = self->priv->class_name;
			if (g_strcmp0 (_tmp14_, _tmp15_) != 0) {
				const gchar* _tmp16_ = NULL;
				ValaUnresolvedSymbol* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				ValaSourceLocation _tmp20_ = {0};
				ValaSourceReference* _tmp21_ = NULL;
				ValaSourceReference* _tmp22_ = NULL;
				ValaComment* _tmp23_ = NULL;
				ValaCreationMethod* _tmp24_ = NULL;
				_tmp16_ = self->priv->class_name;
				_tmp17_ = sym;
				_tmp18_ = vala_symbol_get_name ((ValaSymbol*) _tmp17_);
				_tmp19_ = _tmp18_;
				_tmp20_ = begin;
				_tmp21_ = vala_genie_parser_get_src (self, &_tmp20_);
				_tmp22_ = _tmp21_;
				_tmp23_ = self->priv->comment;
				_tmp24_ = vala_creation_method_new (_tmp16_, _tmp19_, _tmp22_, _tmp23_);
				_vala_code_node_unref0 (method);
				method = _tmp24_;
				_vala_source_reference_unref0 (_tmp22_);
			} else {
				ValaUnresolvedSymbol* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				ValaSourceLocation _tmp28_ = {0};
				ValaSourceReference* _tmp29_ = NULL;
				ValaSourceReference* _tmp30_ = NULL;
				ValaComment* _tmp31_ = NULL;
				ValaCreationMethod* _tmp32_ = NULL;
				_tmp25_ = sym;
				_tmp26_ = vala_symbol_get_name ((ValaSymbol*) _tmp25_);
				_tmp27_ = _tmp26_;
				_tmp28_ = begin;
				_tmp29_ = vala_genie_parser_get_src (self, &_tmp28_);
				_tmp30_ = _tmp29_;
				_tmp31_ = self->priv->comment;
				_tmp32_ = vala_creation_method_new (_tmp27_, NULL, _tmp30_, _tmp31_);
				_vala_code_node_unref0 (method);
				method = _tmp32_;
				_vala_source_reference_unref0 (_tmp30_);
			}
		} else {
			ValaUnresolvedSymbol* _tmp33_ = NULL;
			ValaUnresolvedSymbol* _tmp34_ = NULL;
			ValaUnresolvedSymbol* _tmp35_ = NULL;
			const gchar* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			ValaUnresolvedSymbol* _tmp38_ = NULL;
			const gchar* _tmp39_ = NULL;
			const gchar* _tmp40_ = NULL;
			ValaSourceLocation _tmp41_ = {0};
			ValaSourceReference* _tmp42_ = NULL;
			ValaSourceReference* _tmp43_ = NULL;
			ValaComment* _tmp44_ = NULL;
			ValaCreationMethod* _tmp45_ = NULL;
			_tmp33_ = sym;
			_tmp34_ = vala_unresolved_symbol_get_inner (_tmp33_);
			_tmp35_ = _tmp34_;
			_tmp36_ = vala_symbol_get_name ((ValaSymbol*) _tmp35_);
			_tmp37_ = _tmp36_;
			_tmp38_ = sym;
			_tmp39_ = vala_symbol_get_name ((ValaSymbol*) _tmp38_);
			_tmp40_ = _tmp39_;
			_tmp41_ = begin;
			_tmp42_ = vala_genie_parser_get_src (self, &_tmp41_);
			_tmp43_ = _tmp42_;
			_tmp44_ = self->priv->comment;
			_tmp45_ = vala_creation_method_new (_tmp37_, _tmp40_, _tmp43_, _tmp44_);
			_vala_code_node_unref0 (method);
			method = _tmp45_;
			_vala_source_reference_unref0 (_tmp43_);
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (sym);
	}
	_tmp46_ = vala_genie_parser_current (self);
	if (_tmp46_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp47_ = FALSE;
			_tmp47_ = TRUE;
			while (TRUE) {
				gboolean _tmp48_ = FALSE;
				ValaParameter* param = NULL;
				ValaParameter* _tmp50_ = NULL;
				ValaCreationMethod* _tmp51_ = NULL;
				ValaParameter* _tmp52_ = NULL;
				_tmp48_ = _tmp47_;
				if (!_tmp48_) {
					gboolean _tmp49_ = FALSE;
					_tmp49_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp49_) {
						break;
					}
				}
				_tmp47_ = FALSE;
				_tmp50_ = vala_genie_parser_parse_parameter (self, &_inner_error_);
				param = _tmp50_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp51_ = method;
				_tmp52_ = param;
				vala_method_add_parameter ((ValaMethod*) _tmp51_, _tmp52_);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp53_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES);
	if (_tmp53_) {
		{
			gboolean _tmp54_ = FALSE;
			_tmp54_ = TRUE;
			while (TRUE) {
				gboolean _tmp55_ = FALSE;
				ValaDataType* _tmp57_ = NULL;
				ValaDataType* _tmp58_ = NULL;
				ValaCreationMethod* _tmp59_ = NULL;
				ValaDataType* _tmp60_ = NULL;
				_tmp55_ = _tmp54_;
				if (!_tmp55_) {
					gboolean _tmp56_ = FALSE;
					_tmp56_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp56_) {
						break;
					}
				}
				_tmp54_ = FALSE;
				_tmp58_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				_tmp57_ = _tmp58_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp59_ = method;
				_tmp60_ = _tmp57_;
				vala_code_node_add_error_type ((ValaCodeNode*) _tmp59_, _tmp60_);
				_vala_code_node_unref0 (_tmp60_);
			}
		}
	}
	_tmp61_ = method;
	vala_symbol_set_access ((ValaSymbol*) _tmp61_, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
	_tmp62_ = method;
	_tmp63_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp62_, _tmp63_);
	_tmp64_ = method;
	vala_method_set_binding ((ValaMethod*) _tmp64_, VALA_MEMBER_BINDING_STATIC);
	_tmp65_ = vala_genie_parser_accept_block (self);
	if (_tmp65_) {
		ValaBlock* _tmp66_ = NULL;
		ValaBlock* _tmp67_ = NULL;
		ValaCreationMethod* _tmp68_ = NULL;
		ValaBlock* _tmp69_ = NULL;
		_tmp67_ = vala_genie_parser_parse_block (self, &_inner_error_);
		_tmp66_ = _tmp67_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp68_ = method;
		_tmp69_ = _tmp66_;
		vala_subroutine_set_body ((ValaSubroutine*) _tmp68_, _tmp69_);
		_vala_code_node_unref0 (_tmp69_);
	} else {
		ValaGenieScanner* _tmp70_ = NULL;
		ValaSourceFile* _tmp71_ = NULL;
		ValaSourceFile* _tmp72_ = NULL;
		ValaSourceFileType _tmp73_ = 0;
		ValaSourceFileType _tmp74_ = 0;
		_tmp70_ = self->priv->scanner;
		_tmp71_ = vala_genie_scanner_get_source_file (_tmp70_);
		_tmp72_ = _tmp71_;
		_tmp73_ = vala_source_file_get_file_type (_tmp72_);
		_tmp74_ = _tmp73_;
		if (_tmp74_ == VALA_SOURCE_FILE_TYPE_PACKAGE) {
			ValaCreationMethod* _tmp75_ = NULL;
			_tmp75_ = method;
			vala_symbol_set_external ((ValaSymbol*) _tmp75_, TRUE);
		}
	}
	result = method;
	return result;
}


static ValaSymbol* vala_genie_parser_parse_delegate_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaDataType* type = NULL;
	ValaGenieParserModifierFlags flags = 0;
	ValaGenieParserModifierFlags _tmp1_ = 0;
	ValaUnresolvedSymbol* sym = NULL;
	ValaUnresolvedSymbol* _tmp2_ = NULL;
	ValaList* type_param_list = NULL;
	ValaList* _tmp3_ = NULL;
	ValaGenieParserModifierFlags _tmp4_ = 0;
	ValaArrayList* params = NULL;
	GEqualFunc _tmp9_ = NULL;
	ValaArrayList* _tmp10_ = NULL;
	ValaGenieTokenType _tmp11_ = 0;
	gboolean _tmp18_ = FALSE;
	ValaDelegate* d = NULL;
	ValaUnresolvedSymbol* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	ValaDataType* _tmp25_ = NULL;
	ValaSourceLocation _tmp26_ = {0};
	ValaSourceReference* _tmp27_ = NULL;
	ValaSourceReference* _tmp28_ = NULL;
	ValaComment* _tmp29_ = NULL;
	ValaDelegate* _tmp30_ = NULL;
	ValaDelegate* _tmp31_ = NULL;
	gboolean _tmp32_ = FALSE;
	ValaGenieParserModifierFlags _tmp40_ = 0;
	ValaGenieParserModifierFlags _tmp47_ = 0;
	gboolean _tmp49_ = FALSE;
	ValaGenieParserModifierFlags _tmp50_ = 0;
	gboolean _tmp56_ = FALSE;
	ValaDelegate* _tmp58_ = NULL;
	ValaList* _tmp59_ = NULL;
	ValaSymbol* _result_ = NULL;
	ValaDelegate* _tmp86_ = NULL;
	ValaSymbol* _tmp87_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DELEGATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_member_declaration_modifiers (self);
	flags = _tmp1_;
	_tmp2_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	sym = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	type_param_list = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = flags;
	if ((_tmp4_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		GError* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		_tmp5_ = vala_genie_parser_get_error (self, "`new' modifier not allowed on delegates");
		_tmp6_ = _tmp5_;
		_tmp7_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp6_);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		_inner_error_ = _tmp8_;
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = g_direct_equal;
	_tmp10_ = vala_array_list_new (VALA_TYPE_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp9_);
	params = _tmp10_;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp11_ = vala_genie_parser_current (self);
	if (_tmp11_ != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				gboolean _tmp13_ = FALSE;
				ValaParameter* param = NULL;
				ValaParameter* _tmp15_ = NULL;
				ValaArrayList* _tmp16_ = NULL;
				ValaParameter* _tmp17_ = NULL;
				_tmp13_ = _tmp12_;
				if (!_tmp13_) {
					gboolean _tmp14_ = FALSE;
					_tmp14_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp14_) {
						break;
					}
				}
				_tmp12_ = FALSE;
				_tmp15_ = vala_genie_parser_parse_parameter (self, &_inner_error_);
				param = _tmp15_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (params);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_iterable_unref0 (params);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp16_ = params;
				_tmp17_ = param;
				vala_collection_add ((ValaCollection*) _tmp16_, _tmp17_);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp18_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	if (_tmp18_) {
		ValaDataType* _tmp19_ = NULL;
		ValaDataType* _tmp20_ = NULL;
		_tmp20_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		_tmp19_ = _tmp20_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_iterable_unref0 (params);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_iterable_unref0 (params);
				_vala_iterable_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (type);
		type = _tmp19_;
	} else {
		ValaVoidType* _tmp21_ = NULL;
		_tmp21_ = vala_void_type_new (NULL);
		_vala_code_node_unref0 (type);
		type = (ValaDataType*) _tmp21_;
	}
	_tmp22_ = sym;
	_tmp23_ = vala_symbol_get_name ((ValaSymbol*) _tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = type;
	_tmp26_ = begin;
	_tmp27_ = vala_genie_parser_get_src (self, &_tmp26_);
	_tmp28_ = _tmp27_;
	_tmp29_ = self->priv->comment;
	_tmp30_ = vala_delegate_new (_tmp24_, _tmp25_, _tmp28_, _tmp29_);
	_tmp31_ = _tmp30_;
	_vala_source_reference_unref0 (_tmp28_);
	d = _tmp31_;
	_tmp32_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES);
	if (_tmp32_) {
		{
			gboolean _tmp33_ = FALSE;
			_tmp33_ = TRUE;
			while (TRUE) {
				gboolean _tmp34_ = FALSE;
				ValaDataType* _tmp36_ = NULL;
				ValaDataType* _tmp37_ = NULL;
				ValaDelegate* _tmp38_ = NULL;
				ValaDataType* _tmp39_ = NULL;
				_tmp34_ = _tmp33_;
				if (!_tmp34_) {
					gboolean _tmp35_ = FALSE;
					_tmp35_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp35_) {
						break;
					}
				}
				_tmp33_ = FALSE;
				_tmp37_ = vala_genie_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				_tmp36_ = _tmp37_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (d);
						_vala_iterable_unref0 (params);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (d);
						_vala_iterable_unref0 (params);
						_vala_iterable_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp38_ = d;
				_tmp39_ = _tmp36_;
				vala_code_node_add_error_type ((ValaCodeNode*) _tmp38_, _tmp39_);
				_vala_code_node_unref0 (_tmp39_);
			}
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			_vala_iterable_unref0 (params);
			_vala_iterable_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp40_ = flags;
	if ((_tmp40_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		ValaDelegate* _tmp41_ = NULL;
		_tmp41_ = d;
		vala_symbol_set_access ((ValaSymbol*) _tmp41_, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		ValaDelegate* _tmp42_ = NULL;
		ValaUnresolvedSymbol* _tmp43_ = NULL;
		const gchar* _tmp44_ = NULL;
		const gchar* _tmp45_ = NULL;
		ValaSymbolAccessibility _tmp46_ = 0;
		_tmp42_ = d;
		_tmp43_ = sym;
		_tmp44_ = vala_symbol_get_name ((ValaSymbol*) _tmp43_);
		_tmp45_ = _tmp44_;
		_tmp46_ = vala_genie_parser_get_access (self, _tmp45_);
		vala_symbol_set_access ((ValaSymbol*) _tmp42_, _tmp46_);
	}
	_tmp47_ = flags;
	if ((_tmp47_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		ValaDelegate* _tmp48_ = NULL;
		_tmp48_ = d;
		vala_delegate_set_has_target (_tmp48_, FALSE);
	}
	_tmp50_ = flags;
	if ((_tmp50_ & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp49_ = TRUE;
	} else {
		ValaGenieScanner* _tmp51_ = NULL;
		ValaSourceFile* _tmp52_ = NULL;
		ValaSourceFile* _tmp53_ = NULL;
		ValaSourceFileType _tmp54_ = 0;
		ValaSourceFileType _tmp55_ = 0;
		_tmp51_ = self->priv->scanner;
		_tmp52_ = vala_genie_scanner_get_source_file (_tmp51_);
		_tmp53_ = _tmp52_;
		_tmp54_ = vala_source_file_get_file_type (_tmp53_);
		_tmp55_ = _tmp54_;
		_tmp49_ = _tmp55_ == VALA_SOURCE_FILE_TYPE_PACKAGE;
	}
	_tmp56_ = _tmp49_;
	if (_tmp56_) {
		ValaDelegate* _tmp57_ = NULL;
		_tmp57_ = d;
		vala_symbol_set_external ((ValaSymbol*) _tmp57_, TRUE);
	}
	_tmp58_ = d;
	_tmp59_ = attrs;
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) _tmp58_, _tmp59_);
	{
		ValaList* _type_param_list = NULL;
		ValaList* _tmp60_ = NULL;
		ValaList* _tmp61_ = NULL;
		gint _type_param_size = 0;
		ValaList* _tmp62_ = NULL;
		gint _tmp63_ = 0;
		gint _tmp64_ = 0;
		gint _type_param_index = 0;
		_tmp60_ = type_param_list;
		_tmp61_ = _vala_iterable_ref0 (_tmp60_);
		_type_param_list = _tmp61_;
		_tmp62_ = _type_param_list;
		_tmp63_ = vala_collection_get_size ((ValaCollection*) _tmp62_);
		_tmp64_ = _tmp63_;
		_type_param_size = _tmp64_;
		_type_param_index = -1;
		while (TRUE) {
			gint _tmp65_ = 0;
			gint _tmp66_ = 0;
			gint _tmp67_ = 0;
			ValaTypeParameter* type_param = NULL;
			ValaList* _tmp68_ = NULL;
			gint _tmp69_ = 0;
			gpointer _tmp70_ = NULL;
			ValaDelegate* _tmp71_ = NULL;
			ValaTypeParameter* _tmp72_ = NULL;
			_tmp65_ = _type_param_index;
			_type_param_index = _tmp65_ + 1;
			_tmp66_ = _type_param_index;
			_tmp67_ = _type_param_size;
			if (!(_tmp66_ < _tmp67_)) {
				break;
			}
			_tmp68_ = _type_param_list;
			_tmp69_ = _type_param_index;
			_tmp70_ = vala_list_get (_tmp68_, _tmp69_);
			type_param = (ValaTypeParameter*) _tmp70_;
			_tmp71_ = d;
			_tmp72_ = type_param;
			vala_delegate_add_type_parameter (_tmp71_, _tmp72_);
			_vala_code_node_unref0 (type_param);
		}
		_vala_iterable_unref0 (_type_param_list);
	}
	{
		ValaArrayList* _formal_param_list = NULL;
		ValaArrayList* _tmp73_ = NULL;
		ValaArrayList* _tmp74_ = NULL;
		gint _formal_param_size = 0;
		ValaArrayList* _tmp75_ = NULL;
		gint _tmp76_ = 0;
		gint _tmp77_ = 0;
		gint _formal_param_index = 0;
		_tmp73_ = params;
		_tmp74_ = _vala_iterable_ref0 (_tmp73_);
		_formal_param_list = _tmp74_;
		_tmp75_ = _formal_param_list;
		_tmp76_ = vala_collection_get_size ((ValaCollection*) _tmp75_);
		_tmp77_ = _tmp76_;
		_formal_param_size = _tmp77_;
		_formal_param_index = -1;
		while (TRUE) {
			gint _tmp78_ = 0;
			gint _tmp79_ = 0;
			gint _tmp80_ = 0;
			ValaParameter* formal_param = NULL;
			ValaArrayList* _tmp81_ = NULL;
			gint _tmp82_ = 0;
			gpointer _tmp83_ = NULL;
			ValaDelegate* _tmp84_ = NULL;
			ValaParameter* _tmp85_ = NULL;
			_tmp78_ = _formal_param_index;
			_formal_param_index = _tmp78_ + 1;
			_tmp79_ = _formal_param_index;
			_tmp80_ = _formal_param_size;
			if (!(_tmp79_ < _tmp80_)) {
				break;
			}
			_tmp81_ = _formal_param_list;
			_tmp82_ = _formal_param_index;
			_tmp83_ = vala_list_get ((ValaList*) _tmp81_, _tmp82_);
			formal_param = (ValaParameter*) _tmp83_;
			_tmp84_ = d;
			_tmp85_ = formal_param;
			vala_delegate_add_parameter (_tmp84_, _tmp85_);
			_vala_code_node_unref0 (formal_param);
		}
		_vala_iterable_unref0 (_formal_param_list);
	}
	_tmp86_ = d;
	_tmp87_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp86_);
	_result_ = _tmp87_;
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp88_ = NULL;
		ValaUnresolvedSymbol* _tmp89_ = NULL;
		ValaUnresolvedSymbol* _tmp90_ = NULL;
		ValaUnresolvedSymbol* _tmp91_ = NULL;
		ValaUnresolvedSymbol* _tmp92_ = NULL;
		ValaUnresolvedSymbol* _tmp93_ = NULL;
		ValaUnresolvedSymbol* _tmp94_ = NULL;
		ValaNamespace* ns = NULL;
		ValaUnresolvedSymbol* _tmp95_ = NULL;
		const gchar* _tmp96_ = NULL;
		const gchar* _tmp97_ = NULL;
		ValaDelegate* _tmp98_ = NULL;
		ValaSourceReference* _tmp99_ = NULL;
		ValaSourceReference* _tmp100_ = NULL;
		ValaNamespace* _tmp101_ = NULL;
		ValaSymbol* _tmp102_ = NULL;
		ValaNamespace* _tmp107_ = NULL;
		ValaSymbol* _tmp108_ = NULL;
		_tmp88_ = sym;
		_tmp89_ = vala_unresolved_symbol_get_inner (_tmp88_);
		_tmp90_ = _tmp89_;
		if (!(_tmp90_ != NULL)) {
			break;
		}
		_tmp91_ = sym;
		_tmp92_ = vala_unresolved_symbol_get_inner (_tmp91_);
		_tmp93_ = _tmp92_;
		_tmp94_ = _vala_code_node_ref0 (_tmp93_);
		_vala_code_node_unref0 (sym);
		sym = _tmp94_;
		_tmp95_ = sym;
		_tmp96_ = vala_symbol_get_name ((ValaSymbol*) _tmp95_);
		_tmp97_ = _tmp96_;
		_tmp98_ = d;
		_tmp99_ = vala_code_node_get_source_reference ((ValaCodeNode*) _tmp98_);
		_tmp100_ = _tmp99_;
		_tmp101_ = vala_namespace_new (_tmp97_, _tmp100_);
		ns = _tmp101_;
		_tmp102_ = _result_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp102_, VALA_TYPE_NAMESPACE)) {
			ValaNamespace* _tmp103_ = NULL;
			ValaSymbol* _tmp104_ = NULL;
			_tmp103_ = ns;
			_tmp104_ = _result_;
			vala_symbol_add_namespace ((ValaSymbol*) _tmp103_, G_TYPE_CHECK_INSTANCE_CAST (_tmp104_, VALA_TYPE_NAMESPACE, ValaNamespace));
		} else {
			ValaNamespace* _tmp105_ = NULL;
			ValaSymbol* _tmp106_ = NULL;
			_tmp105_ = ns;
			_tmp106_ = _result_;
			vala_symbol_add_delegate ((ValaSymbol*) _tmp105_, G_TYPE_CHECK_INSTANCE_CAST (_tmp106_, VALA_TYPE_DELEGATE, ValaDelegate));
		}
		_tmp107_ = ns;
		_tmp108_ = _vala_code_node_ref0 ((ValaSymbol*) _tmp107_);
		_vala_code_node_unref0 (_result_);
		_result_ = _tmp108_;
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (d);
	_vala_iterable_unref0 (params);
	_vala_iterable_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaList* vala_genie_parser_parse_type_parameter_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF);
	if (_tmp0_) {
		ValaArrayList* list = NULL;
		GEqualFunc _tmp1_ = NULL;
		ValaArrayList* _tmp2_ = NULL;
		_tmp1_ = g_direct_equal;
		_tmp2_ = vala_array_list_new (VALA_TYPE_TYPEPARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp1_);
		list = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				ValaSourceLocation begin = {0};
				ValaSourceLocation _tmp6_ = {0};
				gchar* id = NULL;
				gchar* _tmp7_ = NULL;
				ValaArrayList* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				ValaSourceLocation _tmp10_ = {0};
				ValaSourceReference* _tmp11_ = NULL;
				ValaSourceReference* _tmp12_ = NULL;
				ValaTypeParameter* _tmp13_ = NULL;
				ValaTypeParameter* _tmp14_ = NULL;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gboolean _tmp5_ = FALSE;
					_tmp5_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp5_) {
						break;
					}
				}
				_tmp3_ = FALSE;
				vala_genie_parser_get_location (self, &_tmp6_);
				begin = _tmp6_;
				_tmp7_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
				id = _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_iterable_unref0 (list);
						return NULL;
					} else {
						_vala_iterable_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				_tmp8_ = list;
				_tmp9_ = id;
				_tmp10_ = begin;
				_tmp11_ = vala_genie_parser_get_src (self, &_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = vala_typeparameter_new (_tmp9_, _tmp12_);
				_tmp14_ = _tmp13_;
				vala_collection_add ((ValaCollection*) _tmp8_, _tmp14_);
				_vala_code_node_unref0 (_tmp14_);
				_vala_source_reference_unref0 (_tmp12_);
				_g_free0 (id);
			}
		}
		result = (ValaList*) list;
		return result;
	} else {
		ValaList* _tmp15_ = NULL;
		ValaList* _tmp18_ = NULL;
		ValaList* _tmp19_ = NULL;
		_tmp15_ = vala_genie_parser__empty_type_parameter_list;
		if (_tmp15_ == NULL) {
			GEqualFunc _tmp16_ = NULL;
			ValaArrayList* _tmp17_ = NULL;
			_tmp16_ = g_direct_equal;
			_tmp17_ = vala_array_list_new (VALA_TYPE_TYPEPARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp16_);
			_vala_iterable_unref0 (vala_genie_parser__empty_type_parameter_list);
			vala_genie_parser__empty_type_parameter_list = (ValaList*) _tmp17_;
		}
		_tmp18_ = vala_genie_parser__empty_type_parameter_list;
		_tmp19_ = _vala_iterable_ref0 (_tmp18_);
		result = _tmp19_;
		return result;
	}
}


static void vala_genie_parser_skip_type_argument_list (ValaGenieParser* self, GError** error) {
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF);
	if (_tmp0_) {
		gboolean _tmp1_ = FALSE;
		_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
		if (_tmp1_) {
			{
				gboolean _tmp2_ = FALSE;
				_tmp2_ = TRUE;
				while (TRUE) {
					gboolean _tmp3_ = FALSE;
					_tmp3_ = _tmp2_;
					if (!_tmp3_) {
						gboolean _tmp4_ = FALSE;
						_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp4_) {
							break;
						}
					}
					_tmp2_ = FALSE;
					vala_genie_parser_skip_type (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			{
				gboolean _tmp5_ = FALSE;
				_tmp5_ = TRUE;
				while (TRUE) {
					gboolean _tmp6_ = FALSE;
					_tmp6_ = _tmp5_;
					if (!_tmp6_) {
						gboolean _tmp7_ = FALSE;
						_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
						if (!_tmp7_) {
							break;
						}
					}
					_tmp5_ = FALSE;
					vala_genie_parser_skip_type (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
		}
	}
}


static ValaList* vala_genie_parser_parse_type_argument_list (ValaGenieParser* self, gboolean maybe_expression, GError** error) {
	ValaList* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF);
	if (_tmp1_) {
		ValaArrayList* list = NULL;
		GEqualFunc _tmp2_ = NULL;
		ValaArrayList* _tmp3_ = NULL;
		gboolean inParens = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp13_ = FALSE;
		_tmp2_ = g_direct_equal;
		_tmp3_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, _tmp2_);
		list = _tmp3_;
		inParens = FALSE;
		_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
		if (_tmp4_) {
			inParens = TRUE;
		}
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_ = FALSE;
				ValaGenieTokenType _tmp8_ = 0;
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					gboolean _tmp7_ = FALSE;
					_tmp7_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA);
					if (!_tmp7_) {
						break;
					}
				}
				_tmp5_ = FALSE;
				_tmp8_ = vala_genie_parser_current (self);
				switch (_tmp8_) {
					case VALA_GENIE_TOKEN_TYPE_VOID:
					case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
					case VALA_GENIE_TOKEN_TYPE_UNOWNED:
					case VALA_GENIE_TOKEN_TYPE_WEAK:
					case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
					{
						ValaDataType* type = NULL;
						ValaDataType* _tmp9_ = NULL;
						ValaArrayList* _tmp10_ = NULL;
						ValaDataType* _tmp11_ = NULL;
						_tmp9_ = vala_genie_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
						type = _tmp9_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_iterable_unref0 (list);
								return NULL;
							} else {
								_vala_iterable_unref0 (list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						_tmp10_ = list;
						_tmp11_ = type;
						vala_collection_add ((ValaCollection*) _tmp10_, _tmp11_);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						ValaSourceLocation _tmp12_ = {0};
						_tmp12_ = begin;
						vala_genie_parser_rollback (self, &_tmp12_);
						result = NULL;
						_vala_iterable_unref0 (list);
						return result;
					}
				}
			}
		}
		_tmp13_ = inParens;
		if (_tmp13_) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_iterable_unref0 (list);
					return NULL;
				} else {
					_vala_iterable_unref0 (list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
		result = (ValaList*) list;
		return result;
	}
	result = NULL;
	return result;
}


static ValaMemberAccess* vala_genie_parser_parse_member_name (ValaGenieParser* self, ValaExpression* base_expr, GError** error) {
	ValaMemberAccess* result = NULL;
	ValaSourceLocation begin = {0};
	ValaSourceLocation _tmp0_ = {0};
	ValaMemberAccess* expr = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_get_location (self, &_tmp0_);
	begin = _tmp0_;
	expr = NULL;
	{
		gboolean _tmp1_ = FALSE;
		_tmp1_ = TRUE;
		while (TRUE) {
			gboolean _tmp2_ = FALSE;
			gchar* id = NULL;
			gchar* _tmp4_ = NULL;
			ValaList* type_arg_list = NULL;
			ValaList* _tmp5_ = NULL;
			ValaExpression* _tmp6_ = NULL;
			ValaMemberAccess* _tmp7_ = NULL;
			ValaExpression* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			ValaSourceLocation _tmp12_ = {0};
			ValaSourceReference* _tmp13_ = NULL;
			ValaSourceReference* _tmp14_ = NULL;
			ValaMemberAccess* _tmp15_ = NULL;
			ValaList* _tmp16_ = NULL;
			_tmp2_ = _tmp1_;
			if (!_tmp2_) {
				gboolean _tmp3_ = FALSE;
				_tmp3_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			_tmp4_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			id = _tmp4_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp5_ = vala_genie_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
			type_arg_list = _tmp5_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp7_ = expr;
			if (_tmp7_ != NULL) {
				ValaMemberAccess* _tmp8_ = NULL;
				_tmp8_ = expr;
				_tmp6_ = (ValaExpression*) _tmp8_;
			} else {
				ValaExpression* _tmp9_ = NULL;
				_tmp9_ = base_expr;
				_tmp6_ = _tmp9_;
			}
			_tmp10_ = _tmp6_;
			_tmp11_ = id;
			_tmp12_ = begin;
			_tmp13_ = vala_genie_parser_get_src (self, &_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = vala_member_access_new (_tmp10_, _tmp11_, _tmp14_);
			_vala_code_node_unref0 (expr);
			expr = _tmp15_;
			_vala_source_reference_unref0 (_tmp14_);
			_tmp16_ = type_arg_list;
			if (_tmp16_ != NULL) {
				{
					ValaList* _type_arg_list = NULL;
					ValaList* _tmp17_ = NULL;
					ValaList* _tmp18_ = NULL;
					gint _type_arg_size = 0;
					ValaList* _tmp19_ = NULL;
					gint _tmp20_ = 0;
					gint _tmp21_ = 0;
					gint _type_arg_index = 0;
					_tmp17_ = type_arg_list;
					_tmp18_ = _vala_iterable_ref0 (_tmp17_);
					_type_arg_list = _tmp18_;
					_tmp19_ = _type_arg_list;
					_tmp20_ = vala_collection_get_size ((ValaCollection*) _tmp19_);
					_tmp21_ = _tmp20_;
					_type_arg_size = _tmp21_;
					_type_arg_index = -1;
					while (TRUE) {
						gint _tmp22_ = 0;
						gint _tmp23_ = 0;
						gint _tmp24_ = 0;
						ValaDataType* type_arg = NULL;
						ValaList* _tmp25_ = NULL;
						gint _tmp26_ = 0;
						gpointer _tmp27_ = NULL;
						ValaMemberAccess* _tmp28_ = NULL;
						ValaDataType* _tmp29_ = NULL;
						_tmp22_ = _type_arg_index;
						_type_arg_index = _tmp22_ + 1;
						_tmp23_ = _type_arg_index;
						_tmp24_ = _type_arg_size;
						if (!(_tmp23_ < _tmp24_)) {
							break;
						}
						_tmp25_ = _type_arg_list;
						_tmp26_ = _type_arg_index;
						_tmp27_ = vala_list_get (_tmp25_, _tmp26_);
						type_arg = (ValaDataType*) _tmp27_;
						_tmp28_ = expr;
						_tmp29_ = type_arg;
						vala_member_access_add_type_argument (_tmp28_, _tmp29_);
						_vala_code_node_unref0 (type_arg);
					}
					_vala_iterable_unref0 (_type_arg_list);
				}
			}
			_vala_iterable_unref0 (type_arg_list);
			_g_free0 (id);
		}
	}
	result = expr;
	return result;
}


static ValaGenieParserTokenInfo* vala_genie_parser_token_info_dup (const ValaGenieParserTokenInfo* self) {
	ValaGenieParserTokenInfo* dup;
	dup = g_new0 (ValaGenieParserTokenInfo, 1);
	memcpy (dup, self, sizeof (ValaGenieParserTokenInfo));
	return dup;
}


static void vala_genie_parser_token_info_free (ValaGenieParserTokenInfo* self) {
	g_free (self);
}


static GType vala_genie_parser_token_info_get_type (void) {
	static volatile gsize vala_genie_parser_token_info_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_token_info_type_id__volatile)) {
		GType vala_genie_parser_token_info_type_id;
		vala_genie_parser_token_info_type_id = g_boxed_type_register_static ("ValaGenieParserTokenInfo", (GBoxedCopyFunc) vala_genie_parser_token_info_dup, (GBoxedFreeFunc) vala_genie_parser_token_info_free);
		g_once_init_leave (&vala_genie_parser_token_info_type_id__volatile, vala_genie_parser_token_info_type_id);
	}
	return vala_genie_parser_token_info_type_id__volatile;
}


static void vala_genie_parser_class_init (ValaGenieParserClass * klass) {
	vala_genie_parser_parent_class = g_type_class_peek_parent (klass);
	VALA_CODE_VISITOR_CLASS (klass)->finalize = vala_genie_parser_finalize;
	g_type_class_add_private (klass, sizeof (ValaGenieParserPrivate));
	VALA_CODE_VISITOR_CLASS (klass)->visit_source_file = vala_genie_parser_real_visit_source_file;
}


static void vala_genie_parser_instance_init (ValaGenieParser * self) {
	self->priv = VALA_GENIE_PARSER_GET_PRIVATE (self);
}


static void vala_genie_parser_finalize (ValaCodeVisitor* obj) {
	ValaGenieParser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_GENIE_TYPE_PARSER, ValaGenieParser);
	_vala_genie_scanner_unref0 (self->priv->scanner);
	_vala_code_context_unref0 (self->priv->context);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	_vala_comment_unref0 (self->priv->comment);
	_g_free0 (self->priv->class_name);
	VALA_CODE_VISITOR_CLASS (vala_genie_parser_parent_class)->finalize (obj);
}


/**
 * Code visitor parsing all Genie source files.
 */
GType vala_genie_parser_get_type (void) {
	static volatile gsize vala_genie_parser_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaGenieParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_genie_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaGenieParser), 0, (GInstanceInitFunc) vala_genie_parser_instance_init, NULL };
		GType vala_genie_parser_type_id;
		vala_genie_parser_type_id = g_type_register_static (VALA_TYPE_CODE_VISITOR, "ValaGenieParser", &g_define_type_info, 0);
		g_once_init_leave (&vala_genie_parser_type_id__volatile, vala_genie_parser_type_id);
	}
	return vala_genie_parser_type_id__volatile;
}



