/* gee.vapi generated by valac, do not modify. */

namespace Vala {
	[CCode (cheader_filename = "valagee.h")]
	public class ArrayList<G> : Vala.List<G> {
		public ArrayList (GLib.EqualFunc equal_func = GLib.direct_equal);
		public override bool add (G item);
		public override void clear ();
		public override bool contains (G item);
		public override G @get (int index);
		public override GLib.Type get_element_type ();
		public override int index_of (G item);
		public override void insert (int index, G item);
		public override Vala.Iterator<G> iterator ();
		public override bool remove (G item);
		public override void remove_at (int index);
		public override void @set (int index, G item);
		public GLib.EqualFunc equal_func { set; }
		public override int size { get; }
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Collection<G> : Vala.Iterable<G> {
		public Collection ();
		public abstract bool add (G item);
		public abstract void clear ();
		public abstract bool contains (G item);
		public abstract bool remove (G item);
		public abstract int size { get; }
	}
	[CCode (cheader_filename = "valagee.h")]
	public class HashMap<K,V> : Vala.Map<K,V> {
		public HashMap (GLib.HashFunc key_hash_func = GLib.direct_hash, GLib.EqualFunc key_equal_func = GLib.direct_equal, GLib.EqualFunc value_equal_func = GLib.direct_equal);
		public override void clear ();
		public override bool contains (K key);
		public override V @get (K key);
		public override Vala.Set<K> get_keys ();
		public override Vala.Collection<V> get_values ();
		public override Vala.MapIterator<K,V> map_iterator ();
		public override bool remove (K key);
		public override void @set (K key, V value);
		public GLib.EqualFunc key_equal_func { set; }
		public GLib.HashFunc key_hash_func { set; }
		public override int size { get; }
		public GLib.EqualFunc value_equal_func { set; }
	}
	[CCode (cheader_filename = "valagee.h")]
	public class HashSet<G> : Vala.Set<G> {
		public HashSet (GLib.HashFunc hash_func = GLib.direct_hash, GLib.EqualFunc equal_func = GLib.direct_equal);
		public override bool add (G key);
		public override void clear ();
		public override bool contains (G key);
		public override GLib.Type get_element_type ();
		public override Vala.Iterator<G> iterator ();
		public override bool remove (G key);
		public GLib.EqualFunc equal_func { set; }
		public GLib.HashFunc hash_func { set; }
		public override int size { get; }
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Iterable<G> {
		public Iterable ();
		public abstract GLib.Type get_element_type ();
		public abstract Vala.Iterator<G> iterator ();
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Iterator<G> {
		public Iterator ();
		public abstract G @get ();
		public abstract bool next ();
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class List<G> : Vala.Collection<G> {
		public List ();
		public abstract G @get (int index);
		public abstract int index_of (G item);
		public abstract void insert (int index, G item);
		public abstract void remove_at (int index);
		public abstract void @set (int index, G item);
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Map<K,V> {
		public Map ();
		public abstract void clear ();
		public abstract bool contains (K key);
		public abstract V @get (K key);
		public abstract Vala.Set<K> get_keys ();
		public abstract Vala.Collection<V> get_values ();
		public abstract Vala.MapIterator<K,V> map_iterator ();
		public abstract bool remove (K key);
		public abstract void @set (K key, V value);
		public abstract int size { get; }
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class MapIterator<K,V> {
		public MapIterator ();
		public abstract K get_key ();
		public abstract V get_value ();
		public abstract bool next ();
	}
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Set<G> : Vala.Collection<G> {
		public Set ();
	}
}
