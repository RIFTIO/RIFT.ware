/*
 * Copyright (c) 2008-2014, Dave Benson and the protobuf-c authors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*! \file
 * \mainpage Introduction
 *
 * This is [protobuf-c], a C implementation of [Protocol Buffers].
 *
 * This file defines the public API for the `libprotobuf-c` support library.
 * This API includes interfaces that can be used directly by client code as well
 * as the interfaces used by the code generated by the `protoc-c` compiler.
 *
 * The `libprotobuf-c` support library performs the actual serialization and
 * deserialization of Protocol Buffers messages. It interacts with structures,
 * definitions, and metadata generated by the `protoc-c` compiler from .proto
 * files.
 *
 * \authors Dave Benson and the `protobuf-c` authors.
 *
 * \copyright 2008-2014. Licensed under the terms of the [BSD-2-Clause] license.
 *
 * [protobuf-c]:       https://github.com/protobuf-c/protobuf-c
 * [Protocol Buffers]: https://developers.google.com/protocol-buffers/
 * [BSD-2-Clause]:     http://opensource.org/licenses/BSD-2-Clause
 *
 * \page gencode Generated Code
 *
 * For each enum, we generate a C enum. For each message, we generate a C
 * structure which can be cast to a `ProtobufCMessage`.
 *
 * For each enum and message, we generate a descriptor object that allows us to
 * implement a kind of reflection on the structures.
 *
 * First, some naming conventions:
 *
 * - The name of the type for enums and messages and services is camel case
 *   (meaning WordsAreCrammedTogether) except that double underscores are used
 *   to delimit scopes. For example, the following `.proto` file:
 *
~~~{.proto}
        package foo.bar;
        message BazBah {
            optional int32 val = 1;
        }
~~~
 *
 * would generate a C type `Foo__Bar__BazBah`.
 *
 * - Identifiers for functions and globals are all lowercase, with camel case
 *   words separated by single underscores. For example, one of the function
 *   prototypes generated by `protoc-c` for the above example:
 *
~~~{.c}
Foo__Bar__BazBah *
       foo__bar__baz_bah__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
~~~
 *
 * - Identifiers for enum values contain an uppercase prefix which embeds the
 *   package name and the enum type name.
 *
 * - A double underscore is used to separate further components of identifier
 *   names.
 *
 * For example, in the name of the unpack function above, the package name
 * `foo.bar` has become `foo__bar`, the message name BazBah has become
 * `baz_bah`, and the method name is `unpack`. These are all joined with double
 * underscores to form the C identifier `foo__bar__baz_bah__unpack`.
 *
 * We also generate descriptor objects for messages and enums. These are
 * declared in the `.pb-c.h` files:
 *
~~~{.c}
extern const ProtobufCMessageDescriptor foo__bar__baz_bah__descriptor;
~~~
 *
 * The message structures all begin with `ProtobufCMessageDescriptor *` which is
 * sufficient to allow them to be cast to `ProtobufCMessage`.
 *
 * For each message defined in a `.proto` file, we generate a number of
 * functions and macros. Each function name contains a prefix based on the
 * package name and message name in order to make it a unique C identifier.
 *
 * - `INIT`. Statically initializes a message object, initializing its
 *   descriptor and setting its fields to default values. Uninitialized
 *   messages cannot be processed by the protobuf-c library.
 *
~~~{.c}
#define FOO__BAR__BAZ_BAH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&foo__bar__baz_bah__descriptor), 0 }
~~~
 * - `init()`. Initializes a message object, initializing its descriptor and
 *   setting its fields to default values. Uninitialized messages cannot be
 *   processed by the protobuf-c library.
 *
~~~{.c}
void foo__bar__baz_bah__init
                     (Foo__Bar__BazBah *message);
~~~
 * - `unpack()`. Unpacks data for a particular message format. Note that the
 *   `allocator` parameter is usually `NULL` to indicate that the system's
 *   `malloc()` and `free()` functions should be used for dynamically allocating
 *   memory.
 *
~~~{.c}
Foo__Bar__BazBah *
       foo__bar__baz_bah__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
~~~
 *
 * - `free_unpacked()`. Frees a message object obtained with the `unpack()`
 *   method.
 *
~~~{.c}
void   foo__bar__baz_bah__free_unpacked
                     (Foo__Bar__BazBah *message,
                      ProtobufCAllocator *allocator);
~~~
 *
 * - `get_packed_size()`. Calculates the length in bytes of the serialized
 *   representation of the message object.
 *
~~~{.c}
size_t foo__bar__baz_bah__get_packed_size
                     (const Foo__Bar__BazBah   *message);
~~~
 *
 * - `pack()`. Pack a message object into a preallocated buffer. Assumes that
 *   the buffer is large enough. (Use `get_packed_size()` first.)
 *
~~~{.c}
size_t foo__bar__baz_bah__pack
                     (const Foo__Bar__BazBah   *message,
                      uint8_t             *out);
~~~
 *
 * - `pack_to_buffer()`. Packs a message into a "virtual buffer". This is an
 *   object which defines an "append bytes" callback to consume data as it is
 *   serialized.
 *
~~~{.c}
size_t foo__bar__baz_bah__pack_to_buffer
                     (const Foo__Bar__BazBah   *message,
                      ProtobufCBuffer     *buffer);
~~~
 *
 * \page pack Packing and unpacking messages
 *
 * To pack a message, first compute the packed size of the message with
 * protobuf_c_message_get_packed_size(), then allocate a buffer of at least
 * that size, then call protobuf_c_message_pack().
 *
 * Alternatively, a message can be serialized without calculating the final size
 * first. Use the protobuf_c_message_pack_to_buffer() function and provide a
 * ProtobufCBuffer object which implements an "append" method that consumes
 * data.
 *
 * To unpack a message, call the protobuf_c_message_unpack() function. The
 * result can be cast to an object of the type that matches the descriptor for
 * the message.
 *
 * The result of unpacking a message should be freed with
 * protobuf_c_message_free_unpacked().
 */

#ifndef __RIFT_PROTOBUF_C_RUNTIME_H_
#define __RIFT_PROTOBUF_C_RUNTIME_H_

#include <assert.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdarg.h>
#include <errno.h>
#include <stdbool.h>

#include <glib-object.h>
#include <pthread.h>

#ifdef __cplusplus
# define PROTOBUF_C_BEGIN_DECLS  extern "C" {
# define PROTOBUF_C_END_DECLS    }
#else
# define PROTOBUF_C_BEGIN_DECLS
# define PROTOBUF_C_END_DECLS
#endif

#ifndef __GI_SCANNER__
#if defined(_WIN32) && defined(PROTOBUF_C_USE_SHARED_LIB)
# ifdef PROTOBUF_C_EXPORT
#  define PROTOBUF_C_API __declspec(dllexport)
# else
#  define PROTOBUF_C_API __declspec(dllimport)
# endif
#else
# define PROTOBUF_C_API
#endif
#else
# define PROTOBUF_C_API
#endif

PROTOBUF_C_BEGIN_DECLS

#ifndef __GI_SCANNER__


#define PROTOBUF_C_OFFSETOF(struct, member) offsetof(struct, member)
#define PROTOBUF_C_SIZEOF(struct, member) sizeof(((struct*)NULL)->member)

#define PROTOBUF_C_ASSERT(condition) assert(condition)
#define PROTOBUF_C_ASSERT_NOT_REACHED() assert(0)

#if !defined(PROTOBUF_C_NO_DEPRECATED) && \
  ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
# define PROTOBUF_C_DEPRECATED __attribute__((__deprecated__))
#else
# define PROTOBUF_C_DEPRECATED
#endif

#ifndef _PROTOBUF_C_FORCE_ENUM_TO_BE_INT_SIZE
 #define _PROTOBUF_C_FORCE_ENUM_TO_BE_INT_SIZE(enum_name) \
  , _##enum_name##_IS_INT_SIZE = INT_MAX
#endif

#ifndef _PROTOBUF_C_MAX_ENUM
 #define _PROTOBUF_C_MAX_ENUM(enum_name, value) \
  , enum_name##MAX_VALUE = value
#endif

#define PROTOBUF_C_SERVICE_DESCRIPTOR_MAGIC    0x14159bc3
#define PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC    0x28aaeef9
#define PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC       0x114315af

/*!
 * ProtobufCMessage magic field. The value of the
 * field must be PROTOBUF_C_FLAG_MAGIC_NUMBER_V1, if this
 * is a validly initialized message.
 */
#define PROTOBUF_C_FLAG_MAGIC_NUMBER_SHIFT 0
#define PROTOBUF_C_FLAG_MAGIC_NUMBER_MASK 0xFFFFFF // 24 bits for magic number
#define PROTOBUF_C_FLAG_MAGIC_NUMBER_V1 0x506243 // "PbC"

/*!
 * Temporary hack to encode a single field delete indication
 * until the complete delta support is available.
 */
#define PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_SHIFT   24
#define PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_MASK    0x1 // 1 bit to indicate that the union is unknown buffer/delta message.
#define PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_UNF     0x0 // If the unknown union is valid, then it indicates UNFs. This is the default. Not required to explicitly set it.
#define PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_DELTA   0x1 // If the unknown union is valid, then it indicates DELTA message.

/*!
 * Flags reserved for future PBC internal/user code use
 */
#define PROTOBUF_C_FLAG_MAGIC_RESERVED_SHIFT 24
#define PROTOBUF_C_FLAG_MAGIC_RESERVED_MASK 0xFF // 8 bits for future use

/*!
 * Reference count.  Limited to 16 million.  At 16 million, object
 * lives forever.
 */
#define PROTOBUF_C_FLAG_REF_COUNT_SHIFT 0
#define PROTOBUF_C_FLAG_REF_COUNT_MASK 0xFFFFFF // 3 bytes for ref count.
#define PROTOBUF_C_FLAG_REF_COUNT_MAX 0xF42400

/*!
 * Indicates message memory management and reference counting state.
 * There are three aspects being controlled: memory layout, memory
 * ownership, and reference counting.
 *
 * Memory layout referes to whether this message is embedded in another
 * message struct, and therefore does not have an independent
 * allocation of its own.  The value of this field can affect reference
 * counting and memory freeing.  There are two basic kinds of messages
 * from the LAYOUT perspective: inner and outer.  An inner message is
 * flat/inline and contained in another message's message struct.  An
 * inner message has no separate allocation or lifetime of its own.
 * An inner message always has a LAYOUT of INNER.
 *
 * An outer message is not contained as a flat/inline field of another
 * message; it may or may not have a separate memory allocation of its
 * own.  An outer message is not necessarily stored in dynamic memory -
 * it could be on a stack, or stored as a field in another struct.
 * Even in the non-dynamic memory cases, the outer message may contain
 * per-message meta-data (such as instance), or an allocator, so
 * locating and identifiying the outer message is still a usful goal.
 * An outer message has a LAYOUT of OWNED, OUTER, or GLOBAL.
 */

#define PROTOBUF_C_FLAG_REF_STATE_SHIFT 24
#define PROTOBUF_C_FLAG_REF_STATE_MASK 0xF // 4 bits for tracking msg reference state

typedef enum {

  /*!
   * UNKNOWN=0: The message is uninitialized.  This state should not
   * be encountered outside of errors.  Accesses to the message from a
   * managed language should crash.  No protobuf-c code will ever set
   * this state value - once a message has been initialized, it will
   * never revert to this state, even when freed.
   */
  PROTOBUF_C_FLAG_REF_STATE_UNKNOWN  = 0x0,

  /*!
   * INNER: This is an inner message inside another message.
   * Reference counting and memory free policies are controlled by the
   * outer-most message.  The outer_offset field contains the offset
   * to the enclosing message.
   */
  PROTOBUF_C_FLAG_REF_STATE_INNER    = 0x1,

  /*!
   *  This is an outer message, which is a global constant
   *  with infinite lifetime.  No reference counting.
   */
  PROTOBUF_C_FLAG_REF_STATE_GLOBAL   = 0x2,

  /*!
   * This is an outer message privately owned by C code that
   * wants to manage the message's lifetime explicitly.  The C code
   * requires that the message is never shared with a managed language
   * or used with reference counting - passing the message to a
   * managed language is disallowed.  In order to use this mode, C
   * code must set this state explicitly immediately after creating
   * the message.
   */
  PROTOBUF_C_FLAG_REF_STATE_PRIVATE  = 0x3,

  /*!
   * This is an outer message, where the lifetime of the memory
   * is not under protobuf-c control.  The message could be
   * dynamically allocated, embedded in some other struct, on the
   * stack, in shared memory, or otherwise directly managed by C code
   * in some other way.  Reference counting may still be applied to
   * the message, with the caveat that crashes are possible if a
   * reference is held when the message is ultimately explicitly
   * destroyed in C.
   */
  PROTOBUF_C_FLAG_REF_STATE_OWNED    = 0x4,

  /*!
   * This is an outer message, where the lifetime of the memory
   * is not under protobuf-c control.  The only difference between
   * OWNED and SHARED is that with SHARED, the message is being
   * reference counted.  The message is still owned by C, and
   * reference counting does not control memory lifetime (other than
   * by detecting error cases and crashing).
   */
  PROTOBUF_C_FLAG_REF_STATE_SHARED   = 0x5,

  /*!
   * This is an outer message, where the lifetime of the
   * memory is fully under protobuf-c control.  The message is
   * reference counted.  The GI constructor always sets this mode.  C
   * code must set this state explicitly immeditely after creating the
   * message, in order to use this mode.
   */
  PROTOBUF_C_FLAG_REF_STATE_COUNTED  = 0x6,

  /*!
   * The message is partially freed; free is in progress.
   * Accesses to the message from a managed language should throw an
   * exception.
   */
  PROTOBUF_C_FLAG_REF_STATE_DELETING = 0x7,

  /*!
   * The message has been freed.  Accesses to the message
   * from a managed language should throw an exception.
   */
  PROTOBUF_C_FLAG_REF_STATE_INVALID  = 0x8

} ProtobufCReferenceState;

#define PROTOBUF_C_CREATE_REF_FLAG(ref_state) \
    (ref_state << PROTOBUF_C_FLAG_REF_STATE_SHIFT)

/*!
 * Macro to access the flags.
 */
#define PROTOBUF_C_FLAG_GET(var_, name_) \
   (((var_) >> PROTOBUF_C_FLAG_ ##name_## _SHIFT) & PROTOBUF_C_FLAG_ ##name_## _MASK)

#define PROTOBUF_C_FLAG_CLR(var_, name_) \
    var_ &= ~(PROTOBUF_C_FLAG_ ##name_## _MASK << PROTOBUF_C_FLAG_ ##name_## _SHIFT)

#define PROTOBUF_C_FLAG_SET(var_, name_, value_) \
    PROTOBUF_C_FLAG_CLR(var_, name_); \
    var_ |= (value_ << PROTOBUF_C_FLAG_ ##name_## _SHIFT)

#define PROTOBUF_C_SET_FIELD_INFO(f ,fd, val)       \
  memset (&f, 0, sizeof (f)); \
  f.element = val;            \
  f.fdesc = fd;

#define PROTOBUF_C_MIN(a, b) \
    a > b ? b : a;

#define PROTOBUF_C_MAX(a, b) \
    a > b ? a : b;

/*!
 * \defgroup api Public API
 *
 * This is the public API for `libprotobuf-c`. These interfaces are stable and
 * subject to Semantic Versioning guarantees.
 *
 * @{
 */

/*!
 * Values for the `flags` word in `ProtobufCFieldDescriptor`.
 */
typedef enum {
  /*! Set if the field is repeated and marked with the `packed` option. */
  PROTOBUF_C_FIELD_FLAG_PACKED = (1 << 0),

  /*! Set if the field is marked with the `deprecated` option. */
  PROTOBUF_C_FIELD_FLAG_DEPRECATED = (1 << 1),

  /*! Set if the field is a member of a oneof (union). */
  PROTOBUF_C_FIELD_FLAG_ONEOF = (1 << 2),
} ProtobufCFieldFlag;

/*!
 * Message field rules.
 *
 * \see [Defining A Message Type] in the Protocol Buffers documentation.
 *
 * [Defining A Message Type]:
 *      https://developers.google.com/protocol-buffers/docs/proto#simple
 */
typedef enum {
  /*! A well-formed message must have exactly one of this field. */
  PROTOBUF_C_LABEL_REQUIRED,

  /*!
   * A well-formed message can have zero or one of this field (but not
   * more than one).
   */
  PROTOBUF_C_LABEL_OPTIONAL,

  /*!
   * This field can be repeated any number of times (including zero) in a
   * well-formed message. The order of the repeated values will be
   * preserved.
   */
  PROTOBUF_C_LABEL_REPEATED,
} ProtobufCLabel;

/*!
 * Field value types.
 *
 * \see [Scalar Value Types] in the Protocol Buffers documentation.
 *
 * [Scalar Value Types]:
 *      https://developers.google.com/protocol-buffers/docs/proto#scalar
 */
typedef enum {
  PROTOBUF_C_TYPE_INT32,      /*!< int32 */
  PROTOBUF_C_TYPE_SINT32,     /*!< signed int32 */
  PROTOBUF_C_TYPE_SFIXED32,   /*!< signed int32 (4 bytes) */
  PROTOBUF_C_TYPE_INT64,      /*!< int64 */
  PROTOBUF_C_TYPE_SINT64,     /*!< signed int64 */
  PROTOBUF_C_TYPE_SFIXED64,   /*!< signed int64 (8 bytes) */
  PROTOBUF_C_TYPE_UINT32,     /*!< unsigned int32 */
  PROTOBUF_C_TYPE_FIXED32,    /*!< unsigned int32 (4 bytes) */
  PROTOBUF_C_TYPE_UINT64,     /*!< unsigned int64 */
  PROTOBUF_C_TYPE_FIXED64,    /*!< unsigned int64 (8 bytes) */
  PROTOBUF_C_TYPE_FLOAT,      /*!< float */
  PROTOBUF_C_TYPE_DOUBLE,     /*!< double */
  PROTOBUF_C_TYPE_BOOL,       /*!< boolean */
  PROTOBUF_C_TYPE_ENUM,       /*!< enumerated type */
  PROTOBUF_C_TYPE_STRING,     /*!< UTF-8 or ASCII string */
  PROTOBUF_C_TYPE_BYTES,      /*!< arbitrary byte sequence */
  PROTOBUF_C_TYPE_MESSAGE,    /*!< nested message */
} ProtobufCType;

/*!
 * Field wire types.
 *
 * \see [Message Structure] in the Protocol Buffers documentation.
 *
 * [Message Structure]:
 *      https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
typedef enum {
  PROTOBUF_C_WIRE_TYPE_VARINT = 0,
  PROTOBUF_C_WIRE_TYPE_64BIT = 1,
  PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED = 2,
  /* "Start group" and "end group" wire types are unsupported. */
  PROTOBUF_C_WIRE_TYPE_32BIT = 5,
} ProtobufCWireType;


#endif /* __GI_SCANNER__ */


struct ProtobufCBinaryData;
struct ProtobufCBuffer;
struct ProtobufCBufferSimple;
struct ProtobufCEnumDescriptor;
struct ProtobufCEnumValue;
struct ProtobufCEnumValueIndex;
struct ProtobufCFieldDescriptor;
struct ProtobufCIntRange;
struct ProtobufCMessage;
struct ProtobufCMessageDescriptor;
struct ProtobufCUnknownFieldBase;
struct ProtobufCUnknownUnionMax;
union  ProtobufCMessageUnknownField;
struct ProtobufCUnknownSerialized;
struct ProtobufCUnknownMessageCast;
struct ProtobufCMessageUnknownFields;
struct ProtobufCMethodDescriptor;
struct ProtobufCService;
struct ProtobufCServiceDescriptor;
struct ProtobufCInstance;
struct ProtobufCCharBuffer;
union  ProtobufCScalarFieldUnion;

/*! Rift-define types.. start */
struct ProtobufCFlatBinaryData;
struct ProtobufCInstance;
struct ProtobufCCTypeDescriptor;
struct rw_yang_pb_enumdesc_t;
struct rw_yang_pb_msgdesc_t;
struct ProtobufCGiMessageBase;
struct ProtobufCGiMessageBox;
struct ProtobufCMessageGiDescriptor;
struct ProtobufCStats;
struct ProtobufCReferenceHeader;
struct ProtobufCDeleteDelta;
struct ProtobufCMessageDebugStats;
typedef struct ProtobufCFlatBinaryData ProtobufCFlatBinaryData;
typedef struct ProtobufCInstance ProtobufCInstance;
typedef struct ProtobufCCTypeDescriptor ProtobufCCTypeDescriptor;
typedef struct ProtobufCFieldInfo ProtobufCFieldInfo;
typedef struct ProtobufCGiMessageBase ProtobufCGiMessageBase;
typedef struct ProtobufCGiMessageBox ProtobufCGiMessageBox;
typedef struct ProtobufCMessageGiDescriptor ProtobufCMessageGiDescriptor;
typedef struct ProtobufCStats ProtobufCStats;
typedef struct ProtobufCReferenceHeader ProtobufCReferenceHeader;
typedef struct ProtobufCDeleteDelta ProtobufCDeleteDelta;
typedef union ProtobufCScalarFieldUnion ProtobufCScalarFieldUnion;
typedef struct ProtobufCMessageDebugStats ProtobufCMessageDebugStats;
/*! Rift-define types.. end */

typedef struct ProtobufCBinaryData ProtobufCBinaryData;
typedef struct ProtobufCBuffer ProtobufCBuffer;
typedef struct ProtobufCBufferSimple ProtobufCBufferSimple;
typedef struct ProtobufCEnumDescriptor ProtobufCEnumDescriptor;
typedef struct ProtobufCEnumValue ProtobufCEnumValue;
typedef struct ProtobufCEnumValueIndex ProtobufCEnumValueIndex;
typedef struct ProtobufCFieldDescriptor ProtobufCFieldDescriptor;
typedef struct ProtobufCIntRange ProtobufCIntRange;
typedef struct ProtobufCMessage ProtobufCMessage;
typedef struct ProtobufCMessageDescriptor ProtobufCMessageDescriptor;
typedef struct ProtobufCUnknownFieldBase ProtobufCUnknownFieldBase;
typedef struct ProtobufCUnknownUnionMax ProtobufCUnknownUnionMax;
typedef struct ProtobufCUnknownSerialized ProtobufCUnknownSerialized;
typedef struct ProtobufCUnknownMessageCast ProtobufCUnknownMessageCast;
typedef union ProtobufCMessageUnknownField ProtobufCMessageUnknownField;
typedef struct ProtobufCMessageUnknownFields ProtobufCMessageUnknownFields;
typedef struct ProtobufCMethodDescriptor ProtobufCMethodDescriptor;
typedef struct ProtobufCService ProtobufCService;
typedef struct ProtobufCServiceDescriptor ProtobufCServiceDescriptor;
typedef struct ProtobufCSerializedSort ProtobufCSerializedSort;
typedef struct ProtobufCSerializedSortMgr ProtobufCSerializedSortMgr;
typedef struct ProtobufCPackOptions ProtobufCPackOptions;
typedef struct ProtobufCCharBuffer ProtobufCCharBuffer;


#ifndef __GI_SCANNER__
#define protobuf_c_boolean gboolean
#else
/*! Boolean type. */
typedef int protobuf_c_boolean;
#endif /* __GI_SCANNER__ */


#ifndef __GI_SCANNER__


typedef void (*ProtobufCClosure)(const ProtobufCMessage *, void *closure_data);
typedef void (*ProtobufCMessageInit)(ProtobufCMessage *);
typedef void (*ProtobufCServiceDestroy)(ProtobufCService *);

/*!
 * Structure for the protobuf `bytes` scalar type.
 *
 * The data contained in a `ProtobufCBinaryData` is an arbitrary sequence of
 * bytes. It may contain embedded `NUL` characters and is not required to be
 * `NUL`-terminated.
 */
struct ProtobufCBinaryData {
  size_t   len;        /*!< Number of bytes in the `data` field. */
  uint8_t  *data;      /*!< Data bytes. */
};

/*!
 * Structure for defining a virtual append-only buffer. Used by
 * protobuf_c_message_pack_to_buffer() to abstract the consumption of serialized
 * bytes.
 *
 * `ProtobufCBuffer` "subclasses" may be defined on the stack. For example, to
 * write to a `FILE` object:
 *
~~~{.c}
typedef struct {
        ProtobufCBuffer base;
        FILE *fp;
} BufferAppendToFile;

static void
my_buffer_file_append(ProtobufCBuffer *buffer,
                      size_t len,
                      const uint8_t *data)
{
        BufferAppendToFile *file_buf = (BufferAppendToFile *) buffer;
        fwrite(data, len, 1, file_buf->fp); // XXX: No error handling!
}
~~~
 *
 * To use this new type of ProtobufCBuffer, it could be called as follows:
 *
~~~{.c}
...
BufferAppendToFile tmp = {0};
tmp.base.append = my_buffer_file_append;
tmp.fp = fp;
protobuf_c_message_pack_to_buffer(&message, &tmp);
...
~~~
 */
struct ProtobufCBuffer {
  /*! Append function. Consumes the `len` bytes stored at `data`. */
  void (*append)(ProtobufCBuffer *buffer,
          size_t len,
          const uint8_t *data);
  ProtobufCInstance*  instance;
};

/*
 * This is a configurable, default instance.  By default, it uses the
 * system allocator (meaning malloc() and free()).  This is typically
 * changed to adapt to frameworks that provide some nonstandard
 * allocation functions.
 *
 * NOTE: you may modify this instance.
 */
extern PROTOBUF_C_API ProtobufCInstance protobuf_c_default_instance; /* settable */

/*!
 * GI reference-management mutex.
 */
PROTOBUF_C_API
extern pthread_mutex_t protobuf_c_gi_ref_mutex;

/*!
 * GI reference-management mutex lock guard lock.  Obtains the mutex
 * and returns a magic value, which can be passed to the release
 * function for validation, or to detect (intentional) early releases.
 *
 * @return - A magic number to indicate that the lock is taken.
 */
PROTOBUF_C_API
extern intptr_t protobuf_c_gi_mutex_guard_lock(void);

/*!
 * GI reference-management mutex lock guard release.  Used in
 * conjunction with a gcc-cleanup attribute to automatcially release a
 * mutex lock.  May also be called directly to explicitly release a
 * lock early.
 */
PROTOBUF_C_API
extern void protobuf_c_gi_mutex_guard_release(intptr_t* guard);


/*!
 * Define and set a local variable to guard the global mutex, and
 * obtain the mutex.  The guard will auto-destroy on scope exit, and
 * release lock.
 */
#define PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE() \
  PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE_NAMED(__LINE__)

/*!
 * Define and set a local variable to guard the global mutex, and
 * obtain the mutex.  Give the mutex a specific name.  The guard will
 * auto-destroy on scope exit, and release lock.  The lock may be
 * released early.
 */
#define PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE_NAMED(name_) \
  PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE_NAMED_1(name_)

#define PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE_NAMED_1(name_) \
  intptr_t protobuf_c_gi_mutex_guard_##name_ \
        __attribute__((__cleanup__(protobuf_c_gi_mutex_guard_release))) \
    = protobuf_c_gi_mutex_guard_lock()

/*!
 * Release the guarded global mutex, if currently held.
 */
#define PROTOBUF_C_GI_MUTEX_GUARD_RELEASE(name_) \
  protobuf_c_gi_mutex_guard_release(&(protobuf_c_gi_mutex_guard_##name_))


/*!
 * Simple buffer "subclass" of `ProtobufCBuffer`.
 *
 * A `ProtobufCBufferSimple` object is declared on the stack and uses a
 * scratch buffer provided by the user for the initial allocation. It performs
 * exponential resizing, using dynamically allocated memory. A
 * `ProtobufCBufferSimple` object can be created and used as follows:
 *
~~~{.c}
uint8_t pad[128];
ProtobufCBufferSimple simple = PROTOBUF_C_BUFFER_SIMPLE_INIT(pad);
ProtobufCBuffer *buffer = (ProtobufCBuffer *) &simple;
~~~
 *
 * `buffer` can now be used with `protobuf_c_message_pack_to_buffer()`. Once a
 * message has been serialized to a `ProtobufCBufferSimple` object, the
 * serialized data bytes can be accessed from the `.data` field.
 *
 * To free the memory allocated by a `ProtobufCBufferSimple` object, if any,
 * call PROTOBUF_C_BUFFER_SIMPLE_CLEAR() on the object, for example:
 *
~~~{.c}
PROTOBUF_C_BUFFER_SIMPLE_CLEAR(&simple);
~~~
 *
 * \see PROTOBUF_C_BUFFER_SIMPLE_INIT
 * \see PROTOBUF_C_BUFFER_SIMPLE_CLEAR
 */
struct ProtobufCBufferSimple {
  /*! "Base class". */
  ProtobufCBuffer base;

  /*! Number of bytes allocated in `data`. */
  size_t alloced;

  /*! Number of bytes currently stored in `data`. */
  size_t len;

  /*! Data bytes. */
  uint8_t *data;

  /*! Whether `data` must be freed. */
  protobuf_c_boolean must_free_data;
};

struct ProtobufCCharBuffer {

  /*! The `ProtobufCInstance` pointer */
  ProtobufCInstance* instance;

  /*! Pointer to char buffer, either stack_buf or dynamically allocated. */
  char *buffer;

  /*! Size of the buffer */
  size_t buf_len;

  /*! Local stack buffer */
  char stack_buf [4096];

  /*! Flag to indicate whether to free buffer if it was dynamically allocated. Redundant but it is ok. */
  protobuf_c_boolean free_buf;
};

/*!
 * Describes an enumeration as a whole, with all of its values.
 */
struct ProtobufCEnumDescriptor {
  /*! Magic value checked to ensure that the API is used correctly. */
  uint32_t magic;

  /*! The qualified name (e.g., "namespace.Type"). */
  const char *name;

  /*! The unqualified name as given in the .proto file (e.g., "Type"). */
  const char *short_name;

  /*! Identifier used in generated C code. */
  const char *c_name;

  /*! The dot-separated namespace. */
  const char *package_name;

  /*! Number elements in `values`. */
  unsigned n_values;

  /*! Array of distinct values, sorted by numeric value. */
  const ProtobufCEnumValue *values;

  /*! Number of elements in `values_by_name`. */
  unsigned n_value_names;

  /*! Array of named values, including aliases, sorted by name. */
  const ProtobufCEnumValueIndex *values_by_name;

  /*! Number of elements in `value_ranges`. */
  unsigned n_value_ranges;

  /*! Value ranges, for faster lookups by numeric value. */
  const ProtobufCIntRange *value_ranges;

  /*! Reserved for future use. */
  void *reserved1;

  /*! Reserved for future use. */
  void *reserved2;

  /*! Reserved for future use. */
  void *reserved3;

  /*! Reserved for future use. */
  void *reserved4;

  /*! Rift ypbc enum descriptor. */
  const struct rw_yang_pb_enumdesc_t *rw_yang_enum;
};

/*!
 * Represents a single value of an enumeration.
 */
struct ProtobufCEnumValue {
  /*! The string identifying this value in the .proto file. */
  const char *name;

  /*! The string identifying this value in generated C code. */
  const char *c_name;

  /*! The numeric value assigned in the .proto file. */
  int value;
};

/*!
 * Used by `ProtobufCEnumDescriptor` to look up enum values.
 */
struct ProtobufCEnumValueIndex {
  /*! Name of the enum value. */
  const char *name;

  /*! Index into values[] array. */
  unsigned index;
};

/*!
 * Describes a single field in a message.
 */
struct ProtobufCFieldDescriptor {
  /*! Name of the field as given in the .proto file. */
  const char *name;

  /*! Name of the field as given in C and GI. */
  const char *c_name;

  /*! Tag value of the field as given in the .proto file. */
  uint32_t id;

  /*! Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */
  ProtobufCLabel label;

  /*! The type of the field. */
  ProtobufCType type;

  /*!
   * The offset in bytes of the message's C structure's quantifier field
   * (the `has_MEMBER` field for optional members or the `n_MEMBER` field
   * for repeated members or the case enum for oneofs).
   */
  unsigned quantifier_offset;

  /*!
   * The offset in bytes into the message's C structure for the member
   * itself.
   */
  unsigned offset;

  /*!
   * A type-specific descriptor.
   */
  union {
    /*!
     * If `type` is neither `PROTOBUF_C_TYPE_ENUM` nor `PROTOBUF_C_TYPE_MESSAGE`,
     * then this field is NULL and should only be accessed via this member.
     */
    const void* descriptor; /* ATTN: Temporary during cutover time */

    /*!
     * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to
     * the corresponding `ProtobufCMessageDescriptor`.
     */
    const ProtobufCMessageDescriptor* msg_desc;

    /*!
     * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the
     * corresponding `ProtobufCEnumDescriptor`.
     */
    const ProtobufCEnumDescriptor* enum_desc;
  };

  /*! The default value for this field, if defined. May be NULL. */
  const void *default_value;

  /*!
   * A flag word. Zero or more of the bits defined in the
   * `ProtobufCFieldFlag` enum may be set.
   */
  uint32_t flags;

  /*! Reserved for future use. */
  unsigned reserved_flags;

  /*! Reserved for future use. */
  void *reserved2;

  /*! Reserved for future use. */
  void *reserved3;

  /*! Rift field options. */
  uint32_t rw_flags;

  /*! Rift inline max value for the field. */
  uint32_t rw_inline_max;

  /*! Rift. size of the field. */
  size_t data_size;

  /*! Rift. CType descriptor if the field is rift defined c-type. */
  const ProtobufCCTypeDescriptor* ctype;
};

/*!
 * Helper structure for optimizing int => index lookups in the case
 * where the keys are mostly consecutive values, as they presumably are for
 * enums and fields.
 *
 * The data structures requires that the values in the original array are
 * sorted.
 */
struct ProtobufCIntRange {
  int start_value;
  unsigned orig_index;
  /*
   * NOTE: the number of values in the range can be inferred by looking
   * at the next element's orig_index. A dummy element is added to make
   * this simple.
   */
};

/*!
 * The ReferenceHeader structure.
 * This tracks the reference state of any object that use this
 * structure for reference counting management.
 *
 * Apart from tracking the reference state, the structure
 * also holds the `ProtobufCInstance` pointer that was used to
 * allocate the object, the pbcm message pointer in case of non-message
 * object.
 */
struct ProtobufCReferenceHeader {
  /*! The message magic number and message allocation flags. */
  uint32_t magic_flags;

  /*! The message reference count and deletion control flags. */
  uint32_t ref_flags;

  union {
    /*!
     *  For outer-most message, the protobuf-c instance that
     *  allocated this message
     */
    ProtobufCInstance* instance; // for message users

    /*!
     * For non-message structures like unknown fields,
     * a back pointer to the holding message.
     */
    ProtobufCMessage* message; // for non-message users

    /*!
     *  If this is an inner (inline) message, then this value, negated
     *  and multiplied by sizeof(intptr_t), is the byte offset to the
     *  outer-most message.
     */
    intptr_t outer_offset; // for inner objects, regardless
  };
};

/*!
 * Temporary hack to encode a delete delta.
 */
struct ProtobufCDeleteDelta {
  /*!
   * Indication whether this message was deleted.
   */
  protobuf_c_boolean me;
  /*!
   * The tag number of the field in the message
   * that was deleted.
   */
  uint32_t child_tag;
};


/*!
 * An instance of a message.
 *
 * `ProtobufCMessage` is a light-weight "base class" for all messages.
 *
 * In particular, `ProtobufCMessage` doesn't have any allocation policy
 * associated with it. That's because it's common to create `ProtobufCMessage`
 * objects on the stack. In fact, that's what we recommend for sending messages.
 * If the object is allocated from the stack, you can't really have a memory
 * leak.
 *
 * This means that calls to functions like protobuf_c_message_unpack() which
 * return a `ProtobufCMessage` must be paired with a call to a free function,
 * like protobuf_c_message_free_unpacked().
 */
struct ProtobufCMessage {

  /*! A common header that keeps track of the reference state of the message. */
  ProtobufCReferenceHeader ref_hdr;

  /*! The descriptor for this message type. */
  const ProtobufCMessageDescriptor *descriptor;

  union {
    /*! The fields that weren't recognized by the parser. */
    ProtobufCMessageUnknownFields* unknown_buffer;

    /*!
     * Temporary hack to send delete indication in the message.
     * PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_MASK indicates what the union contains.
     */
    ProtobufCDeleteDelta* delete_delta;
  };
};


/*!
 * GI boxed message unreference funtion.  This is used to release a
 * reference to a parent box, or a reference held by a function.  The
 * caller MUST NOT refer to the box again after this call.
 */
typedef void (*ProtobufCMessageGiUnref)(
  ProtobufCGiMessageBox *parent);

/*!
 * GI boxed message invalidation funtion.  This is used to destroy a
 * message before all of the references to the box have been cleared.
 * Any use of the box after this function will produce an exception.
 */
typedef void (*ProtobufCMessageGiInvalidate)(
  ProtobufCGiMessageBox *parent);

/*!
 * GI message creation function.  Returns an entirely new boxed object,
 * with the caller's reference already accounted for.  The caller takes
 * ownership of and is responsible for freeing this initial reference.
 */
typedef ProtobufCGiMessageBox* (*ProtobufCMessageGiNewCreate)(void);

/*!
 * GI message adoption function.  Returns a new box that contains the
 * passed message.  The caller's reference is already accounted for in
 * the box.  The caller takes ownership of and is responsible for
 * freeing this initial reference.  The caller must GIVE ownership of
 * the message to the box; no code should retain a reference to the
 * message after this call.
 *
 * This cannot be used to adopt any of the following:
 *  - A const message.
 *  - A message that is already owned by another message or box.
 *  - A message that is already owned by C.
 */
typedef ProtobufCGiMessageBox* (*ProtobufCMessageGiNewAdopt)(
  ProtobufCMessage* adopt_message,
  ProtobufCGiMessageBox* parent,
  ProtobufCMessageGiUnref parent_unref);

/*!
 * Protobuf C GI boxed structure base.  This is used as the base for
 * every boxed GI message, for reference and ownership tracking.
 *
 * ATTN: If/when pooled allocation and/or an allocation header is
 * created, this may go away or become a vastly different type.
 */
struct ProtobufCGiMessageBase {
  /*! Memory validation */
  int magic;

  /*! Reference count. ATTN: Should be an atomic type! */
  int ref_count;

  /*!
   * Parent box, if any.  May be NULL.  If not NULL, then this box
   * holds a reference to the parent's box.
   */
  ProtobufCGiMessageBox *parent;

  /*!
   * Function to call to remove this box's reference to the parent's
   * box.
   *
   * ATTN: This should be deleted from here and into generic function call,
   * through descriptor introspection?  Also, probably disappears with
   * pooled allocator or allocation header.
   */
  ProtobufCMessageGiUnref parent_unref;
};
#define PROTOBUF_C_GI_BOX_MAGIC 0x45F2FFFE
#define PROTOBUF_C_GI_BASE_IS_GOOD( gi_base_ ) \
  ( \
      NULL != (gi_base_) \
   && (gi_base_)->magic == PROTOBUF_C_GI_BOX_MAGIC \
  )

/*!
 * Common GI boxed message structure, with message pointer.  This
 * should be type-punnable with the generated message boxes.
 */
struct ProtobufCGiMessageBox {
  ProtobufCGiMessageBase gi_base;
  ProtobufCMessage* message;
};

/*!
 * Protobuf-C GI descriptor.  Defines the GI interface to a mesage
 * type.
 */
struct ProtobufCMessageGiDescriptor {

  /*! Function to create a new box. */
  ProtobufCMessageGiNewCreate new_create;

  /*! Function to adopt an existing message into a new box. */
  ProtobufCMessageGiNewAdopt new_adopt;

  /*! Release a reference. */
  ProtobufCMessageGiUnref unref;

  /*! Invalidate the box and free the message */
  ProtobufCMessageGiInvalidate invalidate;

  /*! GI typename (not including module) */
  const char* name;

  /*! The size of the GI box. */
  size_t boxed_size;
};

/*!
 * Protobuf-C read-write statistics descriptor.
 */
struct ProtobufCMessageDebugStats {

  /*! Number of times a message has been initted (both inner and outer). */
  int init_count;

  /*! Number of times a message has been initted (inner only). */
  int init_inner_count;

  /*! Number of times a message has been freed (outer only). */
  int free_outer_count;

  /*! Number of times a message has been freed (usebody form). */
  int free_usebody_count;

  /*! Number of times a message has been referenced by GI (not counting new). */
  int gi_ref_count;

  /*! Number of times a message has been referenced by GI. */
  int gi_new_adopt_count;

  /*! Number of references invalidated . */
  int gi_invalidate_count;

  /*! Number of references turned into zombies . */
  int gi_zombie_count;

  /*! Number of zombie references revived. */
  int gi_revive_count;

  /*! Number of times a message has been unreferenced by GI. */
  int gi_unref_count;
};

/*!
 * Describes a message.
 */
struct ProtobufCMessageDescriptor {
  /*! Magic value checked to ensure that the API is used correctly. */
  uint32_t magic;

  /*! The qualified name (e.g., "namespace.Type"). */
  const char *name;

  /*! The unqualified name as given in the .proto file (e.g., "Type"). */
  const char *short_name;

  /*! Identifier used in generated C code. */
  const char *c_name;

  /*! The dot-separated namespace. */
  const char *package_name;

  /*!
   * Size in bytes of the C structure representing an instance of this
   * type of message.
   */
  size_t sizeof_message;

  /*! Number of elements in `fields`. */
  unsigned n_fields;

  /*! Field descriptors, sorted by tag number. */
  const ProtobufCFieldDescriptor *fields;

  /*! Used for looking up fields by name. */
  const unsigned *fields_sorted_by_name;

  /*! Number of elements in `field_ranges`. */
  unsigned n_field_ranges;

  /*! Used for looking up fields by id. */
  const ProtobufCIntRange *field_ranges;

  /*! Pointer to a const message initialization object. */
  const ProtobufCMessage* init_value;

  /*! GI descriptor, if any. */
  const ProtobufCMessageGiDescriptor *gi_descriptor;

  /*! Reserved for future use. */
  void *reserved1;

  /*! Reserved for future use. */
  void *reserved2;

  /*! Reserved for future use. */
  void *reserved3;

  /*! Rift message options. */
  uint32_t rw_flags;

  /*! Rift ypbc message descriptor. */
  const struct rw_yang_pb_msgdesc_t* ypbc_mdesc;

  /*! Debug statistics per messabge type. */
  ProtobufCMessageDebugStats* debug_stats;
};

/*!
 * Union that is used to unpack the unknown scalar fields.
 * ATTN: This is temporary, this should be merged with the
 * unknown field union.
 */
union ProtobufCScalarFieldUnion {

  int32_t  int32_v;
  int64_t  int64_v;
  uint32_t uint32_v;
  uint64_t uint64_v;
  float    float_v;
  double   double_v;
  char     *char_v;
  ProtobufCBinaryData bytes_v;
};

struct ProtobufCUnknownFieldBase {
  /*! The tag number. */
  uint32_t tag;

 /*! Flags indicating the contents of u.
  * Default is ProtobufCUnknownSerialized
  */
  uint32_t unknown_flags;
};

/*!
 * Intended maximum size of ProtobufCMessageUnknownField. Should
 * be large enough to hold a ProtobufCMessage*, a ProtobufCFieldDescriptor*,
 * and any single scalar field type.
 */
struct ProtobufCUnknownUnionMax {
  ProtobufCUnknownFieldBase base_;
  ProtobufCMessage* pbcm;
  ProtobufCFieldDescriptor* pbcfd;
  union {
    double d;
    ProtobufCBinaryData bin;
  } u;
};

/*!
 * Serialized unknown field.  Bag of bytes.  UNION_EXTRA contains the
 * wire type.
 */
struct ProtobufCUnknownSerialized {
  ProtobufCUnknownFieldBase base_;
  /*! Number of bytes in `data`. */
  size_t len;

  /*! Wire type of the data. */
  ProtobufCWireType wire_type;

  /*! Field data. */
  uint8_t *data;
};

/*!
 * Deserialized unknown field, which is cast to a specific message type
 * (as indicated by a particular field descriptor).
 */
struct ProtobufCUnknownMessageCast {
  ProtobufCUnknownFieldBase base_;
  /*! The field descriptor for the message. */
  const ProtobufCFieldDescriptor* fdesc;

  /*! The message in the unknown field. */
  ProtobufCMessage* message;
};

/*!
 * An unknown message field.
 */
union ProtobufCMessageUnknownField {
  ProtobufCUnknownFieldBase base_;

  ProtobufCUnknownUnionMax max;
  ProtobufCUnknownSerialized serialized;
  ProtobufCUnknownMessageCast cmessage;
};

/*
 * Union discriminator for unknown fields.  Defines the contents of
 * ProtobufCMessageUnknownField.u.  Additional information about the
 * union member might also be found in UNION_EXTRA, as noted below.
 *
 * - SERIALIZED: Raw serialized data from the wire, bumpy pointer,
 *   with length.  UNION_EXTRA contains the wire type.
 * - MESSAGE_CAST: The unknown field has been cast into a message type
 *   using a field descriptor (from the same message, another
 *   tag-compatible message, or generic message type).  The members of
 *   the field descriptor that relate to message struct offsets should
 *   be ignored - because they refer to a struct that does not exist.
 *   Additionally, flags for inline, and the label should also be
 *   ignored.  ATTN: Repeated is not currently supported, although
 *   that may change in the future.  UNION_EXTRA is unused.
 *
 * ATTN: Some thoughts on potential future conversions:
 * - FDESC_CAST: The unknown field has been cast into a known type
 *   using a field descriptor, with support for all types, not just
 *   message.  UNION_EXTRA is unused.
 * - PB_CAST: The unknown field has been cast into a protobuf type
 *   without using a field descriptor.  UNION_EXTRA contains PB type.
 * - SERIALIZED_SHORT: Raw serialized data from the wire, short enough
 *   to be included in the union directly, no pointer needed.
 *   UNION_EXTRA contains the length of the serialized data (which
 *   must be less than sizeof(ProtobufCUnknownUnionMax).
 */
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SHIFT 0
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MASK 0xF
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED 0x0
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST 0x1
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_2 0x2
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_3 0x3
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_4 0x4
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_5 0x5
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_6 0x6
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_7 0x7
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_8 0x8
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_9 0x9
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_A 0xA
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_B 0xB
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_C 0xC
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_D 0xD
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_E 0xE
#define PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_RESERVED_F 0xF

/*!
 * List of unknown fields that the parser doesn't understand.
 */
struct ProtobufCMessageUnknownFields {
  /*! The instance that allocated the fields. */
  ProtobufCInstance*  instance;

  /* ATTN: Need the owning message? */

  /*! The number of elements in `unknown_fields`. */
  unsigned n_unknown_fields;

  /*! The fields that weren't recognized by the parser. */
  ProtobufCMessageUnknownField *unknown_fields;
};

/*!
 * Method descriptor.
 */
struct ProtobufCMethodDescriptor {
  /*! Method name. */
  const char *name;

  /*! Input message descriptor. */
  const ProtobufCMessageDescriptor *input;

  /*! Output message descriptor. */
  const ProtobufCMessageDescriptor *output;

  uint32_t rw_methno;
  uint32_t rw_flags:24;
  uint8_t rw_pri;

};

/*!
 * Service.
 */
struct ProtobufCService {
  /*! Service descriptor. */
  const ProtobufCServiceDescriptor *descriptor;

  /*! Channel binding */
  void *rw_context;

  void *rw_usercontext;

  /*! Function to invoke the service. */
  void (*invoke)(ProtobufCService *service,
           unsigned method_index,
           const ProtobufCMessage *input,
           ProtobufCClosure closure,
           void *closure_data);

  void (*invoke_b)(ProtobufCService *service,
                   unsigned method_index,
                   const ProtobufCMessage *input,
                   /*ProtobufCRiftBlockingClosureData*/void *blocking_closure_data);

  /*! Function to destroy the service. */
  void (*destroy)(ProtobufCService *service);
};

/*!
 * Service descriptor.
 */
struct ProtobufCServiceDescriptor {
  /*! Magic value checked to ensure that the API is used correctly. */
  uint32_t magic;

  uint32_t rw_srvno;

  /*! Service name. */
  const char *name;

  /*! Short version of service name. */
  const char *short_name;

  /*! C identifier for the service name. */
  const char *c_name;

  /*! Package name. */
  const char *package;

  /*! Number of elements in `methods`. */
  unsigned n_methods;

  /*! Method descriptors, in the order defined in the .proto file. */
  const ProtobufCMethodDescriptor *methods;

  /*! Sort index of methods. */
  const unsigned *method_indices_by_name;
};

/*!
 * FlatBinaryData for rift-inline byte field.
 */
struct ProtobufCFlatBinaryData {
  /*! Len of the data. len has to be first for non-macro offsetof to work. */
  size_t  len;

  /*! data of fixed size. */
  uint8_t data[];
};

/*!
 * Looked-up field information.
 */
struct ProtobufCFieldInfo {
  /*!
   * The field descriptor.  In some use cases, may be NULL if the data
   * is not part of a message.
   */
  const ProtobufCFieldDescriptor *fdesc;

  /*!
   * The element data (for pointy elements, this points at the data,
   * not at the pointer!)
   */
  const void *element;

  /*!
   * The length of the data, if the data is proto bytes type.  If not
   * proto bytes type, then value is unspecified.
   */
  size_t len;
};

/*!
 * Protobuf C Stats structure. Contains error stats and function call stats.
 */
struct ProtobufCStats {

  struct {
    uint64_t total_errors;
  } error;

  struct {
    uint64_t pack;
    uint64_t get_pack_sz;
    uint64_t pack_to_buffer;
    uint64_t unpack;
    uint64_t check;
    uint64_t merge;
    uint64_t copy;
    uint64_t free;
    uint64_t duplicate;
    uint64_t create;
    uint64_t serialize;
    uint64_t is_equal;
    uint64_t delete_unknown;
    uint64_t delete_field;
    uint64_t compare_keys;
    uint64_t set_field_msg;
    uint64_t set_field;
    uint64_t get_field;
    uint64_t get_field_txt;
    uint64_t get_finfo_txt;
    uint64_t has_field;
    uint64_t compare_fields;
  } fcall;
};

/*!
 * Protobuf C Instance struture. Contains supplied allocator functions etc.
 */
struct ProtobufCInstance {
  /*! Function pointer to malloc/similar routine */
  void *(*alloc)(ProtobufCInstance* instance, size_t size);

  /*! Function pointer to zalloc/similar routine. */
  void *(*zalloc)(ProtobufCInstance* instance, size_t size);

  /*! Function pointer to realloc/simialar routine. */
  void *(*realloc)(ProtobufCInstance* instance, void* data, size_t size);

  /*! Function pointer to free/similar routine. */
  void (*free)(ProtobufCInstance* instance, void *pointer);

  /*! Function pointer to callback/error handling routine */
  void (*error)(ProtobufCInstance* instance, const char* errormsg);

  /*! Context data. */
  void *data;

  /*! Stats data. */
  ProtobufCStats stats;
};


/*!
 * Options for controlling packing.  ATTN: Not supported in pack_to_buffer.
 */
struct ProtobufCPackOptions {
  /*!
   * Sort the packed fields by tag number then by serialized bytes,
   * recursively for all messages.  In the future, it will obey keys
   * (for keyed repeated messages), but not sort non-keyed repeated
   * elements.  Includes unknown fields, if not suppressed.
   */
  protobuf_c_boolean sort_all;

  /*!
   * Discard unknown fields - they will not be serialized.
   */
  protobuf_c_boolean discard_unknown;

  /* ATTN: depth limited? */
  /* ATTN: predicate function to include/exclude fields? */
  /* ATTN: sorting function? */
};

/*!
 * Predefined pack options for unsorted packing.  Unknown fields are
 * packed after all known fields, in the order they were originally
 * received and/or added (essentially, unknown fields are in an
 * unspecified order unless ordered explicitly by the user).
 */
PROTOBUF_C_API
extern const ProtobufCPackOptions protobuf_c_pack_opts_default;

/*!
 * Predefined pack options for sorted known fields and repeated
 * fields, but discarding unknown fields.
 */
PROTOBUF_C_API
extern const ProtobufCPackOptions protobuf_c_pack_opts_known_ordered;

/*!
 * Predefined pack options for sorting known fields, unknown fields,
 * and repeated fields.
 */
PROTOBUF_C_API
extern const ProtobufCPackOptions protobuf_c_pack_opts_ordered;


/*!
 * Serialization sorting helper.  Used to sort serialized data, which
 * is used to make equality comparisons between messages.
 */
struct ProtobufCSerializedSort {
  /*! The tag number of the field. */
  uint32_t tag;

  /*! The starting offset to the field, in the serialized output buffer. */
  uint8_t* out;

  /*! The serialized length of the field (including the tag). */
  size_t length;
};

/*!
 * Serialization sorting management.  Used to track the state of a sort
 * array.
 */
struct ProtobufCSerializedSortMgr {
  /*! The instance. */
  ProtobufCInstance* instance;

  /*! The buffer of order tracking structs. */
  ProtobufCSerializedSort* order;

  /*! The allocation size of order. */
  size_t order_alloc;

  /*! The index in order of the current/last entry. */
  size_t n;

  /*! The current output buffer pointer */
  uint8_t* out;

  /*! The copied output buffer */
  uint8_t* tmp_out;
};


/*!
 * Typedefs for ctype descriptor routines.
 */
typedef size_t (*ProtobufCCTypeGetPackedSize)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* member);

typedef size_t (*ProtobufCCTypePack)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* member,
  uint8_t* out);

typedef protobuf_c_boolean (*ProtobufCCTypeUnpack)(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  size_t in_size,
  const uint8_t* in,
  protobuf_c_boolean maybe_clear,
  void* member);

typedef protobuf_c_boolean (*ProtobufCCTypeToString)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* member,
  size_t* str_size,
  char* str);

typedef protobuf_c_boolean (*ProtobufCCTypeFromString)(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const char* str,
  size_t str_size,
  protobuf_c_boolean maybe_clear,
  void* member);

typedef protobuf_c_boolean (*ProtobufCCTypeInitUsebody)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  void* member);

typedef void (*ProtobufCCTypeFreeUsebody)(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  void* member);

typedef protobuf_c_boolean (*ProtobufCCTypeDeepCopy)(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* copy_from,
  protobuf_c_boolean maybe_clear,
  void* copy_to);

typedef protobuf_c_boolean (*ProtobufCCTypeCheck)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* member);

typedef int (*ProtobufCCTypeCompare)(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* a,
  const void* b);

/*!
 * CType descriptor.
 */
struct ProtobufCCTypeDescriptor {
  /* Pointer to the c-type's get_packed_size routine */
  ProtobufCCTypeGetPackedSize get_packed_size;
  /* Pointer to the c-type's pack routine */
  ProtobufCCTypePack          pack;
  /* Pointer to the c-type's unpack routine */
  ProtobufCCTypeUnpack        unpack;
  /* Pointer to the c-type's to_string routine */
  ProtobufCCTypeToString      to_string;
  /* Pointer to the c-type's from_string routine */
  ProtobufCCTypeFromString    from_string;
  /* Pointer to the c-type's init routine */
  ProtobufCCTypeInitUsebody   init_usebody;   /* optional */
  /* Pointer to the c-type's free routing */
  ProtobufCCTypeFreeUsebody   free_usebody;   /* optional */
  /* Pointer to the c-type's check routine */
  ProtobufCCTypeCheck         check;          /* optional */
  /* Pointer to the c-type's deep-copy function */
  ProtobufCCTypeDeepCopy      deep_copy;
  /* Pointer to the c-type's compare function */
  ProtobufCCTypeCompare       compare;
};

struct rw_keyspec_entry_t;
typedef struct rw_keyspec_entry_t rw_keyspec_entry_t;

struct rw_keyspec_path_t;
typedef struct rw_keyspec_path_t rw_keyspec_path_t;

struct rw_keyspec_path_t {
  ProtobufCMessage base;
};

struct rw_keyspec_entry_t {
  ProtobufCMessage base;
};

/*!  Rift proto field options. */
#define RW_PROTOBUF_FOPT_AGG      (1<<0)
#define RW_PROTOBUF_FOPT_INLINE   (1<<1)
#define RW_PROTOBUF_FOPT_RW_CTYPE (1<<2)
#define RW_PROTOBUF_FOPT_KEY      (1<<3)
#define RW_PROTOBUF_LOGEV_KEY     (1<<4)
#define RW_PROTOBUF_FOPT_MERGE_BEHAVIOR (1<<5)
#define RW_PROTOBUF_FOPT_DYNAMIC  (1<<6)

/*! Rift proto message options. */
#define RW_PROTOBUF_MOPT_FLAT (1<<0)
#define RW_PROTOBUF_MOPT_COMP (1<<1)
#define RW_PROTOBUF_MOPT_HAS_KEYS (1<<2)
#define RW_PROTOBUF_MOPT_LOG_EVENT (1<<4)
#define RW_PROTOBUF_MOPT_DYNAMIC (1<<5)

/*! Minikey related defines.  */
#define RWPB_MINIKEY_OPAQ_LEN 512
#define RWPB_MINIKEY_MAX_SKEY_LEN (RWPB_MINIKEY_OPAQ_LEN - sizeof(void*))
#define RWPB_MINIKEY_MAX_BKEY_LEN (RWPB_MINIKEY_OPAQ_LEN - sizeof(void*) - sizeof(int))

/*! Rift-defined types.. start. */

/*!
 * Get the version of the protobuf-c library. Note that this is the version of
 * the library linked against, not the version of the headers compiled against.
 *
 * \return A string containing the version number of protobuf-c.
 */
PROTOBUF_C_API
const char *
protobuf_c_version(void);

/*!
 * Get the version of the protobuf-c library. Note that this is the version of
 * the library linked against, not the version of the headers compiled against.
 *
 * \return A 32 bit unsigned integer containing the version number of
 *      protobuf-c, represented in base-10 as (MAJOR*1E6) + (MINOR*1E3) + PATCH.
 */
PROTOBUF_C_API
uint32_t
protobuf_c_version_number(void);

/*!
 * The version of the protobuf-c headers, represented as a string using the same
 * format as protobuf_c_version().
 */
#define PROTOBUF_C_VERSION "1.1.0"

#endif /* __GI_SCANNER__ */

/*!
 * The version of the protobuf-c headers, represented as an integer using the
 * same format as protobuf_c_version_number().
 */
#define PROTOBUF_C_VERSION_NUMBER 1001000

/*!
 * The minimum protoc-c version which works with the current version of the
 * protobuf-c headers.
 */
#define PROTOBUF_C_MIN_COMPILER_VERSION 1000000

#ifndef __GI_SCANNER__

/*!
 * Get a pointer to protobuf c instance.
 * If the passed instance is valid, the API
 * returns the same pointer other it returns a
 * pointer to default_instance.
 *
 * \param instance
 *       The `ProtobufCInstance` object.
 */
PROTOBUF_C_API
ProtobufCInstance* protobuf_c_instance_get(
    ProtobufCInstance* instance);

/*!
 * Initialize a ProtobufCInstance with default values
 *
 * \param instance
 *      The `ProtobufCInstance` object.
 */

PROTOBUF_C_API
void protobuf_c_instance_set_defaults(
    ProtobufCInstance *instance);

/*!
 * Public API to free the data allocated earlier via
 * the instance.
 *
 * \param instance
 *     The `ProtobufCInstance` object.
 * \param data
 *     The data to free.
 */
PROTOBUF_C_API
void protobuf_c_instance_free(ProtobufCInstance* instance,
                              void* data);
/*!
 * API to get the count of unknown fields
 *
 * \param msg
 *   The `ProtobufCMessage`
 * \return
 *   The number of unknown fields inside the msg
 */
PROTOBUF_C_API
unsigned protobuf_c_message_unknown_get_count(
    const ProtobufCMessage* msg);

/*!
 * API to get an unknown field based on the index
 *
 * \param msg
 *    The `ProtobufCMessage`
 * \index
 *    The index of the unknown field to get
 * \return
 *    The unknown field at index if it is valid.
 */
PROTOBUF_C_API
const ProtobufCMessageUnknownField* protobuf_c_message_unknown_get_index(
    const ProtobufCMessage* msg,
    uint32_t index);

/*!
 * API to append a serialized data into the unknown_fields
 * of the message.
 *
 * NOTE: Do not pass unpacked unknown field data to this API.
 *
 * \param instance
 *    The `ProtobufCInstance`.
 * \param msg
 *    The `ProtobufCMessage` object to which
 *    the serialized data needs to be appended.
 * \param tag
 *    Protobuf tag.
 * \param wt
 *    The `ProtobufCWireType`.
 * \param data
 *    The serialized data.
 * \param len
 *    The length of serialized data.
 *
 * \return
 *    TRUE if the append was successful, FALSE otherwise.
 */
protobuf_c_boolean
protobuf_c_message_append_unknown_serialized(
    ProtobufCInstance *instance,
    ProtobufCMessage *msg,
    uint32_t tag,
    ProtobufCWireType wt,
    const uint8_t *data,
    size_t len);


/*!
 * API to append a submessage into the unknown_fields
 * of the message.
 * NOTE: This API does not duplicate the 'submsg'.
 * Instead it just copies the pointer. (Shallow Copy)
 *
 * \param instance
 *    The `ProtobufCInstance`.
 * \param msg
 *    The `ProtobufCMessage` object to which
 *    the serialized data needs to be appended.
 * \param tag
 *    Protobuf tag.
 * \param fdesc
 *    The field descriptor for the 'submsg'.
 * \param submsg
 *    The ProtobufCMessage which needs to be
 *    appended to the unknown fields of 'msg'.
 */
protobuf_c_boolean
protobuf_c_message_append_unknown_cast_message(
    ProtobufCInstance *instance,
    ProtobufCMessage *msg,
    uint32_t tag,
    const ProtobufCFieldDescriptor *fdesc,
    const ProtobufCMessage *submsg);


/*!
 * API to append a submessage into the unknown_fields
 * of the message.
 * NOTE: This API creates a clone of the 'submsg' (Deep copy).
 *
 * \param instance
 *    The `ProtobufCInstance`.
 * \param msg
 *    The `ProtobufCMessage` object to which
 *    the serialized data needs to be appended.
 * \param tag
 *    Protobuf tag.
 * \param fdesc
 *    The field descriptor for the 'submsg'.
 * \param submsg
 *    The ProtobufCMessage which needs to be
 *    appended to the unknown fields of 'msg'.
 */
protobuf_c_boolean
protobuf_c_message_append_unknown_cast_message_dup(
    ProtobufCInstance *instance,
    ProtobufCMessage *msg,
    uint32_t tag,
    const ProtobufCFieldDescriptor *fdesc,
    const ProtobufCMessage *submsg
    );

/*!
 * Public API to allocate memory for protocol messages
 *
 * \param instance
 *     The `ProtobufCInstance` object.
 * \param size
 *    The size of memory to allocate.
 */
void* protobuf_c_instance_alloc(ProtobufCInstance* instance,
                                size_t size);

void*
protobuf_c_instance_zalloc(ProtobufCInstance* instance,
                           size_t size);

void *
protobuf_c_instance_realloc(ProtobufCInstance* instance,
                            void* data,
                            size_t size);

/*!
 * Public API to export the protobufc internal error buffer
 *
 * \param instance
 *     The `ProtobufCInstance` object.
 * \param msg
 *     The Protobuf msg to export the error records to.
 * \param m_rname
 *     The error record field name.
 * \param ts_fname
 *     The time-stamp field name inside error-record
 * \param es_fname
 *     The error-string field name inside error-record
 */
int protobuf_c_instance_export_ebuf(ProtobufCInstance* instance,
                                    ProtobufCMessage* msg,
                                    const char* m_rname,
                                    const char* ts_fname,
                                    const char* es_fname);

/*!
 * Look up a `ProtobufCEnumValue` from a `ProtobufCEnumDescriptor` by name.
 *
 * \param desc
 *      The `ProtobufCEnumDescriptor` object.
 * \param name
 *      The `name` field from the corresponding `ProtobufCEnumValue` object to
 *      match.
 * \return
 *      A `ProtobufCEnumValue` object.
 * \retval NULL
 *      If not found.
 */
PROTOBUF_C_API
const ProtobufCEnumValue *
protobuf_c_enum_descriptor_get_value_by_name(
  const ProtobufCEnumDescriptor *desc,
  const char *name);

/*!
 * Look up a `ProtobufCEnumValue` from a `ProtobufCEnumDescriptor` by numeric
 * value.
 *
 * \param desc
 *      The `ProtobufCEnumDescriptor` object.
 * \param value
 *      The `value` field from the corresponding `ProtobufCEnumValue` object to
 *      match.
 *
 * \return
 *      A `ProtobufCEnumValue` object.
 * \retval NULL
 *      If not found.
 */
PROTOBUF_C_API
const ProtobufCEnumValue *
protobuf_c_enum_descriptor_get_value(
  const ProtobufCEnumDescriptor *desc,
  int value);


/*!
 * Look up a `ProtobufCFieldDescriptor` from a `ProtobufCMessageDescriptor` by
 * the tag value of the field.
 *
 * \param desc
 *      The `ProtobufCMessageDescriptor` object.
 * \param value
 *      The tag value of the field.
 * \return
 *      A `ProtobufCFieldDescriptor` object.
 * \retval NULL
 *      If not found.
 */
PROTOBUF_C_API
const ProtobufCFieldDescriptor *
protobuf_c_message_descriptor_get_field(
  const ProtobufCMessageDescriptor *desc,
  unsigned value);

/*!
 * GI boxed message reference function.
 *
 * \param desc
 *      The GI boxed message object.
 * \retval
 *      Same as des.
 */
PROTOBUF_C_API
const ProtobufCMessageDescriptor*
protobuf_c_message_descriptor_gi_ref(
  const ProtobufCMessageDescriptor *desc);

/*!
 * GI boxed message unreference function.  If the reference count goes
 * to zero, the box and message will be deleted.  The caller MUST NOT
 * use the desc_box pointer again upon return!
 *
 * \param desc
 *      The GI boxed message object.
 */
PROTOBUF_C_API
void
protobuf_c_message_descriptor_gi_unref(
  const ProtobufCMessageDescriptor *desc);

/*!
 * Utility function for allocating memory for use by GI boxes generated
 * code.  These allocs are not given away to GI - they are all
 * eventually freed by the generated code.  Some of the generated code
 * does allocate and give memory away to GI - those buffers get
 * allocated with glib.
 *
 * \param bytes
 *      The number of bytes.
 * \retval
 *      The allocated data
 */
PROTOBUF_C_API
void*
protobuf_c_gi_boxed_zalloc(
  size_t bytes);

/*!
 * Utility function for freeing memory allocated by
 * protobuf_c_gi_boxed_zalloc.
 *
 * \param p
 *      The memory to free. May be NULL.
 */
PROTOBUF_C_API
void
protobuf_c_gi_boxed_free(
  void* p);


PROTOBUF_C_API
const ProtobufCMessage*
protobuf_c_unknown_field_cast_message(
    ProtobufCInstance *instance,
    ProtobufCMessageUnknownField *uf,
    const ProtobufCFieldDescriptor *fdesc);

PROTOBUF_C_API
const ProtobufCUnknownSerialized*
protobuf_c_unknown_field_cast_serialized(
    ProtobufCInstance *instance,
    ProtobufCMessageUnknownField *uf);


/*!
 * Determine the number of bytes required to store the serialised message.
 *
 * \param message
 *      The message object to serialise.
 * \return
 *      Number of bytes.
 */
PROTOBUF_C_API
size_t
protobuf_c_message_get_packed_size(ProtobufCInstance* instance,
                                   const ProtobufCMessage *message);

/*!
 * Determine the number of bytes required to store the serialised
 * message, allowing for packing options.
 *
 * \param message
 *      The message object to serialise.
 * \param opts
 *      The packing options that control serialization.
 * \return
 *      Number of bytes.
 */
PROTOBUF_C_API
size_t
protobuf_c_message_get_packed_size_opts(
  const ProtobufCMessage *message,
  const ProtobufCPackOptions* opts);

/*!
 * Serialise a message from its in-memory representation.
 *
 * This function stores the serialised bytes of the message in a pre-allocated
 * buffer.
 *
 * \param message
 *      The message object to serialise.
 * \param[out] out
 *      Buffer to store the bytes of the serialised message. This buffer must
 *      have enough space to store the packed message. Use
 *      protobuf_c_message_get_packed_size() to determine the number of bytes
 *      required.
 * \return
 *      Number of bytes stored in `out`.
 */
PROTOBUF_C_API
size_t
protobuf_c_message_pack(ProtobufCInstance* instance,
                        const ProtobufCMessage *message,
                        uint8_t *out);


/*!
 * Serialise a message from its in-memory representation, with
 * fine-grained control over packing options.
 *
 * This function stores the serialised bytes of the message in a
 * pre-allocated buffer.
 *
 * \param message
 *      The message object to serialise.
 * \param opts
 *      The packing options that control serialization.
 * \param[out] out
 *      Buffer to store the bytes of the serialised message. This buffer must
 *      have enough space to store the packed message. Use
 *      protobuf_c_message_get_packed_size() to determine the number of bytes
 *      required.
 * \return
 *      Number of bytes stored in `out`.
 */
PROTOBUF_C_API
size_t
protobuf_c_message_pack_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  const ProtobufCPackOptions* opts,
  uint8_t *out);

/*!
 * Serialise a message from its in-memory representation to a virtual buffer.
 *
 * This function calls the `append` method of a `ProtobufCBuffer` object to
 * consume the bytes generated by the serialiser.
 *
 * \param message
 *      The message object to serialise.
 * \param buffer
 *      The virtual buffer object.
 * \return
 *      Number of bytes passed to the virtual buffer.
 */
PROTOBUF_C_API
size_t
protobuf_c_message_pack_to_buffer(
  const ProtobufCMessage *message,
  ProtobufCBuffer *buffer);

/*!
 * Unpack a serialised message into an in-memory representation.
 *
 * \param instance
 *      `ProtobufCInstance` to use for memory allocation. May be NULL to
 *      specify the default allocator.
 * \param descriptor
 *      The message descriptor.
 * \param len
 *      Length in bytes of the serialised message.
 * \param data
 *      Pointer to the serialised message.
 * \return
 *      An unpacked message object.
 * \retval NULL
 *      If an error occurred during unpacking.
 */
PROTOBUF_C_API
ProtobufCMessage *
protobuf_c_message_unpack(ProtobufCInstance* instance,
  const ProtobufCMessageDescriptor *descriptor,
  size_t len,
  const uint8_t *data);

/*!
 * Unpack a serialised message into an in-memory representation, using
 * a preallocated message object.  The caller MUST guarantee that the
 * message pointer provided is the correct C struct type corresponding
 * to the descriptor provided!
 *
 * \param instance
 *      `ProtobufCInstance` to use for memory allocation. May be NULL to
 *      specify the default allocator.
 * \param descriptor
 *      The message descriptor.
 * \param len
 *      Length in bytes of the serialised message.
 * \param data
 *      Pointer to the serialised message..
 * \param body
 *      Pointer to the pre-allocated message body.
 * \return
 *      An unpacked message object.
 * \retval NULL
 *      If an error occurred during unpacking.
 */
PROTOBUF_C_API ProtobufCMessage *
protobuf_c_message_unpack_usebody(
  ProtobufCInstance* instance,
  const ProtobufCMessageDescriptor *descriptor,
  size_t len,
  const uint8_t *data,
  ProtobufCMessage *body);

/*!
 * Free an unpacked message object.
 *
 * This function should be used to deallocate the memory used by a call to
 * protobuf_c_message_unpack().
 *
 * \param instance
 *      `ProtobufCInstance` to use for memory allocation. May be NULL to
 *      specify the default allocator.
 * \param message
 *      The message object to free.
 */
PROTOBUF_C_API
void
protobuf_c_message_free_unpacked(
  ProtobufCInstance* instance,
  ProtobufCMessage *message);

/*!
 * Free an unpacked message object, but do not free the message itself.
 * The caller retains ownership of the message, which may be on the
 * stack or embedded in another object.
 *
 * This function should be used to deallocate the memory used by a call to
 * protobuf_c_message_unpack_usebody().
 *
 * \param instance
 *      `ProtobufCInstance` to use for memory allocation. May be NULL to
 *      specify the default allocator.
 * \param message
 *      The message object to free.
 */
PROTOBUF_C_API void
protobuf_c_message_free_unpacked_usebody(
  ProtobufCInstance* instance,
  ProtobufCMessage *message);

#define PROTOBUF_C_INIT_REF_HDR(ref_state, offset) {PROTOBUF_C_FLAG_MAGIC_NUMBER_V1, PROTOBUF_C_CREATE_REF_FLAG(ref_state), { .outer_offset = offset }}

/*! Message initialiser, init the header with the descriptor, ref_state, offset */
#define PROTOBUF_C_MESSAGE_INIT(descriptor, ref_state, offset) {PROTOBUF_C_INIT_REF_HDR(ref_state, offset), descriptor, {NULL}}

/*!
 * Macro to validate the reference header.
 */
#define PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr_) \
(\
  (((intptr_t)(ref_hdr_) & (sizeof(intptr_t)-1)) == 0) && \
  (PROTOBUF_C_FLAG_GET((ref_hdr_)->magic_flags, MAGIC_NUMBER) == PROTOBUF_C_FLAG_MAGIC_NUMBER_V1) && \
  (PROTOBUF_C_IS_VALID_REF_STATE((ref_hdr_)->ref_flags)) \
)

#define PROTOBUF_C_IS_VALID_REF_STATE(ref_) \
( \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_INNER)   || \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_GLOBAL)  || \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_PRIVATE) || \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_OWNED)   || \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_SHARED)  || \
  (PROTOBUF_C_FLAG_GET(ref_, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_COUNTED) \
)

#define PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(desc_) \
( \
  NULL != (desc_) && \
  (desc_)->magic == PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC \
)

#define PROTOBUF_C_IS_MESSAGE(message_) \
( \
  NULL != (message_) && \
  PROTOBUF_C_IS_VALID_REF_HDR((&(message_)->ref_hdr)) && \
  PROTOBUF_C_IS_MESSAGE_DESCRIPTOR((message_)->descriptor) \
)

#define PROTOBUF_C_MESSAGE_IS_DELTA(msg_) \
  (PROTOBUF_C_FLAG_GET((msg_)->ref_hdr.magic_flags, UNKNOWN_BUFFER_UNION) == PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_DELTA)

#define PROTOBUF_C_MESSAGE_IS_DATA(msg_) \
  (PROTOBUF_C_FLAG_GET((msg_)->ref_hdr.magic_flags, UNKNOWN_BUFFER_UNION) == PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_UNF)

/*!
 * Initialise a message object from a message descriptor.
 *
 * \param descriptor
 *      Message descriptor.
 * \param message
 *      Allocated block of memory of size `descriptor->sizeof_message`.
 */
PROTOBUF_C_API void
protobuf_c_message_init(
  const ProtobufCMessageDescriptor *descriptor,
  ProtobufCMessage *message);

/*!
 * Initialise an inner message object that is inline in another
 * message.  This should only be called form the libary or generated
 * code!
 *
 * \param parent
 *      The parent message (most-immediate ancestor).
 * \param inner
 *      The inner message.  Should be uninitialized, recently erased by
 *      free-usebody, or memcpy'ed away.
 * \param fdesc
 *      The field descriptor for inner, in parent's descriptor.
 */
PROTOBUF_C_API void
protobuf_c_message_init_inner(
  const ProtobufCMessage* parent,
  ProtobufCMessage* inner,
  const ProtobufCFieldDescriptor* fdesc);

/*!
 * Create message init value for a dynamic message descriptor.
 *
 * \param instance
 *      The `ProtobufCInstance` pointer.
 * \param mdesc
 *      The dynamically generated message descriptor
 */
PROTOBUF_C_API void
protobuf_c_message_create_init_value(ProtobufCInstance* instance,
                                     ProtobufCMessageDescriptor* mdesc);

/*!
 * Initialise a child inline message inside a parent
 *
 * \param parent
 *      parent message pointer
 * \param fname
 *     The field name of the child in the parent
 * \param child
 *     The child message pointer that needs to the initialized.
 */
PROTOBUF_C_API void
protobuf_c_message_init_inline_child(const ProtobufCMessage* parent,
                                     const char* fname,
                                     ProtobufCMessage* child);
/*!
 * API to memcpy a message. Only this API has to be
 * used to memcpy proto message. Direct memcpy or struct
 * assignments should not be used. This API leaves
 * the header of the dest unmodified and copies
 * only the body.
 *
 * \param dest
 *     The destination message to be copied to
 * \param src
 *     The src message.
 */
PROTOBUF_C_API void
protobuf_c_message_memcpy(ProtobufCMessage* dest,
                          const ProtobufCMessage* src);

/*!
 * API to memcmp two messages excluding its headers.
 *
 * \param msg1
 *     The input message1.
 * \param msg2
 *     The input message2.
 * \return
 *     The standard 0, -1, 1 return values for comparison
 */
PROTOBUF_C_API int
protobuf_c_message_memcmp(const ProtobufCMessage* msg1,
                          const ProtobufCMessage* msg2);

/*!
 * Protobuf C Message ref API. Perform validations
 * and increment the ref_count of the message.
 *
 * \param msg
 *     The msg pointer.
 * \return
 *    The msg pointer.
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_ref(ProtobufCMessage* msg);

/*!
 * Protobuf C Message unref API. Perform validations
 * and decrement the ref_count of the message.
 * Free the message when ref count reaches zero.
 *
 * \param msg
 *     The msg pointer.
 * \return
 *    The msg pointer.
 */
PROTOBUF_C_API void
protobuf_c_message_unref(ProtobufCMessage* msg);

/*!
 * API to free or unref a pointy child message.
 * This API should be invoked only in the context of the
 * parent message and should not be called directly.
 * Free the child msg if ref count is 1 or zero. Else
 * detach the child by calling unref on the child.
 *
 * \param instance
 *      The `ProtobufCInstance` pointer
 * \param child_msg
 *      The child msg pointer to detach/free
 */
PROTOBUF_C_API void
protobuf_c_message_unref_or_free_child(ProtobufCInstance* instance,
                                       ProtobufCMessage* child_msg);

/*!
 * API to create a message for use in GI.
 * The message's ref state is set to COUNTED and ref count
 * is set to 1.
 *
 * \param instance
 *    The `ProtobufCInstance` pointer
 * \param mdesc
 *    The message descriptor
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_gi_create(ProtobufCInstance* instance,
                             const ProtobufCMessageDescriptor *mdesc);

/*!
 * Allocate and initialize a new GI box to reference the adopted
 * message.  The reference count of the box will be 1 upon return.
 *
 * \param boxed_size
 *    The number of bytes for the box. ATTN: Move this into the descriptor.
 * \param message
 *    The message to adopt. Must be valid.
 * \param parent
 *    The parent box, if any.  May be NULL.
 * \param parent_unref
 *    The parent's unref function.  Must be set if parent is set, must
 *    be NULL is parent is NULL.  ATTN: Derive from parent.
 * \return
 *    The newly created box.
 */
PROTOBUF_C_API ProtobufCGiMessageBox*
protobuf_c_message_gi_new_adopt(
  ProtobufCMessage* message,
  ProtobufCGiMessageBox* parent );

/*!
 * Increment the reference count of a GI box.
 *
 * \param gi_boxed
 *    The box.  Must be a valid box, but does not need to contain a
 *    valid message.
 * \return
 *    The box.
 */
PROTOBUF_C_API ProtobufCGiMessageBox*
protobuf_c_message_gi_ref(
  ProtobufCGiMessageBox* gi_boxed );

/*!
   Reparent a GI box.
 *
 * \param parent_boxed
 *    The new parent box.
 * \param child_boxed
 *    The child box.  MUST NOT have a parent already, or the parent
 *    must equal parent_boxed.
 */
PROTOBUF_C_API void
protobuf_c_message_gi_reparent(
  ProtobufCGiMessageBox* parent_boxed,
  ProtobufCGiMessageBox* child_boxed );

/*!
 * Perform the common initial action sequence for invalidating a GI
 * box, where the message has been destroyed or the original reference
 * transferred to another owner.
 *
 * ATTN: Box-specific invalidation still takes place in generated code.
 * These actions need to become descriptor-driven and moved into this
 * API.
 *
 * \param gi_boxed
 *    The box to invalidate.
 */
PROTOBUF_C_API void
protobuf_c_message_gi_invalidate_start(
  ProtobufCGiMessageBox* gi_boxed );

/*!
 * Perform the common final action sequence for invalidating a GI
 * box.
 *
 * \param gi_boxed
 *    The box to invalidate.
 */
PROTOBUF_C_API void
protobuf_c_message_gi_invalidate_complete(
  ProtobufCGiMessageBox* gi_boxed );


/*!
 * Convert a GI box into a zombie.  A zombie is a box that no longer
 * holds an active reference on its parent box.  Zombies are integral
 * to the cleanup mechanism.
 *
 * \param gi_boxed
 *    The box to change.
 */
PROTOBUF_C_API void
protobuf_c_message_gi_become_zombie(
  ProtobufCGiMessageBox* gi_boxed );

/*!
 * Revive a GI zombie box.
 *
 * \param gi_boxed
 *    The box to revive.
 */
PROTOBUF_C_API void
protobuf_c_message_gi_revive_zombie(
  ProtobufCGiMessageBox* gi_boxed );

/*!
 * Release a reference to a GI box.
 *
 * \param gi_boxed
 *    The box to unref.
 * \return
 *    TRUE if the box should be recursively destroyed, along with the
 *    message (if any).  FALSE otherwise.
 */

PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_gi_unref(
  ProtobufCGiMessageBox* gi_boxed );

/*!
 * Allocate and initialize a message, as described by the message
 * descriptor.
 *
 * \retval The new message. May return NULL if out of memory.
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_create(ProtobufCInstance* instance,
                          const ProtobufCMessageDescriptor *descriptor);

/*!
 * Check the validity of a message object.
 *
 * Makes sure all required fields (`PROTOBUF_C_LABEL_REQUIRED`) are present.
 * Recursively checks nested messages.
 *
 * \retval TRUE
 *      Message is valid.
 * \retval FALSE
 *      Message is invalid.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_check(ProtobufCInstance* instance,
                         const ProtobufCMessage *);

/*!
 * The callback function type that the user of the
 * reference header has to provide to free the object.
 */
typedef void (*ProtobufCRefObjectFree)(ProtobufCReferenceHeader*);

/*!
 * The common reference header ref function.
 *
 * \param
 *    The `ProtobufCReferenceHeader` structure.
 */
ProtobufCReferenceHeader*
protobuf_c_ref_header_ref(ProtobufCReferenceHeader* ref_hdr);

/*!
 * The common reference header unref function.
 *
 * \param ref_hdr
 *    The `ProtobufCReferenceHeader` structure.
 * \param free_func
 *    The free callback function to be called to free the object
 *    when ref count becomes zero.
 */
void
protobuf_c_ref_header_unref(ProtobufCReferenceHeader* ref_hdr,
                            ProtobufCRefObjectFree free_func);

/*!
 * The common reference header set ref state function.
 *
 * \param ref_hdr
 *   The `ProtobufCReferenceHeader` structure.
 * \param new_rs
 *   The new reference state.
 */
void
protobuf_c_ref_header_set_ref_state(ProtobufCReferenceHeader* ref_hdr,
                                    ProtobufCReferenceState new_rs);
/*!
 * The API to set the initial values for the reference header.
 *
 * \param ref_hdr
 *   The `ProtobufCReferenceHeader` structure.
 * \param state
 *   The reference state.
 * \param union_val
 *   The value to set for the union field.
 */
void protobuf_c_ref_header_create(ProtobufCReferenceHeader* ref_hdr,
                                  ProtobufCReferenceState state,
                                  intptr_t union_val);

/*!
 * Free a service.
 *
 * \param service
 *      The service object to free.
 */
PROTOBUF_C_API
void
protobuf_c_service_destroy(ProtobufCService *service);

/*!
 * Look up a `ProtobufCMethodDescriptor` by name.
 *
 * \param desc
 *      Service descriptor.
 * \param name
 *      Name of the method.
 *
 * \return
 *      A `ProtobufCMethodDescriptor` object.
 * \retval NULL
 *      If not found.
 */
PROTOBUF_C_API
const ProtobufCMethodDescriptor *
protobuf_c_service_descriptor_get_method_by_name(
  const ProtobufCServiceDescriptor *desc,
  const char *name);

/*!
 * Initialise a `ProtobufCBufferSimple` object.
 */
#define PROTOBUF_C_BUFFER_SIMPLE_INIT(instance, array_of_bytes)   \
{                                                                 \
  { protobuf_c_buffer_simple_append, instance}, \
  sizeof(array_of_bytes),                                         \
  0,                                                              \
  (array_of_bytes),                                               \
  0                                                              \
}

/*!
 * Clear a `ProtobufCBufferSimple` object, freeing any allocated memory.
 */
#define PROTOBUF_C_BUFFER_SIMPLE_CLEAR(simp_buf)                        \
do {                                                                    \
  if ((simp_buf)->must_free_data) {                               \
    PROTOBUF_C_ASSERT((simp_buf)->base.instance); \
    protobuf_c_instance_free( \
        (simp_buf)->base.instance, (simp_buf)->data); \
  }                                                               \
} while (0)


/*!
 * Declare and initialize a `ProtobufCCharBuffer` object.
 */
#define PROTOBUF_C_CHAR_BUF_DECL_INIT(instance_, var_) \
  ProtobufCCharBuffer var_; \
  var_.instance    = instance_; \
  var_.buffer      = &var_.stack_buf[0]; \
  var_.buffer[0]   = 0; \
  var_.buf_len     = sizeof (var_.stack_buf); \
  var_.free_buf    = FALSE;

/*!
 * Clear a `ProtobufCCharBuffer` object, freeing any allocated memory.
 */
#define PROTOBUF_C_CHAR_BUF_CLEAR(char_buf_) \
do {                                          \
    if ((char_buf_)->free_buf) { \
      PROTOBUF_C_ASSERT((char_buf_)->buffer != &((char_buf_)->stack_buf[0])); \
      protobuf_c_instance_free((char_buf_)->instance, (char_buf_)->buffer); \
    } \
} while (0);


/*!
 * \defgroup internal Internal functions and macros
 *
 */

/*!
 * \defgroup macros Utility macros for manipulating structures
 *
 * Macros and constants used to manipulate the base "classes" generated by
 * `protobuf-c`. They also define limits and check correctness.
 *
 * \ingroup internal
 * @{
 */

/*! The maximum length of a 64-bit integer in varint encoding. */
#define MAX_UINT64_ENCODED_SIZE 10

#ifndef PROTOBUF_C_UNPACK_ERROR
/* ATTN: Define a way to capture errors */
/* ATTN: Make more use of this! */
# define PROTOBUF_C_UNPACK_ERROR(...)
#endif

#ifndef PROTOBUF_C_ERROR
/* ATTN: Define a way to capture errors */
/* ATTN: Make more use of this! */
# define PROTOBUF_C_ERROR(...)
#endif

/*!
 * Internal `ProtobufCMessage` manipulation macro.
 *
 * Base macro for manipulating a `ProtobufCMessage`. Used by STRUCT_MEMBER() and
 * STRUCT_MEMBER_PTR().
 */
#define STRUCT_MEMBER_P(struct_p, struct_offset) \
    ((void *) ((uint8_t *) (struct_p) + (struct_offset)))

/*!
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset.
 * Cast it to the passed type.
 */
#define STRUCT_MEMBER(member_type, struct_p, struct_offset) \
    (*(member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))

/*!
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset. Cast
 * it to a pointer to the passed type.
 */
#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset) \
    ((member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))

/*!@}*/

PROTOBUF_C_API
void
protobuf_c_service_generated_init(ProtobufCService *service,
          const ProtobufCServiceDescriptor *descriptor,
          void *rift_ctx,
          ProtobufCServiceDestroy destroy);

PROTOBUF_C_API
void
protobuf_c_service_invoke_internal(
  ProtobufCService *service,
  unsigned method_index,
  const ProtobufCMessage *input,
  ProtobufCClosure closure,
  void *closure_data);

/*!
 * Rift usability enhancements start.
 */

void
protobuf_c_service_invoke_internal_b(
  ProtobufCService *service,
  unsigned method_index,
  const ProtobufCMessage *input,
  void *closure_data);


/* Decls to support generated code for rwmsg */
typedef struct rwmsg_request_s rwmsg_request_t;
typedef struct rwmsg_closure_s rwmsg_closure_t;

#ifdef __RWLIB_H__
typedef rw_status_t protobuf_c_rw_status_t;
#else
typedef int protobuf_c_rw_status_t;
#endif

#define RWMSG_CLICHAN_PROTOC_FLAG_BLOCKING (1<<31)
typedef struct rwmsg_destination_s rwmsg_destination_t;
protobuf_c_rw_status_t
rwmsg_clichan_send_protoc_internal(
  void *rw_context,
  rwmsg_destination_t *rw_destination,
  uint32_t flags,
  ProtobufCService *service,
  uint32_t methidx,
  ProtobufCMessage *input,
  rwmsg_closure_t *closure,
  rwmsg_request_t **req_out);


#define RW_PB_MAX_STR_SIZE 65536 /* ATTN: Remove all uses of this constant!!! This is bad in the worst way. */

/*!
 * The `append` method for `ProtobufCBufferSimple`.
 *
 * \param buffer
 *      The buffer object to append to. Must actually be a
 *      `ProtobufCBufferSimple` object.
 * \param len
 *      Number of bytes in `data`.
 * \param data
 *      Data to append.
 */
PROTOBUF_C_API
void
protobuf_c_buffer_simple_append(
  ProtobufCBuffer *buffer,
  size_t len,
  const unsigned char *data);



/* ATTN: Doxy */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_set_field_message(
  ProtobufCInstance* instance,
  ProtobufCMessage *message,
  const ProtobufCFieldDescriptor *fd,
  ProtobufCMessage **inner_pbcm);

/* ATTN: Doxy */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_set_field_text_value(
  ProtobufCInstance* instance,
  ProtobufCMessage *message,
  const ProtobufCFieldDescriptor *fd,
  const char *val,
  size_t val_len);

PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_set_field(ProtobufCInstance* instance,
                             ProtobufCMessage *message,
                             ProtobufCFieldInfo *finfo);

/* ATTN: Doxy */
// ATTN: This API is rather ugly, it should be tightened up
/*
   ATTN: And it really should be message-based, rather than field based.
     message pointer
     field descriptor pointer
     nth (for repeated, 0 or 1 for required or optional)
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_field_get_text_value(
  ProtobufCInstance* instance,
  const ProtobufCFieldDescriptor *field,
  char *value_str,
  size_t *value_str_len, /* IN: max sizeof(value_str)/OUT: actual sizeof(value_str) */
  /*ATTN:const*/ void *value);

size_t
protobuf_c_message_get_field_size(const ProtobufCFieldDescriptor* fdesc);

/*!
 * Convert a scalar field or scalar repetead element into an XML
 * string.
 *
 * \param [in] finfo
 *   The field information.
 * \param [in/out] cbuffer
 *   The initialized `ProtobufCCharBuffer` pointer. Must be cleared
 *   using the clear macro to free any dynamically allocated mem.
 *
 * \retval
 *    TRUE if the xml conversion was successful FALSE otherwise.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_field_info_get_xml(
  const ProtobufCFieldInfo* finfo,
  ProtobufCCharBuffer* cbuffer);


PROTOBUF_C_API size_t
protobuf_c_message_get_field_count(
  const ProtobufCMessage *base,
  const ProtobufCFieldDescriptor *field);

/* ATTN: Doxy */
// ATTN: This API is rather ugly, it should be tightened up
PROTOBUF_C_API size_t
protobuf_c_message_get_field_count_and_offset(
  const ProtobufCMessage *base,
  const ProtobufCFieldDescriptor *field,
  void **msg_ptr,
  size_t *offset,
  protobuf_c_boolean* array_of_ptrs);

/* ATTN: Doxy */
PROTOBUF_C_API size_t
protobuf_c_message_get_field_desc_count_and_offset(
  const ProtobufCMessage *base,
  unsigned field_tag,
  const ProtobufCFieldDescriptor **fd,
  void **msg_ptr,
  size_t *offset,
  protobuf_c_boolean* array_of_ptrs);

/*
 * ATTN DOXY
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_compare_keys(const ProtobufCMessage *earlier,
                                const ProtobufCMessage *latter,
                                const ProtobufCMessageDescriptor *mdesc);

/*!
 * Obtain a pointer to the element for a field, and for repeated fields
 * a specific index.  This API works only on fields that are currently
 * set.  Attempting to access required fields that are pointy and that
 * were never set, optional fields that are not set, one-of fields
 * using a different member, and repeated indices in excess of the
 * current count will all fail.  This API does not work on unknown
 * fields (although it may someday).
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to read.
 * \param [in] field_tag
 *      The tag field for the field to access.
 * \param [in] repeated_index
 *      The index of the desired element in a repeated field.  For
 *      required and optional, must be 0.
 *      ATTN: Keyed API.
 * \param [out] finfo
 *      The element description.  Upon success, will be filled in with
 *      a pointer to the element, the field descriptor, and for binary
 *      field, the length of the data.  The contents may be invalid
 *      and/or stomped upon failure.
 *
 * \retval TRUE
 *      The field and index were found.  finfo is valid.
 * \retval FALSE
 *      The field and/or index were not found or are not set.  finfo is
 *      invalid.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_get_field_instance(
  ProtobufCInstance *instance,
  const ProtobufCMessage *message,
  const ProtobufCFieldDescriptor *fdesc,
  unsigned repeated_index,
  ProtobufCFieldInfo *finfo);

/*!
 * Serialize a message into a newly allocated buffer of sufficient
 * size.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to serialize.
 * \param [out] size
 *      The serialized size of the message.  Can be safely used to
 *      memcpy the reutned message.
 *
 * \retval The serialized message.  NULL if unable to serialize or
 *     unable to allocate memory.
 */
PROTOBUF_C_API uint8_t*
protobuf_c_message_serialize(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  size_t *size);

/*!
 * Serialize a message and append to existing buffer
 * reallocating the buffer
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to serialize.
 * \param [in] in_buffer
 *      The destination buffer of serialized data.
 * \param [out] size
 *      The serialized size of the message.  Can be safely used to
 *      memcpy the reutned message.
 *
 * \retval The serialized message.  NULL if unable to serialize or
 *     unable to allocate memory.
 */
PROTOBUF_C_API uint8_t*
protobuf_c_message_serialize_append(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  uint8_t * in_buffer,
  size_t *size);

/*!
 * Serialize a message into a newly allocated buffer of sufficient
 * size, with options.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to serialize.
 * \param [in] opts
 *      The packing options that control serialization.
 * \param [out] size
 *      The serialized size of the message.  Can be safely used to
 *      memcpy the reutned message.
 *
 * \retval The serialized message.  NULL if unable to serialize or
 *     unable to allocate memory.
 */
PROTOBUF_C_API uint8_t*
protobuf_c_message_serialize_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  const ProtobufCPackOptions* opts,
  size_t *size);

/*!
 * Serialize a message and append to passed buffer
 * with options.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to serialize.
 * \param [in] opts
 *      The packing options that control serialization.
 * \param [in] in_buffer
 *      The destination buffer for serialization result append.
 * \param [out] size
 *      The serialized size of the message.  Can be safely used to
 *      memcpy the reutned message.
 *
 * \retval The serialized message.  NULL if unable to serialize or
 *     unable to allocate memory.
 */
PROTOBUF_C_API uint8_t*
protobuf_c_message_serialize_append_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  const ProtobufCPackOptions* opts,
  uint8_t *in_buffer,
  size_t *size);
/*!
 * Duplicate a message into a newly allocated buffer of sufficient
 * size.  Possibly changing the message type at the same time.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to duplicate.
 * \param [in] desc
 *      The message descriptor of the message type to duplicate to.
 *
 * \retval The duplicated message.  NULL if unable to de/serialize or
 *      unable to allocate memory.
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_duplicate(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  const ProtobufCMessageDescriptor *desc);

/*!
 * Duplicate a message into a newly allocated buffer of sufficient
 * size.  Possibly changing the message type at the same time.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to duplicate.
 * \param [in] desc
 *      The message descriptor of the message type to duplicate to.
 *
 * \retval The duplicated message.  NULL if unable to de/serialize or
 *      unable to allocate memory.
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_duplicate_allow_deltas(
    ProtobufCInstance* instance,
    const ProtobufCMessage *message,
    const ProtobufCMessageDescriptor *mdesc);

/*!
 * Duplicate a message into a newly allocated buffer of sufficient
 * size.  Possibly changing the message type at the same time.
 * Includes fine control of serialization.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] message
 *      The `ProtobufCMessage` to duplicate.
 * \param [in] desc
 *      The message descriptor of the message type to duplicate to.
 * \param [in] opts
 *      The packing options that control serialization.
 *
 * \retval The duplicated message.  NULL if unable to de/serialize or
 *      unable to allocate memory.
 */
PROTOBUF_C_API ProtobufCMessage*
protobuf_c_message_duplicate_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *message,
  const ProtobufCMessageDescriptor *desc,
  const ProtobufCPackOptions* opts);

/*!
 * Duplicate one message into a different, pre-allocated message.  This
 * function cannot verify the output message size - the caller must
 * ensure that the buffer is large enough.  The output buffer must be
 * in the initilized state.  This API can be used to change the message
 * type.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] in_msg
 *      The `ProtobufCMessage` to duplicate.
 * \param [in/out] out_msg
 *      The `ProtobufCMessage` to duplicate into.  Must already be initialized.
 *
 * \retval TRUE
 *      The message was successfully duplicated.
 * \retval FALSE
 *      The message was not successfully duplicated.  out_msg should be
 *      considered invalid; the only safe operations on out_msg are to
 *      free it, or to reinitialize it.  DO NOT call free_unpacked()!
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_copy_usebody(
  ProtobufCInstance* instance,
  const ProtobufCMessage *in_msg,
  ProtobufCMessage *out_msg);

/*!
 * Duplicate one message into a different, pre-allocated message.  This
 * function cannot verify the output message size - the caller must
 * ensure that the buffer is large enough.  The output buffer must be
 * in the initilized state.  This API can be used to change the message
 * type.  Includes fine control of serialization.
 *
 * \param [in] instance
 *      The `ProtobufCInstance` object.
 * \param [in] in_msg
 *      The `ProtobufCMessage` to duplicate.
 * \param [in] opts
 *      The packing options that control serialization.
 * \param [in/out] out_msg
 *      The `ProtobufCMessage` to duplicate into.  Must already be initialized.
 *
 * \retval TRUE
 *      The message was successfully duplicated.
 * \retval FALSE
 *      The message was not successfully duplicated.  out_msg should be
 *      considered invalid; the only safe operations on out_msg are to
 *      free it, or to reinitialize it.  DO NOT call free_unpacked()!
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_copy_usebody_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *in_msg,
  const ProtobufCPackOptions* opts,
  ProtobufCMessage *out_msg);


/*!
 * Find a submessage from a PBCM message, given its field id, and an index for
 * repeated messages
 */

PROTOBUF_C_API ProtobufCMessage *
protobuf_c_message_get_sub_message (const ProtobufCMessage *parent,
                                    unsigned int field_id,
                                    unsigned int index);

/*!
 * Check if a field at a particular field descriptor is present in a message
 */
uint8_t
protobuf_c_message_is_field_present (ProtobufCMessage *parent,
                                     unsigned int index);


/* ATTN: Doxy */
/*
 * Function to delete a field in a protobuf message.  This function
 * cannot be used for deleting required fields.  For optional scalar
 * fields, it clears the has_XX field and assigns the default value if
 * available.  For non riftinlined and non scalar fields like string,
 * byte and message, it frees the memory.  So callers please make sure
 * not to cause any crashes.  For repeated fields, it resets the
 * n_elements_XXX to zero, and frees all the entries for
 * non-riftinlined, non-scalar types like string, byte, message.  For
 * non-riftinlined fields it also frees the field.  So again, callers
 * please make sure not to cause any crashes.  This API also takes care
 * of unknown fields.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_delete_field(
  ProtobufCInstance* instance,
  ProtobufCMessage* message,
  unsigned field_number);

/* ATTN: Doxy */
/*
 * Function to delete a particular field index in a repeated field of a
 * protobuf message.  This interface can only be used for repeated
 * fields.  After removing the particular index element, the function
 * shrinks the array by calling memmove.  The function frees the array
 * only when the number of elements becomes zero after removing and for
 * non-riftinlined fields.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_delete_field_index(
  ProtobufCInstance* instance,
  ProtobufCMessage *message,
  unsigned field_number,
  unsigned index);

/*!
 * Delete all unknown fields from a message, and recursively in all
 * submessages.
 *
 * \param instance
 *      The `ProtobufCInstance` object.
 * \param message
 *      The `ProtobufCMessage` to delete from.
 *
 * \retval TRUE
 *      Message is valid.
 * \retval FALSE
 *      Message is invalid.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_delete_unknown_all(
  ProtobufCInstance* instance,
  ProtobufCMessage *message);

//ATTN: Doxy
protobuf_c_boolean
protobuf_c_unknown_parse_scalar_type(ProtobufCInstance* instance,
                                     const ProtobufCMessageUnknownField* unkn_field,
                                     ProtobufCType type,
                                     ProtobufCScalarFieldUnion* out);

#endif // __GI_SCANNER__

/*!
 * Determine if two messages are byte-for-byte equal, when serialized
 * on the wire.  They do not need to have the same descriptor.  Beware!
 * This API is sensitive to the order of repeated elements and unknown
 * fields.  Messages that contain the same repeated elements, but in
 * different orders, will NOT be considered equal.
 *
 * This API contrasts with protobuf_c_message_is_equal_deep_orderfree,
 * which is insensitive to the order.  The set of messages that compare
 * equal with this API is a strict subset of the messages that compare
 * equal with protobuf_c_message_is_equal_deep_orderfree.
 *
 * \param a
 *      The first message.
 * \param b
 *      The second message.
 *
 * \retval TRUE
 *      The messages are wire-equal.
 * \retval FALSE
 *      The messages are not wire-equal.
 */
/// @cond GI_SCANNER
/**
 * protobuf_c_message_is_equal_deep:
 * @instance: (nullable)
 * @a:a ProtobufCMessage to compare
 * @b:a ProtobufCMessage to compare
 * Returns: whether or not the inputs are byte-for-byte equal
 */
/// @endcond
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_is_equal_deep(
  ProtobufCInstance* instance,
  const ProtobufCMessage *a,
  const ProtobufCMessage *b);

#ifndef __GI_SCANNER__

/*!
 * Determine if two messages are element equal.  They do not need to
 * have the same descriptor.  Messages are element equal when all of
 * their fields are equal, discounting the order of repeated elements
 * and unknown fields.
 *
 * This API contrasts with protobuf_c_message_is_equal_deep, which is
 * sensitive to the order.  The set of messages that compare equal
 * with this API is a strict superset of the messages that compare
 * equal with protobuf_c_message_is_equal_deep.
 *
 * \param a
 *      The first message.
 * \param b
 *      The second message.
 *
 * \retval TRUE
 *      The messages are order-free wire-equal.
 * \retval FALSE
 *      The messages are not order-free wire-equal.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_is_equal_deep_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *a,
  const ProtobufCMessage *b,
  const ProtobufCPackOptions* opts);

/*!
 * Merge message "from" to message "to".
 * The result of the merge is in message "to"
 * Fields from "from" are merged to "to". New fields
 * are copied to "to" and the old fields in "to"
 * are replaced with the field from "from".
 * Messages are merged recursively.
 * Lists from "from" are appended to "to".
 * Messages with same keys in the list are merged
 * recursively.
 *
 * \param instance
 *      The `ProtobufCInstance` pointer
 * \param from
 *      The new/latest message. The message is not modified.
 * \param to
 *      The old message. The messages is updated with fields from "from"
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_merge(
  ProtobufCInstance* instance,
  const ProtobufCMessage* from,
  ProtobufCMessage* to);

/*!
 * Merge message "from" to message "to".
 * The result of the merge is in message "to"
 * Fields from "from" are merged to "to". New fields
 * are copied to "to". The existing fields in "to"
 * are not updated. This API must be used
 * if the "to" is the new/latest  message.
 * Messages are merged recursively.
 * List elements from "from" are added before
 * list elements in "to".
 * Messages with same keys in the list are merged
 * recursively.
 *
 * \param instance
 *      The `ProtobufCInstance` pointer
 * \param from
 *      The old message. The message is not modified.
 * \param to
 *      The new/latest message. The messages is updated with fields from "from"
 *      that doesnot exists in "to"
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_merge_new(
  ProtobufCInstance* instance,
  const ProtobufCMessage* from,
  ProtobufCMessage* to);

/* ATTN: Doxy */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_ctype_init_memset(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  void* member);

/* ATTN: Doxy */
PROTOBUF_C_API void
protobuf_c_ctype_free_noop(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  void* member);

/* ATTN: Doxy */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_ctype_check_noop(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* member);

/* ATTN: Doxy */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_ctype_deep_copy_memcpy(
  ProtobufCInstance* instance,
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* copy_from,
  protobuf_c_boolean maybe_clear,
  void* copy_to);

/* ATTN: Doxy */
PROTOBUF_C_API int
protobuf_c_ctype_compare_memcmp(
  const ProtobufCCTypeDescriptor* ctypedesc,
  const ProtobufCFieldDescriptor* fielddesc,
  const void* a,
  const void* b);

/* ATTN: Doxy */
protobuf_c_boolean
protobuf_c_message_has_field_by_name(
    ProtobufCInstance* instance,
    const ProtobufCMessage *msg,
    const char *fname);

protobuf_c_boolean
protobuf_c_message_has_field(
    ProtobufCInstance* instance,
    const ProtobufCMessage *msg,
    uint32_t id);

/*!
 * Compare two scalar fields, or scalar list elements, for equality.
 * Not intended for messages or whole lists.  The fields do not need to
 * be in the same message, nor share the same inline/ctype-ness.
 * However, they do need to share the same protobuf-C scalar type
 * (i.e., both UINT32, or both STRING).
 *
 *\param a_finfo
 *     The first field to compare.
 *\param b_finfo
 *     The second field to compare.
 *\return
 *     less-than-0, 0, or greater-than-0, depending on whether field A
 *     is less-than, equal-to, or greater-than field B.
 */
PROTOBUF_C_API int
protobuf_c_field_info_compare(
  const ProtobufCFieldInfo* a_finfo,
  const ProtobufCFieldInfo* b_finfo);

/*!
 * Lookup a field by name, and then check if the field has the same
 * value as passed in.
 *
 *\param msg
 *     The message to check.
 *\param fname
 *     The name of the field to check.
 *\param value_info
 *     The value to check for.
 *\return
 *     TRUE if the field exists and matches the value.  FALSE
 *     otherwise.
 */
PROTOBUF_C_API protobuf_c_boolean
protobuf_c_message_has_field_with_value(
    const ProtobufCMessage *msg,
    const char *fname,
    const ProtobufCFieldInfo* value_finfo);

PROTOBUF_C_API size_t
protobuf_c_message_pack_unknown_fields(ProtobufCInstance *instance,
                                       const ProtobufCMessage* msg,
                                       uint8_t *out);

PROTOBUF_C_API size_t
protobuf_c_message_get_unknown_fields_pack_size(const ProtobufCMessage* msg);

PROTOBUF_C_API size_t
protobuf_c_message_pack_tag(uint32_t id, uint8_t *out);

PROTOBUF_C_API size_t
protobuf_c_message_pack_uint32(uint32_t value, uint8_t *out);

PROTOBUF_C_API size_t
protobuf_c_message_get_uint32_size(uint32_t v);

PROTOBUF_C_API size_t
protobuf_c_message_get_tag_size(unsigned number);


/*
 * Protobuf Diff API's and data structures
 */
// INIT is some large random magic number, certainly not 0.
// it allows the caller to init the state buffer with a simple assignment,
// and still allow an assert to verify the status with high probability.
#define PROTOBUF_C_DIFF_INITIALIZER_INIT (5743895674)
#define PROTOBUF_C_DIFF_INITIALIZER { { PROTOBUF_C_DIFF_INITIALIZER_INIT } }
#define PROTOBUF_C_DIFF_ITER_INITIALIZER 0xdeadbeef

/* Public API's */

#define RW_DIFF_STATE_SIZE 4096
#define RW_DIFF_MAX_STACK_SIZE 64
#define RW_DIFF_MAX_DIFF_PRINT_SIZE 512

typedef char protobuf_c_diff_state_t[RW_DIFF_STATE_SIZE];
typedef uint8_t protobuf_c_diff_print_buffer_t[RW_DIFF_MAX_DIFF_PRINT_SIZE];

typedef struct ProtobufCDiffStatePublic {
  int status;
} ProtobufCDiffStatePublic;

typedef enum ProtobufCDiffFailureCode {
  PROTOBUF_C_NO_MISMATCH = 0,
  PROTOBUF_C_FLAGS_MISMATCH,
  PROTOBUF_C_INLINE_FIELD_MISMATCH, // More informative version
                                    // of flags mismatch
  PROTOBUF_C_FIELD_LABEL_MISMATCH,
  PROTOBUF_C_FIELD_TYPE_MISMATCH,
  PROTOBUF_C_FIELD_VALUE_MISMATCH,
  PROTOBUF_C_FIELD_NUMBER_MISMATCH,    // Not used, for future
  PROTOBUF_C_REPEATED_NUMBER_MISMATCH, // Not used, for future
  PROTOBUF_C_FIELD_EXIST_MISMATCH,
  PROTOBUF_C_UNKNOWN_FIELDS_MISMATCH,
} ProtobufCDiffFailureCode;

typedef struct ProtobufCDiffLocation {
  const ProtobufCMessage *message; // NULL if diff is missing
  ProtobufCFieldInfo fld_info;     // fdesc is null if unknown field
  uint32_t list_index;
} ProtobufCDiffLocation;


typedef struct ProtobufCDiffInfo {
  const ProtobufCDiffLocation *a;
  const ProtobufCDiffLocation *b;
  ProtobufCDiffFailureCode mismatch_reason;
} ProtobufCDiffInfo;


#define PROTOBUF_C_DIFF_STOP_AT_FIRST (1 << 0)
#define PROTOBUF_C_DIFF_FIND_ALL      (1 << 1)

typedef struct ProtobufCDiffOptions {
  uint32_t diff_opts;
} ProtobufCDiffOptions;


typedef enum ProtobufCDiffStatus{
    PROTOBUF_C_DIFF_STATUS_INIT = PROTOBUF_C_DIFF_INITIALIZER_INIT,
    PROTOBUF_C_DIFF_STATUS_ACTIVE, // Status while diff is ongoing
    PROTOBUF_C_DIFF_STATUS_DONE,
} ProtobufCDiffStatus;


/*!
 * Initializes the required data structures for findiong the
 * diff between two protobuf messages.
 * This API *must* be called before protobuf_c_diff_next
 * API.
 *
 * \param instance
 *    Required for managing memory resources and error handling.
 *    Pass NULL if there is none.
 * \param state
 *    Uninitialized state buffer pointer.
 * \param a
 *    The first Protobuf Message which needs to be compared against
 *    another.
 *    This is the target protobuf message in which one is expecting
 *    to find/update the changes present in message 'b'.
 * \param b
 *    The second Protobuf Message which would be compared with a.
 *    This is the source protobuf message.
 * \param opts
 *    ProtobufCDiffOptions structure for controlling the diff
 *    behavior.
 */
void protobuf_c_diff_start(
        ProtobufCInstance *instance,
        protobuf_c_diff_state_t *state,
        const ProtobufCMessage *a,
        const ProtobufCMessage *b,
        const ProtobufCDiffOptions opts);

/*!
 * Gets the next difference between the two messages provided
 * to the API protobuf_c_diff_start.
 * The APIs protobuf_c_diff* are stateful APIs i.e they maintain
 * the state internally inside a stack and updates it during the
 * execution of this API.
 *
 * \param state
 *    This is the state buffer which gets internally represented
 *    as a structure for storing/saving data.
 *
 * \retval ProtobufCDiffInfo*
 *    Returns a pointer to the ProtobufCDiffInfo structure.
 *    It contains the information regarding the field at which
 *    the difference was found with some other details.
 *
 *    Returns NULL if no difference were found.
 */
// Return NULL when no more differences
const ProtobufCDiffInfo* protobuf_c_diff_next(
        protobuf_c_diff_state_t *state);


/*!
 * Finishes the diff procedure by reiniting the state buffer
 * and resetting the state machine.
 * Must be called once the client is done with fetching the diffs
 * between the protobuf message.
 *
 * \param state
 *    This is the state buffer which gets internally represented
 *    as a structure for storing/saving data.
 *
 * \retval protobuf_c_boolean
 *    returns TRUE if reiniting was done successfully
 *    returns FALSE if there was some issue with state machine.
 */
protobuf_c_boolean protobuf_c_diff_done(
        protobuf_c_diff_state_t *state);



/*!
 * ProtobufCDiffIterRes
 *  Iterator for walking through the stack of messages
 *  at the site where the difference between protobuf i
 *  messages were found.
 *  This structure must be initialized using
 *  protobuf_c_diff_iter_init API
 */
typedef struct ProtobufCDiffIterRes {
  uint32_t magic;
  protobuf_c_boolean msg_order;   // Determines which message to select from ProtobufCDiffStkNode/
                                  // from 'a' and 'b'. If TRUE, message 'a' will be selected
                                  // if FALSE. message 'b' will be selected.
                                  // It is auto detected and set by protobuf_c_diff_iter_init API
  ProtobufCDiffLocation result;
  int visited_elem;
} ProtobufCDiffIterRes;

/*!
 * Initializes the iterator which can be used to
 * inpect the elements present in the internal stack
 * at the site where the difference was found.
 *
 * \param msg
 *    The message for which the stack needs to be inspected.
 * \param iter
 *    The iterator ProtobufCDiffIterRes.
 * \param state
 *    This is the state buffer which gets internally represented
 *    as a structure for storing/saving data.
 *
 * \retval boolean
 *    Returns TRUE if the iterator was initialized successfully.
 *    Returns FALSE in case of invalid arguments or invalid state.
 */
protobuf_c_boolean protobuf_c_diff_iter_init(
        ProtobufCMessage *msg,
        ProtobufCDiffIterRes *iter,
        protobuf_c_diff_state_t *state);


/*!
 * Forward iterator on the internal stack.
 * The iterated result is updated in iter.result.
 */
protobuf_c_boolean protobuf_c_diff_iter_change_path_up(
        ProtobufCDiffIterRes *iter,
        protobuf_c_diff_state_t *state);

/*!
 * Backward iterator on the intyernal stack.
 * The iterated result is updated in iter.result.
 */
protobuf_c_boolean protobuf_c_diff_iter_change_path_down(
        ProtobufCDiffIterRes *iter,
        protobuf_c_diff_state_t *state);



/*!
 * Provides a formatted printable string of the diff
 * to the caller.
 * The diff behavior is controlled by the diff options
 * which is provided as one of the arguments to this API.
 *
 *\param state
 *  This is the state buffer which gets internally represented
 *  as a structure for storing/saving data.
 *\param buffer
 *  Stack allocated buffer at the caller site. The diff would
 *  be written into this buffer.
 *  NOTE: The buffer would be memset during each call to this
 *  API.
 *
 * \retval boolean
 *    Returns TRUE if the difference was written into the buffer.
 *    Returns FALSE if nothing was written into buffer.
 */
protobuf_c_boolean
protobuf_c_diff_print_str(protobuf_c_diff_state_t *state,
                          protobuf_c_diff_print_buffer_t *print_buffer);

/*! Rift usability enhancements end.*/

/*!@}*/

#endif /* __GI_SCANNER__ */


#ifndef __GI_SCANNER__
/**
 * Look up a `ProtobufCFieldDescriptor` from a `ProtobufCMessageDescriptor` by
 * the name of the field.
 *
 * \param desc
 *      The `ProtobufCMessageDescriptor` object.
 * \param name
 *      The name of the field.
 * \return
 *      A `ProtobufCFieldDescriptor` object.
 * \retval NULL
 *      If not found.
 */
#endif
/// @cond GI_SCANNER
/**
 * protobuf_c_message_descriptor_get_field_by_name:
 * returns:  (transfer none) (type ProtobufC.FieldDescriptor):
 */
/// @endcond

PROTOBUF_C_API
const ProtobufCFieldDescriptor *
protobuf_c_message_descriptor_get_field_by_name(
  const ProtobufCMessageDescriptor *desc,
  const char *name);

PROTOBUF_C_API
protobuf_c_boolean
protobuf_c_field_descriptor_is_list(
const ProtobufCFieldDescriptor *desc);

GType protobuf_c_message_get_type(void);
GType protobuf_c_instance_get_type(void);

/// @cond GI_SCANNER
/**
 * protobuf_c_message_get_gi_typename:
 */
/// @endcond

PROTOBUF_C_API const char*
protobuf_c_message_get_gi_typename(
  const ProtobufCMessage* message);

/// @cond GI_SCANNER
/**
 * protobuf_c_message_retrieve_descriptor:
 * @message:
 * returns: (type ProtobufC.MessageDescriptor)
 */
/// @endcond
const ProtobufCMessageDescriptor*
protobuf_c_message_retrieve_descriptor(const ProtobufCMessage* message);

GType protobuf_c_message_descriptor_get_type(void);

/// @cond GI_SCANNER
/**
 * protobuf_c_message_descriptor_get_field_names:
 * returns:  (transfer container) (array zero-terminated=1):
 */
/// @endcond

const char **
protobuf_c_message_descriptor_get_field_names(const ProtobufCMessageDescriptor *desc);

/// @cond GI_SCANNER
/**
 * protobuf_c_message_descriptor_get_key_names:
 * returns:  (transfer container) (array zero-terminated=1):
 */
/// @endcond

const char **
protobuf_c_message_descriptor_get_key_names(const ProtobufCMessageDescriptor *desc);


/// @cond GI_SCANNER
/**
 * protobuf_c_message_descriptor_get_gi_typename:
 */
/// @endcond

const char *
protobuf_c_message_descriptor_get_gi_typename(const ProtobufCMessageDescriptor *desc);

PROTOBUF_C_END_DECLS

#endif /* __RIFT_PROTOBUF_C_RUNTIME_H_ */
