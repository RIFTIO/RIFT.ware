/* --- protobuf-c.c: protobuf c runtime implementation --- */

/*
 * Copyright (c) 2008-2014, Dave Benson and the protobuf-c authors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*! \file
 * Support library for `protoc-c` generated code.
 *
 * This file implements the public API used by the code generated
 * by `protoc-c`.
 *
 * \authors Dave Benson and the protobuf-c authors
 *
 * \copyright 2008-2014. Licensed under the terms of the [BSD-2-Clause] license.
 */

/**
 * \todo 64-BIT OPTIMIZATION: certain implementations use 32-bit math
 * even on 64-bit platforms (uint64_size, uint64_pack, parse_uint64).
 *
 * \todo Use size_t consistently.
 */

#include <stdlib.h>     /* for malloc, free */
#include <string.h>     /* for strcmp, strlen, memcpy, memmove, memset */
#include <stdio.h>      /* for snprintf */
#include <ctype.h>      /* for isspace */
#include <inttypes.h>   /* for SCNd64... */
#include <time.h>       /* for time, localtime... */

#include "rift-protobuf-c.h"

#ifndef TRUE
#define TRUE  1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#include "pbc_b64.h"

/* Workaround for Microsoft compilers. */
#ifdef _MSC_VER
# define inline __inline
#endif

/**
 * \defgroup internal Internal functions and macros
 *
 * These are not exported by the library but are useful to developers working
 * on `libprotobuf-c` itself.
 */

/**
 * \defgroup macros Utility macros for manipulating structures
 *
 * Macros and constants used to manipulate the base "classes" generated by
 * `protobuf-c`. They also define limits and check correctness.
 *
 * \ingroup internal
 * @{
 */

/** The maximum length of a 64-bit integer in varint encoding. */
#define MAX_UINT64_ENCODED_SIZE 10

#ifndef PROTOBUF_C_MESSAGE_ERROR
#define PROTOBUF_C_MESSAGE_ERROR(instance, msg, fdesc, format, ...) \
  do_error_message(instance, msg, fdesc, format, ##__VA_ARGS__)
#endif

#define PROTOBUF_C_INC_STATS(instance_, type_, name_) \
    g_atomic_pointer_add(&instance_->stats.type_.name_, 1); // for 64bit increment

/**
 * Internal `ProtobufCMessage` manipulation macro.
 *
 * Base macro for manipulating a `ProtobufCMessage`. Used by STRUCT_MEMBER() and
 * STRUCT_MEMBER_PTR().
 */
#define STRUCT_MEMBER_P(struct_p, struct_offset) \
    ((void *) ((uint8_t *) (struct_p) + (struct_offset)))

/**
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset.
 * Cast it to the passed type.
 */
#define STRUCT_MEMBER(member_type, struct_p, struct_offset) \
    (*(member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))

/**
 * Return field in a `ProtobufCMessage` based on offset.
 *
 * Take a pointer to a `ProtobufCMessage` and find the field at the offset. Cast
 * it to a pointer to the passed type.
 */
#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset) \
    ((member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))


#define PROTOBUF_C_IS_SERVICE_DESCRIPTOR(desc_) \
( \
  NULL != (desc_) && \
  (desc_)->magic == PROTOBUF_C_SERVICE_DESCRIPTOR_MAGIC \
)

#define PROTOBUF_C_IS_FIELD_DESCRIPTOR(desc_) \
( \
  NULL != (desc_) && \
  (desc_)->magic == PROTOBUF_C_FIELD_DESCRIPTOR_MAGIC \
)

#define PROTOBUF_C_IS_ENUM_DESCRIPTOR(desc_) \
( \
  NULL != (desc_) && \
  (desc_)->magic == PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC \
)

#define PROTOBUF_C_IS_COMPLEX_FIELD(desc_) \
( \
  (desc_)->type == PROTOBUF_C_TYPE_MESSAGE || \
  (desc_)->type == PROTOBUF_C_TYPE_BYTES || \
  (desc_)->type == PROTOBUF_C_TYPE_STRING \
)

#define PROTOBUF_C_MESSAGE_IS_INNER(msg_) \
(\
  (PROTOBUF_C_FLAG_GET((msg_)->ref_hdr.ref_flags, REF_STATE) == PROTOBUF_C_FLAG_REF_STATE_INNER) && \
  ((msg_)->ref_hdr.outer_offset != 0) \
)

/* Forward declarations for static functions in the file */
static protobuf_c_boolean
protobuf_c_message_clone_unknown_field(ProtobufCInstance *instance,
                      const ProtobufCMessageUnknownField *source_fld,
                      ProtobufCMessageUnknownField *target_fld);

/**@}*/

/* --- version --- */

const char *
protobuf_c_version(void)
{
  return PROTOBUF_C_VERSION;
}

uint32_t
protobuf_c_version_number(void)
{
  return PROTOBUF_C_VERSION_NUMBER;
}

/* --- allocator --- */

static void *
system_alloc(ProtobufCInstance* instance,
             size_t size)
{
  (void)instance;
  return malloc(size);
}

static void *
system_zalloc(ProtobufCInstance* instance,
              size_t size)
{
  (void)instance;
  return calloc(1,size);
}

static void *
system_realloc(ProtobufCInstance* instance,
               void *data,
               size_t size)
{
  (void)instance;
  return realloc(data, size);
}

static void
system_free(ProtobufCInstance* instance,
            void *data)
{
  (void)instance;
  free(data);
}

static void
system_error(ProtobufCInstance* instance,
             const char* errmsg)
{
  (void)instance;
  (void)errmsg;
}

/*
 * Some users may configure the default allocator; providing your own allocator
 * to unpack() is preferred. This allocator is still used for packing nested
 * messages.
 */
ProtobufCInstance protobuf_c_default_instance = {
  .alloc = &system_alloc,
  .zalloc = &system_zalloc,
  .realloc = &system_realloc,
  .free = &system_free,
  .error = &system_error,
  .data = NULL,
};

static inline void *
do_alloc(ProtobufCInstance* instance,
         size_t size)
{
  PROTOBUF_C_ASSERT(instance->alloc);
  void *ptr = instance->alloc(instance, size);
  PROTOBUF_C_ASSERT(ptr);
  return ptr;
}

static inline void *
do_zalloc(ProtobufCInstance* instance,
          size_t size)
{
  PROTOBUF_C_ASSERT(instance->zalloc);
  void* ptr = instance->zalloc(instance, size);
  PROTOBUF_C_ASSERT(ptr);
  return ptr;
}

static inline void *
do_realloc(ProtobufCInstance* instance,
           void *data,
           size_t size)
{
  PROTOBUF_C_ASSERT(instance->realloc);
  void* ptr = instance->realloc(instance, data, size);
  PROTOBUF_C_ASSERT(ptr);
  return ptr;
}

static inline void
do_free(ProtobufCInstance* instance,
        void *data)
{
  PROTOBUF_C_ASSERT(instance->free);
  if (data != NULL) {
    instance->free(instance, data);
  }
}

static inline void
do_error(ProtobufCInstance* instance,
         const char* errmsg)
{
  if (instance->error) {
    instance->error(instance, errmsg);
  }
}

ProtobufCInstance*
protobuf_c_instance_get(ProtobufCInstance* instance)
{
  if (instance) {
    return instance;
  }
  return &protobuf_c_default_instance;
}

void *
protobuf_c_instance_alloc(ProtobufCInstance* instance,
                          size_t size)
{
  instance = protobuf_c_instance_get(instance);
  return do_alloc(instance, size);
}

void *
protobuf_c_instance_zalloc(ProtobufCInstance* instance,
                           size_t size)
{
  instance = protobuf_c_instance_get(instance);
  return do_zalloc(instance, size);
}

void *
protobuf_c_instance_realloc(ProtobufCInstance* instance,
                            void* data,
                            size_t size)
{
  instance = protobuf_c_instance_get(instance);
  return do_realloc(instance, data, size);
}

void
protobuf_c_instance_free(ProtobufCInstance* instance,
                         void* data)
{
  instance = protobuf_c_instance_get(instance);
  return do_free(instance, data);
}

void
protobuf_c_instance_error(ProtobufCInstance* instance,
                          const char* errmsg)
{
  instance = protobuf_c_instance_get(instance);
  if (instance->error) {
    instance->error(instance, errmsg);
  }
}

void protobuf_c_instance_set_defaults(ProtobufCInstance *instance)
{
  instance->alloc = &system_alloc;
  instance->zalloc = &system_zalloc;
  instance->realloc = &system_realloc;
  instance->free = &system_free;
  instance->error = &system_error;
  instance->data = NULL;
}

/*
 * ATTN: Temporary hack circular buffer of protobuf-c errors, for
 * helping debug protobuf/keyspec issues.
 */
enum {
  PROTOBUF_C_ERROR_RECORDS = 256,
  PROTOBUF_C_ERROR_RECORD_SIZE = 256,
};

typedef struct ProtobufCErrorRecord
{
  time_t time;
  char error[PROTOBUF_C_ERROR_RECORD_SIZE];
} ProtobufCErrorRecord;

volatile ProtobufCErrorRecord protobuf_c_error_records[PROTOBUF_C_ERROR_RECORDS];
volatile int protobuf_c_error_index = 0;
volatile int protobuf_c_error_stderr_count = 0;


/*
 * This is the error reporting function
 */
static inline void
do_error_message(ProtobufCInstance *instance,
                 const ProtobufCMessage *msg,
                 const ProtobufCFieldDescriptor *fdesc,
                 const char* format,
                 ...)
{
  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, error, total_errors);

  char fstr[4096];
  int bytes = -1;
  if (msg && msg->descriptor && fdesc) {
    bytes = snprintf(fstr, sizeof(fstr), "%s(%p).%s(%u): msg=%p: ",
                     msg->descriptor->short_name,
                     msg->descriptor,
                     fdesc->name,
                     fdesc->id,
                     msg);
  } else if (msg && fdesc) {
    bytes = snprintf(fstr, sizeof(fstr), "*Unknown*.%s(%u): msg=%p: ",
                     fdesc->name,
                     fdesc->id,
                     msg);
  } else if (msg) {
    bytes = snprintf(fstr, sizeof(fstr), "%s(%p): msg=%p: ",
                     msg->descriptor->short_name,
                     msg->descriptor,
                     msg);
  } else if (fdesc) {
    bytes = snprintf(fstr, sizeof(fstr), "*Unknown*.%s(%u): ",
                     fdesc->name,
                     fdesc->id);
  } else {
    bytes = snprintf(fstr, sizeof(fstr), "*Unknown*: ");
  }
  PROTOBUF_C_ASSERT(bytes > 0 && bytes < sizeof(fstr));

  va_list argptr;
  va_start(argptr, format);
  int more = vsnprintf(fstr+bytes, sizeof(fstr)-bytes, format, argptr);
  va_end(argptr);
  PROTOBUF_C_ASSERT(more > 0); /* It is a bug to have a bad printf string. Fix it. */

  /* ATTN: Technically not thread safe - but don't care too much right now. */
  int ei = protobuf_c_error_index;
  if (ei >= (PROTOBUF_C_ERROR_RECORDS-1) || ei < 0) {
    ei = PROTOBUF_C_ERROR_RECORDS - 1;
    protobuf_c_error_index = 0;
  } else {
    protobuf_c_error_index = ei + 1;
  }

  volatile ProtobufCErrorRecord* r = &protobuf_c_error_records[ei];
  r->time = time(NULL);
  strncpy((char*)(r->error), fstr, sizeof(r->error)-1);

  int esc = protobuf_c_error_stderr_count;
  if (esc) {
    --esc;
    if (esc < 0) {
      esc = 0;
    }
    protobuf_c_error_stderr_count = esc;
    fprintf(stderr, "%s\n", fstr);
  }

  if (instance->error) {
    (instance->error)(instance, fstr);
  }
  return;
}

void protobuf_c_error_dump_records(void)
{
  time_t stime = time(NULL);
  char tbuf[64] = {};

  int sei = protobuf_c_error_index;
  if (sei < 0 || sei >= PROTOBUF_C_ERROR_RECORDS) {
    sei = 0;
  }

  for (int c = 0; c <= PROTOBUF_C_ERROR_RECORDS; ++c) {
    int ei = sei + c;
    ei = ei % PROTOBUF_C_ERROR_RECORDS;
    volatile const ProtobufCErrorRecord* r = &protobuf_c_error_records[ei];
    if (r->time <= stime && r->time ) {
      struct tm tm;
      localtime_r((const time_t*)(&r->time), &tm);
      char tbuf[64] = { 0 };
      strftime(tbuf, sizeof(tbuf), "%Y%m%d-%H%M%S", &tm);
      fprintf(stderr, "[%3d] %s: %.*s\n", ei, tbuf, sizeof(r->error)-1, r->error);
      fflush(stderr);
    }
  }
}

void protobuf_c_error_clear(void)
{
  memset((void*)protobuf_c_error_records, 0, sizeof(protobuf_c_error_records));
  protobuf_c_error_index = 0;
}

int protobuf_c_instance_export_ebuf(ProtobufCInstance* instance,
                                    ProtobufCMessage* msg,
                                    const char* m_rname,
                                    const char* ts_fname,
                                    const char* es_fname)
{
  /*
   * This is a kind of hack to export error records.
   * Assumptions about protobufc structure is made here.
   * Not worring as it is just a debug code.
   */
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(m_rname);
  PROTOBUF_C_ASSERT(ts_fname);
  PROTOBUF_C_ASSERT(es_fname);

  instance = protobuf_c_instance_get(instance);

  const ProtobufCFieldDescriptor* mfdesc =
      protobuf_c_message_descriptor_get_field_by_name(msg->descriptor, m_rname);

  if (!mfdesc) {
    return 0;
  }

  // Make sure to assert all the assumptions!
  PROTOBUF_C_ASSERT(mfdesc->type == PROTOBUF_C_TYPE_MESSAGE);
  PROTOBUF_C_ASSERT(mfdesc->label == PROTOBUF_C_LABEL_REPEATED);
  PROTOBUF_C_ASSERT(!(mfdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE));

  const ProtobufCFieldDescriptor* tsfdesc =
      protobuf_c_message_descriptor_get_field_by_name(mfdesc->msg_desc, ts_fname);

  if (!tsfdesc) {
    return 0;
  }

  PROTOBUF_C_ASSERT(tsfdesc->type == PROTOBUF_C_TYPE_STRING);
  PROTOBUF_C_ASSERT(tsfdesc->label == PROTOBUF_C_LABEL_OPTIONAL);
  PROTOBUF_C_ASSERT(tsfdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  const ProtobufCFieldDescriptor* esfdesc =
      protobuf_c_message_descriptor_get_field_by_name(mfdesc->msg_desc, es_fname);

  if (!esfdesc) {
    return 0;
  }

  PROTOBUF_C_ASSERT(esfdesc->type == PROTOBUF_C_TYPE_STRING);
  PROTOBUF_C_ASSERT(esfdesc->label == PROTOBUF_C_LABEL_OPTIONAL);
  PROTOBUF_C_ASSERT(esfdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  // Make sure that the field is not allocated earlier.
  PROTOBUF_C_ASSERT(!STRUCT_MEMBER(ProtobufCMessage**, msg, mfdesc->offset));
  PROTOBUF_C_ASSERT(!STRUCT_MEMBER(uint32_t, msg, mfdesc->quantifier_offset));

  ProtobufCMessage** records = (ProtobufCMessage **)do_alloc(
      instance, PROTOBUF_C_ERROR_RECORDS*sizeof(void*));

  // Caution! dont call any function that may log error.
  time_t stime = time(NULL);

  int sei = protobuf_c_error_index;
  if (sei < 0 || sei >= PROTOBUF_C_ERROR_RECORDS) {
    sei = 0;
  }

  unsigned tot_records = 0;
  for (int c = 0; c <= PROTOBUF_C_ERROR_RECORDS; ++c) {
    int ei = sei + c;
    ei = ei % PROTOBUF_C_ERROR_RECORDS;
    volatile const ProtobufCErrorRecord* r = &protobuf_c_error_records[ei];
    if (r->time <= stime && r->time ) {
      struct tm tm;
      localtime_r((const time_t*)(&r->time), &tm);

      ProtobufCMessage* record = (ProtobufCMessage *)do_alloc(
          instance, mfdesc->msg_desc->sizeof_message);
      protobuf_c_message_init(mfdesc->msg_desc, record);

      char *tbuf = STRUCT_MEMBER_PTR(char, record, tsfdesc->offset);
      strftime(tbuf, tsfdesc->data_size, "%Y%m%d-%H%M%S", &tm);
      // Set the has field.
      STRUCT_MEMBER(uint32_t, record, tsfdesc->quantifier_offset) = 1;

      char *estr = STRUCT_MEMBER_PTR(char, record, esfdesc->offset);
      PROTOBUF_C_ASSERT(esfdesc->data_size >= sizeof(r->error));
      strncpy(estr, (const char*)r->error, sizeof(r->error)-1);
      estr[sizeof(r->error)-1] = 0;
      // Set the has field.
      STRUCT_MEMBER(uint32_t, record, esfdesc->quantifier_offset) = 1;

      records[tot_records++] = record;
    }
  }

  if (tot_records) {
    STRUCT_MEMBER(ProtobufCMessage**, msg, mfdesc->offset) = records;
    STRUCT_MEMBER(uint32_t, msg, mfdesc->quantifier_offset) = tot_records;
  } else {
    do_free(instance, records);
  }

  return tot_records;
}

typedef enum {

  /* Move fields from "from" msg to "to" msg */
  MERGE_FLAG_MOVE_FIELDS       = 1 << 0,
  /* Copy fields from "from" msg to "to" msg */
  MERGE_FLAG_COPY_FIELDS       = 1 << 1,
  /* The "to" messages is earlier msg and "from" msg is latter.
   * For scalar singular fields, the output always contains
   * the latter msg field or the latest seen value. This is
   * the default for intutive merge */
  MERGE_FLAG_TO_BEFORE_FROM    = 1 << 2,
  /* The "from" msg is earlier msg and "to" msg is latter.
   * This is the default for unpack merge */
  MERGE_FLAG_FROM_BEFORE_TO    = 1 << 3

} protobuf_c_merge_flags_t;

typedef struct {
  protobuf_c_merge_flags_t flags;
} ProtobufCMergeOptions_t;

ProtobufCMergeOptions_t default_unpack   = { MERGE_FLAG_MOVE_FIELDS | MERGE_FLAG_FROM_BEFORE_TO };

static protobuf_c_boolean
merge_messages(ProtobufCInstance* instance,
               ProtobufCMessage *from,
               ProtobufCMessage *to,
               ProtobufCMergeOptions_t opts);

/* === ProtobufCMessage unknown fields public APIs === */
unsigned
protobuf_c_message_unknown_get_count(const ProtobufCMessage* msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  if (msg->unknown_buffer) {
    return msg->unknown_buffer->n_unknown_fields;
  }

  return 0;
}

const ProtobufCMessageUnknownField*
protobuf_c_message_unknown_get_index(const ProtobufCMessage* msg,
                                     uint32_t index)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  ProtobufCMessageUnknownField* uf = NULL;

  if (msg->unknown_buffer &&
      index < msg->unknown_buffer->n_unknown_fields) {
    uf = &msg->unknown_buffer->unknown_fields[index];
  }

  return uf;
}

static protobuf_c_boolean
expand_unknown_fields(ProtobufCInstance *instance,
                      ProtobufCMessage* msg)
{
  ProtobufCMessageUnknownFields *unk_flds = msg->unknown_buffer;

  if (!unk_flds) {
    unk_flds = do_zalloc(instance, sizeof(ProtobufCMessageUnknownFields));
    if (!unk_flds) {
      return FALSE;
    }

    (unk_flds)->unknown_fields = do_alloc(instance, sizeof(ProtobufCMessageUnknownField));
    if (!(unk_flds)->unknown_fields) {
      return FALSE;
    }
    msg->unknown_buffer = unk_flds;

  } else {
    ProtobufCMessageUnknownField* tmp = do_realloc(instance,
                                    unk_flds->unknown_fields,
                                    sizeof(ProtobufCMessageUnknownField)*(unk_flds->n_unknown_fields+1));
    if (!tmp) {
      return FALSE;
    }
    unk_flds->unknown_fields = tmp;
  }

  unk_flds->n_unknown_fields++;

  return TRUE;
}


protobuf_c_boolean
protobuf_c_message_append_unknown_serialized(ProtobufCInstance *instance,
                                             ProtobufCMessage *msg,
                                             uint32_t tag,
                                             ProtobufCWireType wt,
                                             const uint8_t *data,
                                             size_t len)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  instance = protobuf_c_instance_get(instance);

  if (!expand_unknown_fields(instance, msg)){
    goto no_memory;
  }

  ProtobufCMessageUnknownFields *unk_flds = msg->unknown_buffer;

  unsigned index = unk_flds->n_unknown_fields - 1;
  unk_flds->unknown_fields[index].base_.tag = tag;

  ProtobufCMessageUnknownField *target_fld = &unk_flds->unknown_fields[index];
  ProtobufCUnknownSerialized *user = &target_fld->serialized;
  user->wire_type = wt;
  user->data = do_alloc(instance, len);
  if (!user->data) {
    goto no_memory;
  }

  user->len = len;
  memcpy(user->data, data, len);

  PROTOBUF_C_FLAG_SET(unk_flds->unknown_fields[index].base_.unknown_flags,
      UNKNOWN_UNION_TYPE, PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED);

  return TRUE;

no_memory:
  PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                           "Unknown append fail. No memory.");
  return FALSE;
}


protobuf_c_boolean
protobuf_c_message_append_unknown_cast_message(
                                ProtobufCInstance *instance,
                                ProtobufCMessage *msg,
                                uint32_t tag,
                                const ProtobufCFieldDescriptor *fdesc,
                                const ProtobufCMessage *submsg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(submsg);

  instance = protobuf_c_instance_get(instance);

  if (!expand_unknown_fields(instance, msg)) {
    PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
        "Unknown cast message fail. No memory");
    return FALSE;
  }

  ProtobufCMessageUnknownFields *unk_flds = msg->unknown_buffer;

  unsigned index = unk_flds->n_unknown_fields - 1;
  unk_flds->unknown_fields[index].base_.tag = tag;

  ProtobufCMessageUnknownField *target_fld = &unk_flds->unknown_fields[index];
  ProtobufCUnknownMessageCast *umcast = &target_fld->cmessage;

  umcast->fdesc = fdesc;
  umcast->message = (ProtobufCMessage *) submsg;

  PROTOBUF_C_FLAG_SET(target_fld->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                      PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST);

  return TRUE;
}


protobuf_c_boolean
protobuf_c_message_append_unknown_cast_message_dup(
                                ProtobufCInstance *instance,
                                ProtobufCMessage *msg,
                                uint32_t tag,
                                const ProtobufCFieldDescriptor *fdesc,
                                const ProtobufCMessage *submsg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(submsg);

  instance = protobuf_c_instance_get(instance);

  if (!expand_unknown_fields(instance, msg)) {
    goto no_memory;
  }

  ProtobufCMessageUnknownFields *unk_flds = msg->unknown_buffer;

  unsigned index = unk_flds->n_unknown_fields - 1;
  unk_flds->unknown_fields[index].base_.tag = tag;

  ProtobufCMessageUnknownField *target_fld = &unk_flds->unknown_fields[index];
  ProtobufCUnknownMessageCast *umcast = &target_fld->cmessage;

  ProtobufCMessage *message = protobuf_c_message_duplicate(instance,
                                submsg, fdesc->descriptor);
  if (!message) {
    goto no_memory;
  }

  umcast->fdesc = fdesc;
  umcast->message = message;

  PROTOBUF_C_FLAG_SET(target_fld->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                      PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST);

  return TRUE;

no_memory:
  PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
      "Unknown cast dup fail. No memory.");
  return FALSE;
}

void
protobuf_c_message_init_inner(const ProtobufCMessage* parent,
                              ProtobufCMessage* inner,
                              const ProtobufCFieldDescriptor* fdesc)
{
  PROTOBUF_C_ASSERT(fdesc && fdesc->msg_desc);
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(fdesc->msg_desc));

  protobuf_c_message_init(fdesc->msg_desc, inner);
  intptr_t offset = (intptr_t)inner - (intptr_t)parent;
  protobuf_c_ref_header_create(&inner->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_INNER, offset);

  ProtobufCMessageDebugStats* debug_stats = inner->descriptor->debug_stats;
  if (debug_stats) {
    g_atomic_int_inc(&debug_stats->init_inner_count);
  }
}

void
protobuf_c_message_init_inline_child(const ProtobufCMessage* parent,
                                     const char* fname,
                                     ProtobufCMessage* child)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(parent));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(parent));

  PROTOBUF_C_ASSERT(child);
  PROTOBUF_C_ASSERT(fname);

  const ProtobufCFieldDescriptor* fdesc =
      protobuf_c_message_descriptor_get_field_by_name(parent->descriptor, fname);

  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(fdesc->type == PROTOBUF_C_TYPE_MESSAGE);
  PROTOBUF_C_ASSERT(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  protobuf_c_message_init_inner(parent, child, fdesc);
}

void
protobuf_c_message_memcpy(ProtobufCMessage* dest,
                          const ProtobufCMessage* src)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(src));
  PROTOBUF_C_ASSERT(dest);

  dest->descriptor = src->descriptor;
  dest->unknown_buffer = src->unknown_buffer;
  /* Dont copy the ref_hdr */

  size_t header_sz = sizeof(ProtobufCMessage);
  uint8_t* dest_body = (uint8_t *)dest + header_sz;
  const uint8_t* src_body = (const uint8_t *)src + header_sz;
  memcpy(dest_body, src_body, src->descriptor->sizeof_message - header_sz);
}

int
protobuf_c_message_memcmp(const ProtobufCMessage* msg1,
                          const ProtobufCMessage* msg2)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg1));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg2));

  // Ignore the header while comparing.
  size_t header_sz = sizeof(ProtobufCMessage);
  uint8_t* a = (uint8_t *)msg1 + header_sz;
  uint8_t* b = (uint8_t *)msg2 + header_sz;

  return memcmp(a, b, msg1->descriptor->sizeof_message - header_sz);
}

/* === buffer-simple === */

void
protobuf_c_buffer_simple_append(ProtobufCBuffer *buffer,
                                size_t len,
                                const uint8_t *data)
{
  ProtobufCBufferSimple *simp = (ProtobufCBufferSimple *) buffer;
  buffer->instance = protobuf_c_instance_get(buffer->instance);
  size_t new_len = simp->len + len;

  if (new_len > simp->alloced) {
    size_t new_alloced = simp->alloced * 2;
    uint8_t *new_data;
    while (new_alloced < new_len) {
      new_alloced += new_alloced;
    }
    new_data = do_alloc(buffer->instance, new_alloced);
    if (!new_data) {
      return;
    }
    memcpy(new_data, simp->data, simp->len);
    if (simp->must_free_data) {
      do_free(buffer->instance, simp->data);
    } else {
      simp->must_free_data = TRUE;
    }
    simp->data = new_data;
    simp->alloced = new_alloced;
  }
  memcpy(simp->data + simp->len, data, len);
  simp->len = new_len;
}

const ProtobufCPackOptions protobuf_c_pack_opts_default =
{
  .sort_all = FALSE,
  .discard_unknown = FALSE,
};

const ProtobufCPackOptions protobuf_c_pack_opts_known_ordered =
{
  .sort_all = TRUE,
  .discard_unknown = TRUE,
};

const ProtobufCPackOptions protobuf_c_pack_opts_ordered =
{
  .sort_all = TRUE,
  .discard_unknown = FALSE,
};


/**
 * \defgroup packedsz protobuf_c_message_get_packed_size() implementation
 *
 * Routines mainly used by protobuf_c_message_get_packed_size().
 *
 * \ingroup internal
 * @{
 */

/**
 * Return the number of bytes required to store the tag for the field. Includes
 * 3 bits for the wire-type, and a single bit that denotes the end-of-tag.
 *
 * \param number
 *      Field tag to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
get_tag_size(unsigned number)
{
  if (number < (1 << 4)) {
    return 1;
  } else if (number < (1 << 11)) {
    return 2;
  } else if (number < (1 << 18)) {
    return 3;
  } else if (number < (1 << 25)) {
    return 4;
  }
  return 5;
}

/**
 * Return the number of bytes required to store a variable-length unsigned
 * 32-bit integer in base-128 varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
uint32_size(uint32_t v)
{
  if (v < (1 << 7)) {
    return 1;
  } else if (v < (1 << 14)) {
    return 2;
  } else if (v < (1 << 21)) {
    return 3;
  } else if (v < (1 << 28)) {
    return 4;
  }
  return 5;
}

/**
 * Return the number of bytes required to store a variable-length signed 32-bit
 * integer in base-128 varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
int32_size(int32_t v)
{
  if (v < 0) {
    return 10;
  } else if (v < (1 << 7)) {
    return 1;
  } else if (v < (1 << 14)) {
    return 2;
  } else if (v < (1 << 21)) {
    return 3;
  } else if (v < (1 << 28)) {
    return 4;
  }
  return 5;
}

/**
 * Return the ZigZag-encoded 32-bit unsigned integer form of a 32-bit signed
 * integer.
 *
 * \param v
 *      Value to encode.
 * \return
 *      ZigZag encoded integer.
 */
static inline uint32_t
zigzag32(int32_t v)
{
  if (v < 0) {
    return ((uint32_t) (-v)) * 2 - 1;
  }
  return v * 2;
}

/**
 * Return the number of bytes required to store a signed 32-bit integer,
 * converted to an unsigned 32-bit integer with ZigZag encoding, using base-128
 * varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
sint32_size(int32_t v)
{
  return uint32_size(zigzag32(v));
}

/**
 * Return the number of bytes required to store a 64-bit unsigned integer in
 * base-128 varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t
uint64_size(uint64_t v)
{
  uint32_t upper_v = (uint32_t) (v >> 32);

  if (upper_v == 0) {
    return uint32_size((uint32_t) v);
  } else if (upper_v < (1 << 3)) {
    return 5;
  } else if (upper_v < (1 << 10)) {
    return 6;
  } else if (upper_v < (1 << 17)) {
    return 7;
  } else if (upper_v < (1 << 24)) {
    return 8;
  } else if (upper_v < (1U << 31)) {
    return 9;
  }
  return 10;
}

/**
 * Return the ZigZag-encoded 64-bit unsigned integer form of a 64-bit signed
 * integer.
 *
 * \param v
 *      Value to encode.
 * \return
 *      ZigZag encoded integer.
 */
static inline uint64_t
zigzag64(int64_t v)
{
  if (v < 0) {
    return ((uint64_t) (-v)) * 2 - 1;
  }
  return v * 2;
}

/**
 * Return the number of bytes required to store a signed 64-bit integer,
 * converted to an unsigned 64-bit integer with ZigZag encoding, using base-128
 * varint encoding.
 *
 * \param v
 *      Value to encode.
 * \return
 *      Number of bytes required.
 */
static inline size_t sint64_size(int64_t v)
{
  return uint64_size(zigzag64(v));
}

/**
 * Calculate the serialized size of a single required message field, including
 * the space needed by the preceding tag.
 *
 * \param field
 *      Field descriptor for member.
 * \param member
 *      Field to encode.
 * \return
 *      Number of bytes required.
 */
static size_t
required_field_get_packed_size(const ProtobufCFieldDescriptor* fdesc,
                               const ProtobufCPackOptions* opts,
                               const void *member)
{
  size_t rv = get_tag_size(fdesc->id);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->get_packed_size);
    if (is_inline) {
      size_t len = ctype->get_packed_size(ctype, fdesc, member);
      return rv + uint32_size(len) + len;
    }
    size_t len = ctype->get_packed_size(ctype, fdesc, *(const void*const*)member);
    return rv + uint32_size(len) + len;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SINT32:
      return rv + sint32_size(*(const int32_t *) member);
    case PROTOBUF_C_TYPE_INT32:
      return rv + int32_size(*(const uint32_t *) member);
    case PROTOBUF_C_TYPE_UINT32:
      return rv + uint32_size(*(const uint32_t *) member);
    case PROTOBUF_C_TYPE_SINT64:
      return rv + sint64_size(*(const int64_t *) member);
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      return rv + uint64_size(*(const uint64_t *) member);
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
      return rv + 4;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
      return rv + 8;
    case PROTOBUF_C_TYPE_BOOL:
      return rv + 1;
    case PROTOBUF_C_TYPE_FLOAT:
      return rv + 4;
    case PROTOBUF_C_TYPE_DOUBLE:
      return rv + 8;
    case PROTOBUF_C_TYPE_ENUM:
      return rv + uint32_size(*(const int32_t *) member);
    case PROTOBUF_C_TYPE_STRING: {
      size_t len = 0;
      if (is_inline) {
        const void* eos = memchr(member, '\0', fdesc->data_size);
        PROTOBUF_C_ASSERT(eos); // cannot use all the bytes!
        len = (const char*)eos - (const char*)member;
      } else {
        const char* str = *(const char* const*) member;
        len = str ? strlen(str) : 0;
      }
      return rv + uint32_size(len) + len;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      size_t len = 0;
      if (is_inline) {
        len = ((const ProtobufCFlatBinaryData *) member)->len;
      } else {
        len = ((const ProtobufCBinaryData *) member)->len;
      }
      return rv + uint32_size(len) + len;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      const ProtobufCMessage *msg;
      if (is_inline) {
        msg = (const ProtobufCMessage *) member;
        PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER(msg));
      } else {
        msg = *(ProtobufCMessage * const *) member;
      }
      size_t subrv = msg ? protobuf_c_message_get_packed_size_opts(msg, opts) : 0;
      return rv + uint32_size(subrv) + subrv;
    }
    default:
      break;
  }
  PROTOBUF_C_ASSERT_NOT_REACHED();
  return 0;
}

/**
 * Calculate the serialized size of a single oneof message field, including
 * the space needed by the preceding tag. Returns 0 if the oneof field isn't
 * selected or is not set.
 *
 * \param field
 *      Field descriptor for member.
 * \param oneof_case
 *      A pointer to the case enum that selects the field in the oneof.
 * \param member
 *      Field to encode.
 * \return
 *      Number of bytes required.
 */
static size_t
oneof_field_get_packed_size(const ProtobufCFieldDescriptor *fdesc,
                            const ProtobufCPackOptions* opts,
                            const uint32_t *oneof_case,
                            const void *member)
{
  PROTOBUF_C_ASSERT(fdesc);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  if (*oneof_case == fdesc->id) {
    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_STRING:
      case PROTOBUF_C_TYPE_MESSAGE:
        if (!is_inline) {
          const void *ptr = *(const void * const *) member;
          if (ptr == NULL || ptr == fdesc->default_value) {
            return 0;
          }
        }
        break;
      case PROTOBUF_C_TYPE_BYTES:
        if (fdesc->ctype && !is_inline) {
          const void *ptr = *(const void* const*)member;
          if (ptr == NULL || ptr == fdesc->default_value) {
            return 0;
          }
        }
        break;
      default:
        break;
    }
  } else {
    return 0;
  }
  return required_field_get_packed_size(fdesc, opts, member);
}

/**
 * Calculate the serialized size of a single optional message field, including
 * the space needed by the preceding tag. Returns 0 if the optional field isn't
 * set.
 *
 * \param field
 *      Field descriptor for member.
 * \param has
 *      True if the field exists, false if not.
 * \param member
 *      Field to encode.
 * \return
 *      Number of bytes required.
 */
static size_t
optional_field_get_packed_size(const ProtobufCFieldDescriptor* fdesc,
                               const ProtobufCPackOptions* opts,
                               const protobuf_c_boolean *has,
                               const void *member)
{
  /* ATTN: Common code with optional_field_pack() and optional_field_pack_to_buffer()! */
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(has);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      if (fdesc->ctype && !is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    default:
      break;
  }
  if (has && !*has) {
    return 0;
  }
  return required_field_get_packed_size(fdesc, opts, member);
}

/**
 * Given a field type, return the in-memory size.
 *
 * \todo Implement as a table lookup.
 *
 * \param type
 *      Field type.
 * \return
 *      Size of the field.
 */
static size_t
sizeof_elt_in_repeated_array(const ProtobufCFieldDescriptor* fdesc)
{
  PROTOBUF_C_ASSERT(fdesc);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    if (is_inline) {
      return fdesc->data_size;
    }
    return sizeof(void*);
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
    case PROTOBUF_C_TYPE_ENUM:
      return 4;
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      return 8;
    case PROTOBUF_C_TYPE_BOOL:
      return sizeof(protobuf_c_boolean);
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
      if (is_inline) {
        return fdesc->data_size;
      }
      return sizeof(void*);
    case PROTOBUF_C_TYPE_BYTES:
      if (is_inline) {
        return fdesc->data_size;
      }
      return sizeof(ProtobufCBinaryData);
  }
  PROTOBUF_C_ASSERT_NOT_REACHED();
  return 0;
}

/**
 * Calculate the serialized size of repeated message fields, which may consist
 * of any number of values (including 0). Includes the space needed by the
 * preceding tags (as needed).
 *
 * \param field
 *      Field descriptor for member.
 * \param count
 *      Number of repeated field members.
 * \param member
 *      Field to encode.
 * \return
 *      Number of bytes required.
 */
static size_t
repeated_field_get_packed_size(const ProtobufCFieldDescriptor* fdesc,
                               const ProtobufCPackOptions* opts,
                               size_t count,
                               const void *member)
{
  size_t header_size;
  size_t rv = 0;
  unsigned i;
  size_t len;

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const char *array;
  if (is_inline) {
    array = (const char*)member;
  } else {
    array = *(const char* const *) member;
  }

  if (count == 0) {
    return 0;
  }

  header_size = get_tag_size(fdesc->id);
  if (0 == (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
    header_size *= count;
  }
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(!(fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED));
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->get_packed_size);
    for (i = 0; i < count; i++) {
      if (is_inline) {
        len = ctype->get_packed_size(ctype, fdesc, array + i*sizeof_elt);
      } else {
        len = ctype->get_packed_size(ctype, fdesc, ((const void*const*)array)[i]);
      }
      rv += uint32_size(len) + len;
    }
    return header_size + rv;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SINT32:
      for (i = 0; i < count; i++) {
        rv += sint32_size(((int32_t *) array)[i]);
      }
      break;
    case PROTOBUF_C_TYPE_INT32:
      for (i = 0; i < count; i++) {
        rv += int32_size(((uint32_t *) array)[i]);
      }
      break;
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_ENUM:
      for (i = 0; i < count; i++) {
        rv += uint32_size(((uint32_t *) array)[i]);
      }
      break;
    case PROTOBUF_C_TYPE_SINT64:
      for (i = 0; i < count; i++) {
        rv += sint64_size(((int64_t *) array)[i]);
      }
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      for (i = 0; i < count; i++) {
        rv += uint64_size(((uint64_t *) array)[i]);
      }
      break;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      rv += 4 * count;
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      rv += 8 * count;
      break;
    case PROTOBUF_C_TYPE_BOOL:
      rv += count;
      break;
    case PROTOBUF_C_TYPE_STRING:
      for (i = 0; i < count; i++) {
        if (is_inline) {
          const void* eos = memchr(&array[i*sizeof_elt], '\0', sizeof_elt);
          PROTOBUF_C_ASSERT(eos); // cannot use all the bytes!
          len = (const char*)eos - &array[i*sizeof_elt];
        } else {
          const char* str = ((const char*const*)array)[i];
          len = str ? strlen(str) : 0;
        }
        rv += uint32_size(len) + len;
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      for (i = 0; i < count; i++) {
        if (is_inline) {
          len = ((const ProtobufCFlatBinaryData *)(array + i*sizeof_elt))->len;
        } else {
          len = ((const ProtobufCBinaryData*)array)[i].len;
        }
        rv += uint32_size(len) + len;
      }
      break;
    case PROTOBUF_C_TYPE_MESSAGE:
      for (i = 0; i < count; i++) {
        if (is_inline) {
          len = protobuf_c_message_get_packed_size_opts(
            (const ProtobufCMessage *)(array + i*sizeof_elt), opts);
        } else {
          len = protobuf_c_message_get_packed_size_opts(
            ((const ProtobufCMessage* const*)array)[i], opts);
        }
        rv += uint32_size(len) + len;
      }
      break;
  }

  if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
    header_size += uint32_size(rv);
  }
  return header_size + rv;
}

/**
 * Calculate the serialized size of an unknown field, i.e. one that is passed
 * through mostly uninterpreted. This is required for forward compatibility if
 * new fields are added to the message descriptor.
 *
 * \param field
 *      Unknown field type.
 * \return
 *      Number of bytes required.
 */
static inline size_t
unknown_field_get_packed_size(const ProtobufCMessageUnknownField *unkn)
{
  PROTOBUF_C_ASSERT(unkn);

  size_t size = 0;

  switch(PROTOBUF_C_FLAG_GET(unkn->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    size = get_tag_size(unkn->base_.tag) + unkn->serialized.len;
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    const ProtobufCFieldDescriptor *fdesc = unkn->cmessage.fdesc;
    const ProtobufCMessage *msg = unkn->cmessage.message;

    size += get_tag_size(fdesc->id);
    const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

    if (ctype) {
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
      PROTOBUF_C_ASSERT(ctype->get_packed_size);

      size_t len = ctype->get_packed_size(ctype, fdesc, (void*)msg);
      return size + uint32_size(len) + len;
    }
    size_t subrv = protobuf_c_message_get_packed_size_opts(msg,
          &protobuf_c_pack_opts_default);

    size += uint32_size(subrv) + subrv;
  }
  break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

  return size;
}

/**@}*/

size_t protobuf_c_message_get_packed_size(ProtobufCInstance* instance,
                                          const ProtobufCMessage *message)
{
  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, get_pack_sz);

  return protobuf_c_message_get_packed_size_opts(message, &protobuf_c_pack_opts_default);
}

size_t protobuf_c_message_get_packed_size_opts(const ProtobufCMessage *message,
                                               const ProtobufCPackOptions* opts)
{
  unsigned i;
  size_t rv = 0;

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(opts);

  for (i = 0; i < message->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor* fdesc = message->descriptor->fields + i;
    const void *member = ((const char*)message) + fdesc->offset;
    const void *qmember = ((const char*)message) + fdesc->quantifier_offset;

    if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
      rv += required_field_get_packed_size(fdesc, opts, member);
    } else if (fdesc->label == PROTOBUF_C_LABEL_OPTIONAL) {
      /* All one-of fields are of optional type. The quantifier offset is the
       * case containing the field id/tag of the current set oneof field. */
      if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
        rv += oneof_field_get_packed_size(fdesc, opts, qmember, member);
      } else if (fdesc->quantifier_offset) {
        rv += optional_field_get_packed_size(fdesc, opts, qmember, member);
      } else {
        /* optional thing with no has_ field; rift-protoc-c sometimes does this for items with a default value */
        protobuf_c_boolean has = TRUE;
        rv += optional_field_get_packed_size(fdesc, opts, &has, member);
      }
    } else {
      rv += repeated_field_get_packed_size(fdesc, opts, *(const size_t*)qmember, member);
    }
  }

  if (!opts->discard_unknown && message->unknown_buffer) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(message));
    ProtobufCMessageUnknownFields* unk_buf = message->unknown_buffer;
    for (i = 0; i < unk_buf->n_unknown_fields; i++) {
      rv += unknown_field_get_packed_size(&unk_buf->unknown_fields[i]);
    }
  }

  return rv;
}

/**
 * \defgroup pack protobuf_c_message_pack() implementation
 *
 * Routines mainly used by protobuf_c_message_pack().
 *
 * \ingroup internal
 * @{
 */

static void
sortmgr_alloc_more(ProtobufCSerializedSortMgr** sortmgr_p, size_t n)
{
  PROTOBUF_C_ASSERT(sortmgr_p);
  ProtobufCSerializedSortMgr* sortmgr = *sortmgr_p;
  PROTOBUF_C_ASSERT(sortmgr);

  sortmgr->order_alloc += n;
  sortmgr->order = do_realloc(sortmgr->instance,
                              sortmgr->order,
                              sortmgr->order_alloc * sizeof(sortmgr->order[0]));
  if (NULL == sortmgr->order) {
    /* Ran out of memory. Make sure to remember. */
    *sortmgr_p = NULL;
  }
}

static void
sortmgr_save(ProtobufCSerializedSortMgr* sortmgr, uint32_t tag, size_t bytes)
{
  PROTOBUF_C_ASSERT(sortmgr);
  if (0 == bytes) {
    return;
  }

  PROTOBUF_C_ASSERT(sortmgr->n < sortmgr->order_alloc);
  sortmgr->order[sortmgr->n].tag = tag;
  sortmgr->order[sortmgr->n].out = sortmgr->out;
  sortmgr->order[sortmgr->n].length = bytes;
  sortmgr->out += bytes;
  ++sortmgr->n;
}

static int
sortmgr_compare(const void* va, const void* vb)
{
  /* qsort comparison function */
  const ProtobufCSerializedSort* a = va;
  const ProtobufCSerializedSort* b = vb;

  /* First, sort by tag */
  if (a->tag != b->tag) {
    return (int)a->tag - (int)b->tag;
  }

  /* Then, sort by serialized bytes */
  size_t len = a->length;
  if (len > b->length) {
    len = b->length;
  }
  int retval = memcmp(a->out, b->out, len);
  if (0 != retval) {
    return retval;
  }

  /* Then, whichever is shorter. */
  if (a->length != (int)b->length) {
    return (int)a->length - (int)b->length;
  }

  /* Finally, keep the order stable. */
  if (a->out < b->out) {
    return -1;
  }
  PROTOBUF_C_ASSERT(a->out > b->out);
  return 1;
}

/**
 * Pack an unsigned 32-bit integer in base-128 varint encoding and return the
 * number of bytes written, which must be 5 or less.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
uint32_pack(uint32_t value, uint8_t *out)
{
  unsigned rv = 0;

  if (value >= 0x80) {
    out[rv++] = value | 0x80;
    value >>= 7;
    if (value >= 0x80) {
      out[rv++] = value | 0x80;
      value >>= 7;
      if (value >= 0x80) {
        out[rv++] = value | 0x80;
        value >>= 7;
        if (value >= 0x80) {
          out[rv++] = value | 0x80;
          value >>= 7;
        }
      }
    }
  }
  /* PROTOBUF_C_ASSERT: value<128 */
  out[rv++] = value;
  return rv;
}

/**
 * Pack a signed 32-bit integer and return the number of bytes written.
 * Negative numbers are encoded as two's complement 64-bit integers.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
int32_pack(int32_t value, uint8_t *out)
{
  if (value < 0) {
    out[0] = value | 0x80;
    out[1] = (value >> 7) | 0x80;
    out[2] = (value >> 14) | 0x80;
    out[3] = (value >> 21) | 0x80;
    out[4] = (value >> 28) | 0x80;
    out[5] = out[6] = out[7] = out[8] = 0xff;
    out[9] = 0x01;
    return 10;
  } else {
    return uint32_pack(value, out);
  }
}

/**
 * Pack a signed 32-bit integer using ZigZag encoding and return the number of
 * bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint32_pack(int32_t value, uint8_t *out)
{
  return uint32_pack(zigzag32(value), out);
}

/**
 * Pack a 64-bit unsigned integer using base-128 varint encoding and return the
 * number of bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
uint64_pack(uint64_t value, uint8_t *out)
{
  uint32_t hi = (uint32_t) (value >> 32);
  uint32_t lo = (uint32_t) value;
  unsigned rv;

  if (hi == 0) {
    return uint32_pack((uint32_t) lo, out);
  }
  out[0] = (lo) | 0x80;
  out[1] = (lo >> 7) | 0x80;
  out[2] = (lo >> 14) | 0x80;
  out[3] = (lo >> 21) | 0x80;
  if (hi < 8) {
    out[4] = (hi << 4) | (lo >> 28);
    return 5;
  } else {
    out[4] = ((hi & 7) << 4) | (lo >> 28) | 0x80;
    hi >>= 3;
  }
  rv = 5;
  while (hi >= 128) {
    out[rv++] = hi | 0x80;
    hi >>= 7;
  }
  out[rv++] = hi;
  return rv;
}

/**
 * Pack a 64-bit signed integer in ZigZag encoding and return the number of
 * bytes written.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint64_pack(int64_t value, uint8_t *out)
{
  return uint64_pack(zigzag64(value), out);
}

/**
 * Pack a 32-bit quantity in little-endian byte order. Used for protobuf wire
 * types fixed32, sfixed32, float. Similar to "htole32".
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed32_pack(uint32_t value, void *out)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, &value, 4);
#else
  uint8_t *buf = out;

  buf[0] = value;
  buf[1] = value >> 8;
  buf[2] = value >> 16;
  buf[3] = value >> 24;
#endif
  return 4;
}

/**
 * Pack a 64-bit quantity in little-endian byte order. Used for protobuf wire
 * types fixed64, sfixed64, double. Similar to "htole64".
 *
 * \todo The big-endian impl is really only good for 32-bit machines, a 64-bit
 * version would be appreciated, plus a way to decide to use 64-bit math where
 * convenient.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed64_pack(uint64_t value, void *out)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, &value, 8);
#else
  fixed32_pack(value, out);
  fixed32_pack(value >> 32, ((char *) out) + 4);
#endif
  return 8;
}

/**
 * Pack a boolean value as an integer and return the number of bytes written.
 *
 * \todo Perhaps on some platforms *out = !!value would be a better impl, b/c
 * that is idiomatic C++ in some STL implementations.
 *
 * \param value
 *      Value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
boolean_pack(protobuf_c_boolean value, uint8_t *out)
{
  *out = value ? TRUE : FALSE;
  return 1;
}

/**
 * Pack a NUL-terminated C string and return the number of bytes written. The
 * output includes a length delimiter.
 *
 * The NULL pointer is treated as an empty string. This isn't really necessary,
 * but it allows people to leave required strings blank. (See Issue #13 in the
 * bug tracker for a little more explanation).
 *
 * \param str
 *      String to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
string_pack(const char *str, uint8_t *out)
{
  if (str == NULL) {
    out[0] = 0;
    return 1;
  }
  size_t len = strlen(str);
  size_t rv = uint32_pack(len, out);
  memcpy(out + rv, str, len);
  return rv + len;
}

/**
 * Pack a ProtobufCBinaryData and return the number of bytes written. The output
 * includes a length delimiter.
 *
 * \param bd
 *      ProtobufCBinaryData to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
binary_data_pack(const ProtobufCBinaryData *bd, uint8_t *out)
{
  size_t len = bd->len;
  size_t rv = uint32_pack(len, out);
  memcpy(out + rv, bd->data, len);
  return rv + len;
}

/*
 * Pack a ProtobufCBinaryData and return the number of bytes written. The output
 * includes a length delimiter.
 */
static inline size_t
flat_binary_data_pack(const ProtobufCFlatBinaryData *bd, uint8_t *out)
{
  size_t len = bd->len;
  size_t rv = uint32_pack(len, out);
  memcpy(out + rv, &bd->data[0], len);
  return rv + len;
}

/**
 * Pack a ProtobufCMessage and return the number of bytes written. The output
 * includes a length delimiter.
 *
 * \param message
 *      ProtobufCMessage object to pack.
 * \param[out] out
 *      Packed message.
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
prefixed_message_pack(ProtobufCInstance* instance,
                      const ProtobufCMessage *message,
                      const ProtobufCPackOptions* opts,
                      uint8_t *out)
{
  if (message == NULL) {
    out[0] = 0;
    return 1;
  }
  size_t rv = protobuf_c_message_pack_opts(instance, message, opts, out + 1);
  uint32_t rv_packed_size = uint32_size(rv);
  if (rv_packed_size != 1) {
    memmove(out + rv_packed_size, out + 1, rv);
  }
  return uint32_pack(rv, out) + rv;
}

/**
 * Pack a field tag.
 *
 * Wire-type will be added in required_field_pack().
 *
 * \todo Just call uint64_pack on 64-bit platforms.
 *
 * \param id
 *      Tag value to encode.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
tag_pack(uint32_t id, uint8_t *out)
{
  if (id < (1 << (32 - 3))) {
    return uint32_pack(id << 3, out);
  }
  return uint64_pack(((uint64_t) id) << 3, out);
}

/**
 * Pack a required field and return the number of bytes written.
 *
 * \param field
 *      Field descriptor.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
required_field_pack(ProtobufCInstance* instance,
                    const ProtobufCFieldDescriptor* fdesc,
                    const ProtobufCPackOptions* opts,
                    const void *member,
                    uint8_t *out)
{
  size_t rv = tag_pack(fdesc->id, out);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->pack);
    PROTOBUF_C_ASSERT(ctype->get_packed_size);
    out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;

    const void* data;
    if (is_inline) {
      data = member;
    } else {
      data = *(const void*const*)member;
      /* Treat null pointer as an error */
      /* ATTN: This may not be the "correct" translation of required fields... */
      if (!data) {
        return 0;
      }
    }

    size_t len = ctype->get_packed_size(ctype, fdesc, data);
    rv = rv + uint32_pack(len, out + rv);
    return rv + ctype->pack(ctype, fdesc, data, out + rv);
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SINT32:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + sint32_pack(*(const int32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_INT32:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + int32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_ENUM:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + uint32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SINT64:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + sint64_pack(*(const int64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + uint64_pack(*(const uint64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      out[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;
      return rv + fixed32_pack(*(const uint32_t *) member, out + rv);
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      out[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;
      return rv + fixed64_pack(*(const uint64_t *) member, out + rv);
    case PROTOBUF_C_TYPE_BOOL:
      out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      return rv + boolean_pack(*(const protobuf_c_boolean *) member, out + rv);
    case PROTOBUF_C_TYPE_STRING:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      if (is_inline) {
        return rv + string_pack((const char *) member, out + rv);
      }
      return rv + string_pack(*(char *const *) member, out + rv);
    case PROTOBUF_C_TYPE_BYTES:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      if (is_inline) {
        return rv + flat_binary_data_pack((const ProtobufCFlatBinaryData *) member, out + rv);
      }
      return rv + binary_data_pack((const ProtobufCBinaryData *) member, out + rv);
    case PROTOBUF_C_TYPE_MESSAGE:
      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      if (is_inline) {
        return rv + prefixed_message_pack(instance, (const ProtobufCMessage *) member, opts, out + rv);
      }
      return rv + prefixed_message_pack(instance, *(ProtobufCMessage * const *) member, opts, out + rv);
  }
  PROTOBUF_C_ASSERT_NOT_REACHED();
  return 0;
}

/**
 * Pack a oneof field and return the number of bytes written. Only packs the
 * field that is selected by the case enum.
 *
 * \param field
 *      Field descriptor.
 * \param oneof_case
 *      A pointer to the case enum that selects the field in the oneof.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
oneof_field_pack(ProtobufCInstance* instance,
                 const ProtobufCFieldDescriptor *fdesc,
                 const ProtobufCPackOptions* opts,
                 const uint32_t *oneof_case,
                 const void *member,
                 uint8_t *out)
{
  PROTOBUF_C_ASSERT(fdesc);
  if (*oneof_case != fdesc->id) {
    return 0;
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value)
          return 0;
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      if (fdesc->ctype && !is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value)
          return 0;
      }
      break;
    default:
      break;
  }
  return required_field_pack(instance, fdesc, opts, member, out);
}

/**
 * Pack an optional field and return the number of bytes written.
 *
 * \param field
 *      Field descriptor.
 * \param has
 *      Whether the field is set.
 * \param member
 *      The field member.
 * \param[out] out
 *      Packed value.
 * \return
 *      Number of bytes written to `out`.
 */

static size_t
optional_field_pack(ProtobufCInstance* instance,
                    const ProtobufCFieldDescriptor* fdesc,
                    const ProtobufCPackOptions* opts,
                    const protobuf_c_boolean *has,
                    const void *member,
                    uint8_t *out)
{
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(has);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      if (fdesc->ctype && !is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    default:
      break;
  }
  if (has && !*has) {
    return 0;
  }
  return required_field_pack(instance, fdesc, opts, member, out);
}

/**
 * Pack an array of 32-bit quantities.
 *
 * \param[out] out
 *      Destination.
 * \param[in] in
 *      Source.
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_32(void *out, const void *in, const unsigned n)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, in, n * 4);
#else
  unsigned i;
  const uint32_t *ini = in;
  for (i = 0; i < n; i++) {
    fixed32_pack(ini[i], (uint32_t *) out + i);
  }
#endif
}

/**
 * Pack an array of 64-bit quantities.
 *
 * \param[out] out
 *      Destination.
 * \param[in] in
 *      Source.
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_64(void *out, const void *in, const unsigned n)
{
#if !defined(WORDS_BIGENDIAN)
  memcpy(out, in, n * 8);
#else
  unsigned i;
  const uint64_t *ini = in;
  for (i = 0; i < n; i++) {
    fixed64_pack(ini[i], (uint64_t *) out + i);
  }
#endif
}

/**
 * Get the minimum number of bytes required to pack a field value of a
 * particular type.
 *
 * \param type
 *      Field type.
 * \return
 *      Number of bytes.
 */
static unsigned
get_type_min_size(ProtobufCType type)
{
  if (type == PROTOBUF_C_TYPE_SFIXED32 ||
      type == PROTOBUF_C_TYPE_FIXED32 ||
      type == PROTOBUF_C_TYPE_FLOAT)
  {
    return 4;
  }
  if (type == PROTOBUF_C_TYPE_SFIXED64 ||
      type == PROTOBUF_C_TYPE_FIXED64 ||
      type == PROTOBUF_C_TYPE_DOUBLE)
  {
    return 8;
  }
  return 1;
}

/**
 * Packs the elements of a repeated field and returns the serialised field and
 * its length.
 *
 * \param field
 *      Field descriptor.
 * \param count
 *      Number of elements in the repeated field array.
 * \param member
 *      Pointer to the elements for this repeated field.
 * \param[out] out
 *      Serialised representation of the repeated field.
 * \return
 *      Number of bytes serialised to `out`.
 */
static size_t
repeated_field_pack(ProtobufCInstance* instance,
                    const ProtobufCFieldDescriptor* fdesc,
                    const ProtobufCPackOptions* opts,
                    size_t count,
                    const void *member,
                    uint8_t *out,
                    ProtobufCSerializedSortMgr** sortmgr_p)
{
  if (count == 0) {
    return 0;
  }

  unsigned i;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const char *array;
  if (is_inline) {
    array = (const char *)member;
  } else {
    array = *(const char * const *) member;
  }

  if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
    unsigned header_len;
    unsigned len_start;
    unsigned min_length;
    unsigned payload_len;
    unsigned length_size_min;
    unsigned actual_length_size;
    uint8_t *payload_at;

    header_len = tag_pack(fdesc->id, out);
    out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
    len_start = header_len;
    min_length = get_type_min_size(fdesc->type) * count;
    length_size_min = uint32_size(min_length);
    header_len += length_size_min;
    payload_at = out + header_len;

    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_SFIXED32:
      case PROTOBUF_C_TYPE_FIXED32:
      case PROTOBUF_C_TYPE_FLOAT:
        copy_to_little_endian_32(payload_at, array, count);
        payload_at += count * 4;
        break;
      case PROTOBUF_C_TYPE_SFIXED64:
      case PROTOBUF_C_TYPE_FIXED64:
      case PROTOBUF_C_TYPE_DOUBLE:
        copy_to_little_endian_64(payload_at, array, count);
        payload_at += count * 8;
        break;
      case PROTOBUF_C_TYPE_INT32: {
        const int32_t *arr = (const int32_t *) array;
        for (i = 0; i < count; i++) {
          payload_at += int32_pack(arr[i], payload_at);
        }
        break;
      }
      case PROTOBUF_C_TYPE_SINT32: {
        const int32_t *arr = (const int32_t *) array;
        for (i = 0; i < count; i++) {
          payload_at += sint32_pack(arr[i], payload_at);
        }
        break;
      }
      case PROTOBUF_C_TYPE_SINT64: {
        const int64_t *arr = (const int64_t *) array;
        for (i = 0; i < count; i++) {
          payload_at += sint64_pack(arr[i], payload_at);
        }
        break;
      }
      case PROTOBUF_C_TYPE_ENUM:
      case PROTOBUF_C_TYPE_UINT32: {
        const uint32_t *arr = (const uint32_t *) array;
        for (i = 0; i < count; i++) {
          payload_at += uint32_pack(arr[i], payload_at);
        }
        break;
      }
      case PROTOBUF_C_TYPE_INT64:
      case PROTOBUF_C_TYPE_UINT64: {
        const uint64_t *arr = (const uint64_t *) array;
        for (i = 0; i < count; i++) {
          payload_at += uint64_pack(arr[i], payload_at);
        }
        break;
      }
      case PROTOBUF_C_TYPE_BOOL: {
        const protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;
        for (i = 0; i < count; i++) {
          payload_at += boolean_pack(arr[i], payload_at);
        }
        break;
      }
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }

    payload_len = payload_at - (out + header_len);
    actual_length_size = uint32_size(payload_len);
    if (length_size_min != actual_length_size) {
      PROTOBUF_C_ASSERT(actual_length_size == length_size_min + 1);
      memmove(out + header_len + 1, out + header_len, payload_len);
      header_len++;
    }
    uint32_pack(payload_len, out + len_start);
    return header_len + payload_len;
  }
  /* not "packed" cased */
  /* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */

  size_t rv = 0;
  unsigned siz = sizeof_elt_in_repeated_array(fdesc);
  if (*sortmgr_p) {
    sortmgr_alloc_more(sortmgr_p, count-1);
  }

  for (i = 0; i < count; i++) {
    size_t bytes = required_field_pack(instance, fdesc, opts, array, out + rv);
    array += siz;
    if (*sortmgr_p) {
      sortmgr_save(*sortmgr_p, fdesc->id, bytes);
    }
    rv += bytes;
  }
  return rv;
}

static size_t
unknown_field_pack(ProtobufCInstance *instance,
                   const ProtobufCMessageUnknownField *unkn,
                   uint8_t *out)
{
  PROTOBUF_C_ASSERT(out);
  size_t size = 0;

  switch (PROTOBUF_C_FLAG_GET(unkn->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    size_t rv = tag_pack(unkn->base_.tag, out);
    const ProtobufCUnknownSerialized *user = &unkn->serialized;

    out[0] |= user->wire_type;
    memcpy(out + rv, user->data, user->len);
    size = rv + user->len;
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    const ProtobufCUnknownMessageCast *umcast = &unkn->cmessage;
    const ProtobufCFieldDescriptor *fdesc = umcast->fdesc;
    const ProtobufCMessage *msg = umcast->message;

    size_t rv = tag_pack(fdesc->id, out);
    const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

    if (ctype) {
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
      PROTOBUF_C_ASSERT(ctype->pack);
      PROTOBUF_C_ASSERT(ctype->get_packed_size);

      out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;

      size_t len = ctype->get_packed_size(ctype, fdesc, (void*)msg);
      rv = rv + uint32_pack(len, out + rv);
      return rv + ctype->pack(ctype, fdesc, (void*)msg, out + rv);
    }

    out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
    size = rv + prefixed_message_pack(instance, msg,
        &protobuf_c_pack_opts_default, out + rv);
  }
  break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

  return size;
}

size_t
protobuf_c_message_pack_opts(ProtobufCInstance* instance,
                             const ProtobufCMessage *message,
                             const ProtobufCPackOptions* opts,
                             uint8_t *out)
{
  unsigned i;
  size_t rv = 0;
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(opts);

  instance = protobuf_c_instance_get(instance);
  ProtobufCMessageUnknownFields* unk_buf = message->unknown_buffer;

  ProtobufCSerializedSortMgr sortmgr_obj;
  ProtobufCSerializedSortMgr* sortmgr = NULL;
  if (opts->sort_all) {
    sortmgr = &sortmgr_obj;
    sortmgr->instance = instance;
    sortmgr->order = NULL;
    sortmgr->order_alloc = 0;
    sortmgr->n = 0;
    sortmgr->out = out;
    sortmgr->tmp_out = NULL;
    sortmgr_alloc_more(&sortmgr,
                          message->descriptor->n_fields
                        + ((unk_buf)?unk_buf->n_unknown_fields:0));
  }

  for (i = 0; i < message->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor* fdesc
      = message->descriptor->fields + i;
    const void *member = ((const char *) message) + fdesc->offset;

    /*
     * It doesn't hurt to compute qmember (a pointer to the
     * quantifier field of the structure), but the pointer is only
     * valid if the field is:
     *  - a repeated field, or
     *  - an optional field that isn't a pointer type
     * (Meaning: not a non-RIFT-inline message or a string).
     */
    const void *qmember
      = ((const char *) message) + fdesc->quantifier_offset;
    size_t bytes = 0;

    if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
      bytes = required_field_pack(instance, fdesc, opts, member, out + rv);
      if (sortmgr) {
        sortmgr_save(sortmgr, fdesc->id, bytes);
      }
    } else if (fdesc->label == PROTOBUF_C_LABEL_OPTIONAL) {
      if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
        bytes = oneof_field_pack (instance, fdesc, opts, qmember, member, out + rv);
      } else if (!fdesc->quantifier_offset) {
        protobuf_c_boolean has = TRUE;
        bytes = optional_field_pack(instance, fdesc, opts, &has, member, out + rv);
      } else {
        bytes = optional_field_pack(instance, fdesc, opts, qmember, member, out + rv);
      }
      if (sortmgr) {
        sortmgr_save(sortmgr, fdesc->id, bytes);
      }
    } else {
      bytes = repeated_field_pack(instance, fdesc, opts, *(const size_t *) qmember,
                                  member, out + rv, &sortmgr);
    }
    rv += bytes;
  }

  if (!opts->discard_unknown && unk_buf) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(message));
    for (i = 0; i < unk_buf->n_unknown_fields; i++) {
      size_t bytes = unknown_field_pack(instance, &unk_buf->unknown_fields[i], out + rv);
      if (sortmgr) {
        sortmgr_save(sortmgr, unk_buf->unknown_fields[i].base_.tag, bytes);
      }
      rv += bytes;
    }
  }

  if (opts->sort_all) {
    if (sortmgr == NULL) {
      PROTOBUF_C_MESSAGE_ERROR(instance, message, NULL,
                               "failed to sort serialized fields, no field memory");
      rv = 0;
    }

    if (rv) {
      sortmgr_obj.tmp_out = do_zalloc(sortmgr_obj.instance, rv);
      if (!sortmgr_obj.tmp_out) {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, NULL,
                                 "failed to sort serialized fields, no buffer memory");
        rv = 0;
        goto error;
      }
      qsort(sortmgr_obj.order,
            sortmgr_obj.n,
            sizeof(sortmgr_obj.order[0]),
            &sortmgr_compare);
      uint8_t* tmp_out = sortmgr_obj.tmp_out;
      for (i = 0; i < sortmgr_obj.n; ++i) {
        memcpy(tmp_out, sortmgr_obj.order[i].out, sortmgr_obj.order[i].length);
        tmp_out += sortmgr_obj.order[i].length;
      }
      memcpy(out, sortmgr_obj.tmp_out, rv);
    }
  }

error:
  if (opts->sort_all) {
    if (sortmgr_obj.order) {
      do_free(sortmgr_obj.instance, sortmgr_obj.order);
    }
    if (sortmgr_obj.tmp_out) {
      do_free(sortmgr_obj.instance, sortmgr_obj.tmp_out);
    }
  }
  return rv;
}

size_t
protobuf_c_message_pack(ProtobufCInstance* instance, const ProtobufCMessage *message, uint8_t *out)
{
  PROTOBUF_C_ASSERT(message);
  PROTOBUF_C_ASSERT(out);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, pack);

  return protobuf_c_message_pack_opts(instance, message, &protobuf_c_pack_opts_default, out);
}

/**@}*/


/**
 * \defgroup packbuf protobuf_c_message_pack_to_buffer() implementation
 *
 * Routines mainly used by protobuf_c_message_pack_to_buffer().
 *
 * \ingroup internal
 * @{
 */

/**
 * Pack a required field to a virtual buffer.
 *
 * \param field
 *      Field descriptor.
 * \param member
 *      The element to be packed.
 * \param[out] buffer
 *      Virtual buffer to append data to.
 * \return
 *      Number of bytes packed.
 */
static size_t
required_field_pack_to_buffer(const ProtobufCFieldDescriptor* fdesc,
                              const void *member,
                              ProtobufCBuffer *buffer)
{
  uint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];
  size_t rv = tag_pack(fdesc->id, scratch);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  ProtobufCInstance* instance = buffer->instance;
  PROTOBUF_C_ASSERT(instance);

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->pack);
    PROTOBUF_C_ASSERT(ctype->get_packed_size);

    const void* data;
    if (is_inline) {
      data = member;
    } else if (ctype) {
      data = *(const void* const*)member;
    }

    uint8_t stackbuf[4096];
    uint8_t* buf = NULL;
    size_t packed_size = ctype->get_packed_size(ctype, fdesc, data);
    if (packed_size <= sizeof(stackbuf)) {
      buf = stackbuf;
    } else {
      buf = (uint8_t*)do_alloc(instance, packed_size);
    }
    size_t ctype_size = ctype->pack(ctype, fdesc, data, buf);
    PROTOBUF_C_ASSERT(ctype_size == packed_size);

    scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
    rv += uint32_pack(packed_size, scratch + rv);
    buffer->append(buffer, rv, scratch);
    buffer->append(buffer, packed_size, buf);
    rv += packed_size;

    if (buf != stackbuf) {
      do_free(instance, buf);
    }
    return rv;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SINT32:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += sint32_pack(*(const int32_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_INT32:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += int32_pack(*(const uint32_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_ENUM:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += uint32_pack(*(const uint32_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_SINT64:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += sint64_pack(*(const int64_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += uint64_pack(*(const uint64_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;
      rv += fixed32_pack(*(const uint32_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;
      rv += fixed64_pack(*(const uint64_t *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_BOOL:
      scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
      rv += boolean_pack(*(const protobuf_c_boolean *) member, scratch + rv);
      buffer->append(buffer, rv, scratch);
      break;
    case PROTOBUF_C_TYPE_STRING: {
      size_t sublen = 0;
      const char *str = NULL;
      if (is_inline) {
        str = (const char *)member;
        const void* eos = memchr(member, '\0', fdesc->data_size);
        PROTOBUF_C_ASSERT(eos); // cannot use all the bytes!
        sublen = (const char*)eos - str;
      } else {
        str = *(const char* const*) member;
        sublen = str ? strlen(str) : 0;
      }

      scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      rv += uint32_pack(sublen, scratch + rv);
      buffer->append(buffer, rv, scratch);
      buffer->append(buffer, sublen, (const uint8_t *)str);
      rv += sublen;
      break;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      const uint8_t *data;
      size_t sublen;
      if (is_inline) {
        const ProtobufCFlatBinaryData *flatbin = (const ProtobufCFlatBinaryData*)member;
        sublen = flatbin->len;
        data = flatbin->data;
      } else {
        const ProtobufCBinaryData *bin = (const ProtobufCBinaryData*)member;
        sublen = bin->len;
        data = bin->data;
        PROTOBUF_C_ASSERT(sublen==0 || data);
      }

      scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      rv += uint32_pack(sublen, scratch + rv);
      buffer->append(buffer, rv, scratch);
      buffer->append(buffer, sublen, data);
      rv += sublen;
      break;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      const ProtobufCMessage *msg;
      if (is_inline) {
        msg = (const ProtobufCMessage *) member;
        PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER(msg));
      } else {
        msg = *(const ProtobufCMessage* const*) member;
      }

      uint8_t simple_buffer_scratch[4096];
      ProtobufCBufferSimple simple_buffer =
        PROTOBUF_C_BUFFER_SIMPLE_INIT(instance, simple_buffer_scratch);

      size_t sublen;
      if (msg == NULL) {
        sublen = 0;
      } else {
        sublen = protobuf_c_message_pack_to_buffer(msg, &simple_buffer.base);
      }

      scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
      rv += uint32_pack(sublen, scratch + rv);
      buffer->append(buffer, rv, scratch);
      buffer->append(buffer, sublen, simple_buffer.data);
      rv += sublen;
      PROTOBUF_C_BUFFER_SIMPLE_CLEAR(&simple_buffer);
      break;
    }
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  return rv;
}

/**
 * Pack a oneof field to a buffer. Only packs the field that is selected by the case enum.
 *
 * \param field
 *      Field descriptor.
 * \param oneof_case
 *      A pointer to the case enum that selects the field in the oneof.
 * \param member
 *      The element to be packed.
 * \param[out] buffer
 *      Virtual buffer to append data to.
 * \return
 *      Number of bytes serialised to `buffer`.
 */
static size_t
oneof_field_pack_to_buffer(const ProtobufCFieldDescriptor *fdesc,
                           const uint32_t *oneof_case,
                           const void *member,
                           ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT(fdesc);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  if (*oneof_case == fdesc->id) {
    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_STRING:
      case PROTOBUF_C_TYPE_MESSAGE:
        if (!is_inline) {
          const void *ptr = *(const void* const*)member;
          if (ptr == NULL || ptr == fdesc->default_value)
            return 0;
        }
        break;
      case PROTOBUF_C_TYPE_BYTES:
        if (fdesc->ctype && !is_inline) {
          const void *ptr = *(const void* const*)member;
          if (ptr == NULL || ptr == fdesc->default_value)
            return 0;
        }
        break;
      default:
        break;
    }
  } else {
    return 0;
  }
  return required_field_pack_to_buffer(fdesc, member, buffer);
}

/**
 * Pack an optional field to a buffer.
 *
 * \param field
 *      Field descriptor.
 * \param has
 *      Whether the field is set.
 * \param member
 *      The element to be packed.
 * \param[out] buffer
 *      Virtual buffer to append data to.
 * \return
 *      Number of bytes serialised to `buffer`.
 */
static size_t
optional_field_pack_to_buffer(const ProtobufCFieldDescriptor* fdesc,
                              const protobuf_c_boolean *has,
                              const void *member,
                              ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(has);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      if (fdesc->ctype && !is_inline) {
        const void *ptr = *(const void* const*)member;
        if (ptr == NULL || ptr == fdesc->default_value) {
          return 0;
        }
      }
      break;
    default:
      break;
  }
  if (has && !*has) {
    return 0;
  }
  return required_field_pack_to_buffer(fdesc, member, buffer);
}

/**
 * Get the packed size of an array of same field type.
 *
 * \param field
 *      Field descriptor.
 * \param count
 *      Number of elements of this type.
 * \param array
 *      The elements to get the size of.
 * \return
 *      Number of bytes required.
 */
static size_t
get_packed_payload_length(const ProtobufCFieldDescriptor* fdesc,
                          unsigned count,
                          const void *array)
{
  unsigned rv = 0;
  unsigned i;

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      return count * 4;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      return count * 8;
    case PROTOBUF_C_TYPE_INT32: {
      const int32_t *arr = (const int32_t *) array;
      for (i = 0; i < count; i++) {
        rv += int32_size(arr[i]);
      }
      break;
    }
    case PROTOBUF_C_TYPE_SINT32: {
      const int32_t *arr = (const int32_t *) array;
      for (i = 0; i < count; i++) {
        rv += sint32_size(arr[i]);
      }
      break;
    }
    case PROTOBUF_C_TYPE_ENUM:
    case PROTOBUF_C_TYPE_UINT32: {
      const uint32_t *arr = (const uint32_t *) array;
      for (i = 0; i < count; i++) {
        rv += uint32_size(arr[i]);
      }
      break;
    }
    case PROTOBUF_C_TYPE_SINT64: {
      const int64_t *arr = (const int64_t *) array;
      for (i = 0; i < count; i++) {
        rv += sint64_size(arr[i]);
      }
      break;
    }
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64: {
      const uint64_t *arr = (const uint64_t *) array;
      for (i = 0; i < count; i++) {
        rv += uint64_size(arr[i]);
      }
      break;
    }
    case PROTOBUF_C_TYPE_BOOL:
      return count;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  return rv;
}

/**
 * Pack an array of same field type to a virtual buffer.
 *
 * \param field
 *      Field descriptor.
 * \param count
 *      Number of elements of this type.
 * \param array
 *      The elements to get the size of.
 * \param[out] buffer
 *      Virtual buffer to append data to.
 * \return
 *      Number of bytes packed.
 */
static size_t
pack_buffer_packed_payload(const ProtobufCFieldDescriptor* fdesc,
                           unsigned count,
                           const void *array,
                           ProtobufCBuffer *buffer)
{
  uint8_t scratch[16];
  size_t rv = 0;
  unsigned i;

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
#if !defined(WORDS_BIGENDIAN)
      rv = count * 4;
      goto no_packing_needed;
#else
      for (i = 0; i < count; i++) {
        unsigned len = fixed32_pack(((uint32_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
#endif
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
#if !defined(WORDS_BIGENDIAN)
      rv = count * 8;
      goto no_packing_needed;
#else
      for (i = 0; i < count; i++) {
        unsigned len = fixed64_pack(((uint64_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
#endif
    case PROTOBUF_C_TYPE_INT32:
      for (i = 0; i < count; i++) {
        unsigned len = int32_pack(((int32_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
    case PROTOBUF_C_TYPE_SINT32:
      for (i = 0; i < count; i++) {
        unsigned len = sint32_pack(((int32_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
    case PROTOBUF_C_TYPE_ENUM:
    case PROTOBUF_C_TYPE_UINT32:
      for (i = 0; i < count; i++) {
        unsigned len = uint32_pack(((uint32_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
    case PROTOBUF_C_TYPE_SINT64:
      for (i = 0; i < count; i++) {
        unsigned len = sint64_pack(((int64_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      for (i = 0; i < count; i++) {
        unsigned len = uint64_pack(((uint64_t *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      break;
    case PROTOBUF_C_TYPE_BOOL:
      for (i = 0; i < count; i++) {
        unsigned len = boolean_pack(((protobuf_c_boolean *) array)[i], scratch);
        buffer->append(buffer, len, scratch);
        rv += len;
      }
      return count;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  return rv;

no_packing_needed:
  buffer->append(buffer, rv, array);
  return rv;
}

static size_t
repeated_field_pack_to_buffer(const ProtobufCFieldDescriptor* fdesc,
                              unsigned count,
                              const void *member,
                              ProtobufCBuffer *buffer)
{
  if (count == 0) {
    return 0;
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const char *array;
  if (is_inline) {
    array = (const char *)member;
  } else {
    array = *(const char* const*)member;
  }

  if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
    uint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];
    size_t rv = tag_pack(fdesc->id, scratch);
    size_t payload_len = get_packed_payload_length(fdesc, count, array);
    size_t tmp;

    scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
    rv += uint32_pack(payload_len, scratch + rv);
    buffer->append(buffer, rv, scratch);
    tmp = pack_buffer_packed_payload(fdesc, count, array, buffer);
    PROTOBUF_C_ASSERT(tmp == payload_len);
    return rv + payload_len;
  } else {
    size_t siz;
    unsigned i;
    /* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */
    unsigned rv = 0;

    siz = sizeof_elt_in_repeated_array(fdesc);
    for (i = 0; i < count; i++) {
      rv += required_field_pack_to_buffer(fdesc, array, buffer);
      array += siz;
    }
    return rv;
  }
}

static size_t
unknown_field_pack_to_buffer(const ProtobufCMessageUnknownField *unkn,
                             ProtobufCBuffer *buffer)
{
  switch(PROTOBUF_C_FLAG_GET(unkn->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    const ProtobufCUnknownSerialized *user = &unkn->serialized;
    uint8_t header[MAX_UINT64_ENCODED_SIZE];
    size_t rv = tag_pack(unkn->base_.tag, header);

    header[0] |= user->wire_type;
    buffer->append(buffer, rv, header);
    buffer->append(buffer, user->len, user->data);

    return rv + user->len;
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    const ProtobufCUnknownMessageCast *umcast = &unkn->cmessage;
    return protobuf_c_message_pack_to_buffer(umcast->message, buffer);
  }
  break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

}

/**@}*/

size_t
protobuf_c_message_pack_to_buffer(const ProtobufCMessage *message,
                                  ProtobufCBuffer *buffer)
{
  unsigned i;
  size_t rv = 0;

  PROTOBUF_C_ASSERT(buffer);
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(message));

  buffer->instance = protobuf_c_instance_get(buffer->instance);
  PROTOBUF_C_INC_STATS(buffer->instance, fcall, pack_to_buffer);

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  for (i = 0; i < message->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor* fdesc = message->descriptor->fields + i;
    const void *member = ((const char *) message) + fdesc->offset;
    const void *qmember = ((const char *) message) + fdesc->quantifier_offset;

    if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
      rv += required_field_pack_to_buffer(fdesc, member, buffer);
    } else if (fdesc->label == PROTOBUF_C_LABEL_OPTIONAL) {
      if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
        rv += oneof_field_pack_to_buffer( fdesc, qmember, member, buffer );
      } else {
        rv += optional_field_pack_to_buffer( fdesc, qmember, member, buffer );
      }
    } else {
      rv += repeated_field_pack_to_buffer( fdesc, *(const size_t *) qmember, member, buffer );
    }
  }
  if (message->unknown_buffer) {
    ProtobufCMessageUnknownFields* unk_buf = message->unknown_buffer;
    for (i = 0; i < unk_buf->n_unknown_fields; i++) {
      rv += unknown_field_pack_to_buffer(&unk_buf->unknown_fields[i], buffer);
    }
  }
  return rv;
}

/**
 * \defgroup unpack unpacking implementation
 *
 * Routines mainly used by the unpacking functions.
 *
 * \ingroup internal
 * @{
 */

static inline int
int_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)
{
  if (n_ranges == 0) {
    return -1;
  }

  unsigned start = 0;
  unsigned n = n_ranges;
  while (n > 1) {
    unsigned mid = start + n / 2;

    if (value < ranges[mid].start_value) {
      n = mid - start;
    } else if (value >= (ranges[mid].start_value +
                         (int) (ranges[mid + 1].orig_index -
                         ranges[mid].orig_index))) {
      unsigned new_start = mid + 1;
      n = start + n - new_start;
      start = new_start;
    } else {
      return (value - ranges[mid].start_value) + ranges[mid].orig_index;
    }
  }
  if (n > 0) {
    unsigned start_orig_index = ranges[start].orig_index;
    unsigned range_size = ranges[start + 1].orig_index - start_orig_index;

    if (   ranges[start].start_value <= value
        && value < (int) (ranges[start].start_value + range_size)) {
      return (value - ranges[start].start_value) + start_orig_index;
    }
  }
  return -1;
}

static size_t
parse_tag_and_wiretype(size_t len,
                       const uint8_t *data,
                       uint32_t *tag_out,
                       ProtobufCWireType *wiretype_out)
{
  unsigned max_rv = len > 5 ? 5 : len;
  uint32_t tag = (data[0] & 0x7f) >> 3;
  unsigned shift = 4;
  unsigned rv;

  *wiretype_out = data[0] & 7;
  if ((data[0] & 0x80) == 0) {
    *tag_out = tag;
    return 1;
  }
  for (rv = 1; rv < max_rv; rv++) {
    if (data[rv] & 0x80) {
      tag |= (data[rv] & 0x7f) << shift;
      shift += 7;
    } else {
      tag |= data[rv] << shift;
      *tag_out = tag;
      return rv + 1;
    }
  }
  return 0; /* error: bad header */
}

/* sizeof(ScannedMember) must be <= (1<<BOUND_SIZEOF_SCANNED_MEMBER_LOG2) */
#define BOUND_SIZEOF_SCANNED_MEMBER_LOG2 5
typedef struct _ScannedMember ScannedMember;
/** Field as it's being read. */
struct _ScannedMember {
  uint32_t tag;              /**< Field tag. */
  uint8_t wire_type;         /**< Field type. */
  uint8_t length_prefix_len; /**< Prefix length. */
  const ProtobufCFieldDescriptor *fdesc; /**< Field descriptor. */
  size_t len;                /**< Field length. */
  const uint8_t *data;       /**< Pointer to field data. */
};

static inline uint32_t
scan_length_prefixed_data(ProtobufCInstance* instance,
                          size_t len,
                          const uint8_t *data,
                          size_t *prefix_len_out)
{
  unsigned hdr_max = len < 5 ? len : 5;
  unsigned hdr_len;
  uint32_t val = 0;
  unsigned i;
  unsigned shift = 0;

  for (i = 0; i < hdr_max; i++) {
    val |= (data[i] & 0x7f) << shift;
    shift += 7;
    if ((data[i] & 0x80) == 0) {
      break;
    }
  }
  if (i == hdr_max) {
    PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                            "error parsing length for length-prefixed data");
    return 0;
  }
  hdr_len = i + 1;
  *prefix_len_out = hdr_len;
  if (hdr_len + val > len) {
    PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                             "data too short after length-prefix of %u", val);
    return 0;
  }
  return hdr_len + val;
}

static size_t max_b128_numbers(size_t len, const uint8_t *data)
{
  size_t rv = 0;
  while (len--) {
    if ((*data++ & 0x80) == 0) {
      ++rv;
    }
  }
  return rv;
}

protobuf_c_boolean
protobuf_c_message_compare_keys(const ProtobufCMessage *earlier,
                                const ProtobufCMessage *latter,
                                const ProtobufCMessageDescriptor *mdesc)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(earlier));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(latter));
  /*
   * This function checks whether both the messages have same
   * keys values for all the key fields.
   * ATTN: Need a more efficient way to index key fields rather than
   * a plain linear search.
   */
  for (unsigned i = 0; i < mdesc->n_fields; i++) {

    if (!(mdesc->fields[i].rw_flags & RW_PROTOBUF_FOPT_KEY)) {
      continue;
    }
    const ProtobufCFieldDescriptor *key_fdesc = &mdesc->fields[i];

    // Keys are required fields, atleast for now.
    PROTOBUF_C_ASSERT(key_fdesc->label == PROTOBUF_C_LABEL_REQUIRED);
    bool is_inline = !!(key_fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

    void *key_ptr1 = ((char *)earlier) + key_fdesc->offset;
    void *key_ptr2 = ((char *)latter) + key_fdesc->offset;
    protobuf_c_boolean match = FALSE;

    if (key_fdesc->ctype) {
      PROTOBUF_C_ASSERT(key_fdesc->ctype->compare);
      int ret = 0;
      if (is_inline) {
        ret = key_fdesc->ctype->compare(key_fdesc->ctype,
                                          key_fdesc,
                                          key_ptr1, key_ptr2);
      } else {
        ret = key_fdesc->ctype->compare(key_fdesc->ctype,
                                          key_fdesc,
                                          *(void **)key_ptr1,
                                          *(void **)key_ptr2);
      }

      if (ret != 0) {
        return FALSE;
      }
      continue;
    }

    size_t ksize = sizeof_elt_in_repeated_array(key_fdesc);

    switch(key_fdesc->type) {
      case PROTOBUF_C_TYPE_STRING:
        if (is_inline) {
          match = (0 == strcmp((char *)key_ptr1, (char *)key_ptr2));
        } else {
          match = (0 == strcmp(*(char **)key_ptr1, *(char **)key_ptr2));
        }
        break;
      case PROTOBUF_C_TYPE_BYTES: {
        if (is_inline) {
          ProtobufCFlatBinaryData *bkey1 = (ProtobufCFlatBinaryData *)key_ptr1;
          ProtobufCFlatBinaryData *bkey2 = (ProtobufCFlatBinaryData *)key_ptr2;
          if (   (bkey1->len == bkey2->len)
              && (0 == memcmp(bkey1->data, bkey2->data, bkey1->len))) {
            match = TRUE;
          }
        } else {
          ProtobufCBinaryData *bkey1 = (ProtobufCBinaryData *)key_ptr1;
          ProtobufCBinaryData *bkey2 = (ProtobufCBinaryData *)key_ptr2;
          if (   (bkey1->len == bkey2->len)
              && (0 == memcmp(bkey1->data, bkey2->data, bkey1->len))) {
            match = TRUE;
          }
        }
        break;
      }
      case PROTOBUF_C_TYPE_MESSAGE:
        PROTOBUF_C_ASSERT_NOT_REACHED();
      default:
        // Other primitive types.
        match = (0 == memcmp(key_ptr1, key_ptr2, ksize));
        break;
    }

    if (!match) {
      return FALSE;
    }
  }

  return TRUE;
}

static protobuf_c_boolean
merge_ctype_field(ProtobufCInstance* instance,
                  ProtobufCMessage *from,
                  ProtobufCMessage *to,
                  const ProtobufCFieldDescriptor *fdesc,
                  ProtobufCMergeOptions_t opts)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
  PROTOBUF_C_ASSERT(fdesc->ctype);

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  protobuf_c_boolean ok = TRUE;

  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  uint32_t qf_f = 0, qf_t = 0;
  uint8_t* ctype_f = NULL, *ctype_t = NULL;

  if (fdesc->quantifier_offset) {
    qf_f = STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset);
    qf_t = STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset);
  }

  if (is_inline) {
    ctype_f = STRUCT_MEMBER_PTR(uint8_t, from, fdesc->offset);
    ctype_t = STRUCT_MEMBER_PTR(uint8_t, to, fdesc->offset);
  } else {
    ctype_f = STRUCT_MEMBER(uint8_t*, from, fdesc->offset);
    ctype_t = STRUCT_MEMBER(uint8_t*, to, fdesc->offset);

    if (fdesc->label != PROTOBUF_C_LABEL_REPEATED) {
      if (ctype_f) qf_f = 1;
      if (ctype_t) qf_t = 1;
    }
  }

  if (!qf_f) {
    return ok;
  }

  PROTOBUF_C_ASSERT(fdesc->ctype->deep_copy);

  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_OPTIONAL: {

      if ((qf_t) && !(opts.flags & MERGE_FLAG_TO_BEFORE_FROM)) {
        break;
      }

      if (is_inline || qf_t) {
        // Just call deep_copy, the API should take care of clearing any fields.
        ok = fdesc->ctype->deep_copy(instance, fdesc->ctype, fdesc, ctype_f, TRUE, ctype_t);
      } else {
        if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
          STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = ctype_f; // Take-away the pointer!
          ctype_f = NULL;
        } else {
          ctype_t = (uint8_t *)do_alloc(instance, fdesc->data_size);
          if (fdesc->ctype->init_usebody) {
            (fdesc->ctype->init_usebody)(fdesc->ctype, fdesc, ctype_t);
          }
          STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = ctype_t;
          ok = fdesc->ctype->deep_copy(instance, fdesc->ctype, fdesc, ctype_f, FALSE, ctype_t);
        }
      }
      if (fdesc->quantifier_offset) {
        STRUCT_MEMBER(protobuf_c_boolean, to, fdesc->quantifier_offset) = TRUE;
      }
      break;
    }
    case PROTOBUF_C_LABEL_REPEATED: {

      size_t f_list_size = qf_f*sizeof_elt;
      size_t t_list_size = qf_t*sizeof_elt;

      if (is_inline) {
        if ((qf_f + qf_t) > fdesc->rw_inline_max) {
          return FALSE; // Not enough space.
        }

        if (opts.flags & MERGE_FLAG_FROM_BEFORE_TO) {
          memmove(ctype_t+f_list_size, ctype_t, t_list_size);
        } else {
          ctype_t += t_list_size;
        }
      } else {
        if (!qf_t) {
          if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
            STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = ctype_f; // Take away the pointer!
            STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += qf_f;
            ctype_f = NULL;
            break;
          }
        }

        uint8_t* ctype_n = do_alloc(instance, t_list_size+f_list_size);
        if (opts.flags & MERGE_FLAG_FROM_BEFORE_TO) {
          memcpy(ctype_n+f_list_size, ctype_t, t_list_size);
          do_free(instance, ctype_t);
          ctype_t = ctype_n;
        } else {
          memcpy(ctype_n, ctype_t, t_list_size);
          do_free(instance, ctype_t);
          ctype_t = ctype_n+t_list_size;
        }
        STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = ctype_n;
      }

      if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
        memcpy(ctype_t, ctype_f, qf_f * sizeof_elt); // Grab the pointers!
        STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += qf_f;
        break;
      }

      for (unsigned i = 0; i < qf_f && ok; i++) {
        uint8_t* src = ctype_f + (i * sizeof_elt);
        uint8_t* dest = ctype_t + (i * sizeof_elt);
        if (!is_inline) {
          uint8_t* temp = (uint8_t *)do_alloc(instance, fdesc->data_size);
          *((uint8_t **)dest) = temp; dest = temp;
          src = *((uint8_t **)src);
        }
        if (fdesc->ctype->init_usebody) {
          fdesc->ctype->init_usebody(fdesc->ctype, fdesc, dest);
        }
        ok = fdesc->ctype->deep_copy(instance, fdesc->ctype, fdesc, src, FALSE, dest);
        if (ok) STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += 1;
      }
    }
    default:
      break;
  }

  /* Clean up the from message */
  if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {

    if (fdesc->quantifier_offset &&
        fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
      STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset) = 0;
    }
    if (!is_inline) {
      if (ctype_f) {
        do_free(instance, ctype_f);
      }
      STRUCT_MEMBER(uint8_t*, from, fdesc->offset) = NULL;
    }
  }

  return ok;
}

static protobuf_c_boolean
merge_repeated_keyed_msg_field(ProtobufCInstance* instance,
                               ProtobufCMessage *from,
                               ProtobufCMessage *to,
                               const ProtobufCFieldDescriptor* fdesc,
                               ProtobufCMergeOptions_t opts)
{
  protobuf_c_boolean ok = TRUE;
  instance = protobuf_c_instance_get(instance);

  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  bool is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  uint32_t n_from = STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset);
  uint32_t n_to = STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset);

  if (!n_from) {
    return TRUE;
  }

  uint8_t* f_array = NULL;
  uint8_t* t_array = NULL;

  if (is_inline) {
    f_array = STRUCT_MEMBER_PTR(uint8_t, from, fdesc->offset);
    t_array = STRUCT_MEMBER_PTR(uint8_t, to, fdesc->offset);
  } else {
    f_array = STRUCT_MEMBER(uint8_t*, from, fdesc->offset);
    t_array = STRUCT_MEMBER(uint8_t*, to, fdesc->offset);
  }

  ProtobufCMessage* add_list[n_from]; // Used only in non-inline case.
  unsigned added_count = 0, merged_count = 0;
  uint8_t* add_loc = NULL;

  do {
    /*
     * If the destination list is empty, and move fields is specified
     * memcpy at one shot!
     */
    if (!n_to) {
      if (!is_inline) {
        t_array = do_alloc(instance, n_from*sizeof_elt);
        STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = t_array;
      }

      if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
        memcpy(t_array, f_array, n_from*sizeof_elt);
        STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) = n_from;
        added_count += n_from;
        break;
      }
    }

    // New elements are always appended to the destination list.
    add_loc = t_array + (n_to * sizeof_elt);

    for (unsigned f_index = 0; f_index < n_from && ok; f_index++) {

      ProtobufCMessage* msg1 = NULL, *msg2 = NULL;
      if (is_inline) {
        msg1 = (ProtobufCMessage *)(f_array + (f_index * sizeof_elt));
      } else {
        msg1 = *((ProtobufCMessage **)(f_array + (f_index * sizeof_elt)));
      }

      bool need_to_copy = true;

      for (unsigned t_index = 0; t_index < n_to; t_index++) {

        if (is_inline) {
          msg2 = (ProtobufCMessage *)(t_array + (t_index * sizeof_elt));
        } else {
          msg2 = *((ProtobufCMessage **)(t_array + (t_index * sizeof_elt)));
        }

        if (protobuf_c_message_compare_keys(msg1, msg2, fdesc->msg_desc)) {
          // The messages have same keys, they must be merged.
          ok = merge_messages(instance, msg1, msg2, opts);
          need_to_copy = false;
          break;
        }
      }

      if (!ok) {
        break;
      }

      if (need_to_copy) {
        /*
         * This message does not exists in the target list.
         * Add this to the target list.
         */
        if (is_inline) {

          if ((added_count + n_to) >= fdesc->rw_inline_max) {
            /* No space in the target to copy this element. */
            ok = FALSE;
          } else {

            uint8_t *target = add_loc + (added_count * sizeof_elt);
            if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
              memcpy(target, msg1, fdesc->msg_desc->sizeof_message);
            } else {
              ok = protobuf_c_message_copy_usebody(instance, msg1, (ProtobufCMessage *)target);
            }
          }

          if (ok) {
            // The addition of this msg was successfull incr the count
            STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += 1;
          }

        } else {
          //Non-line case, just store the pointers to be copied/moved later.
          add_list[added_count] = msg1;
        }
        added_count++;
        continue;
      }

      /* This message was successfully merged to the target list.
       * If move_fields flag is specified, then this msg has to be
       * freed/cleaned up
       */
      merged_count++;
      if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
        if (is_inline) {
          protobuf_c_message_free_unpacked_usebody(instance, msg1);
        } else {
          protobuf_c_message_free_unpacked(instance, msg1);
        }
      }
    }

    if (!ok) {
      break;
    }

    PROTOBUF_C_ASSERT(added_count + merged_count == n_from);

    if (!is_inline) {
      /*
       * For the non-inline case, we just stored the pointers that
       * were not merged to the add_list. Copy or move them to the target list
       * after reallocating the array if there were any.
       */
      if (added_count != 0) {

        unsigned tot_elems = n_to + added_count;
        t_array = do_realloc(instance, t_array, tot_elems*sizeof(void*));
        STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = t_array;
        add_loc = t_array + (n_to * sizeof_elt);

        for (unsigned i = 0; i < added_count; i++) {
          ProtobufCMessage **target = (ProtobufCMessage **)(add_loc + (i * sizeof_elt));
          if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
            *target = add_list[i]; // Take the pointer!
          } else {
            *target = protobuf_c_message_duplicate(instance, add_list[i], fdesc->msg_desc);
            if (!*target) {
              ok = FALSE;
              break;
            }
          }

          add_list[i] = NULL;
          STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += 1;
        }
      }
    }

  } while (0);

  if (!ok) {
    /*
     * "from" message will be in bad state if the merge failed inbetween
     * and we resued some of its elements.
     * Merged messages are already freed above.
     * So go over and free the seen-unmerged and unseen messages.
     */
    if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {

      // Free unseen
      for (unsigned i = (added_count + merged_count); i < n_from; i++) {
        ProtobufCMessage *msg = (ProtobufCMessage *)(f_array + (i * sizeof_elt));
        if (is_inline) {
          protobuf_c_message_free_unpacked_usebody(instance, msg);
        } else {
          protobuf_c_message_free_unpacked(instance, msg);
        }
      }

      // Free seen unmerged
      for (unsigned i = 0; i < added_count; i++) {
        if (add_list[i] != NULL) {
          protobuf_c_message_free_unpacked(instance, add_list[i]);
        }
      }
    }
  }

  if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
    STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset) = 0;
    if (!is_inline) {
      do_free(instance, f_array);
      STRUCT_MEMBER(ProtobufCMessage**, from, fdesc->offset) = NULL;
    }
  }

  return ok;
}

static protobuf_c_boolean
merge_repeated_field(ProtobufCInstance* instance,
                     ProtobufCMessage* from,
                     ProtobufCMessage* to,
                     const ProtobufCFieldDescriptor* fdesc,
                     ProtobufCMergeOptions_t opts)
{
  instance = protobuf_c_instance_get(instance);
  protobuf_c_boolean ok = TRUE;

  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  bool is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  uint32_t n_from = STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset);
  uint32_t n_to = STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset);

  if (!n_from) {
    return TRUE;
  }

  if (is_inline) {
    if (n_to + n_from > fdesc->rw_inline_max) {
      return FALSE; // Not enough space in the target!
    }
  }

  uint8_t* f_array = NULL;
  uint8_t* t_array = NULL;

  if (is_inline) {
    f_array = STRUCT_MEMBER_PTR(uint8_t, from, fdesc->offset);
    t_array = STRUCT_MEMBER_PTR(uint8_t, to, fdesc->offset);
  } else {
    f_array = STRUCT_MEMBER(uint8_t*, from, fdesc->offset);
    t_array = STRUCT_MEMBER(uint8_t*, to, fdesc->offset);
  }

  size_t f_list_size = n_from * sizeof_elt;
  size_t t_list_size = n_to * sizeof_elt;

  do {

    if (!n_to && !is_inline) {
      if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
        STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = f_array; // Grab the complete array.
        STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += n_from;
        f_array = NULL;
        break;
      }
    }

    if (!is_inline) {
      t_array = do_alloc(instance, f_list_size + t_list_size);
    }

    if (t_list_size) {
      if (!is_inline) {
        uint8_t* old_array = STRUCT_MEMBER(uint8_t*, to, fdesc->offset);
        if (opts.flags & MERGE_FLAG_FROM_BEFORE_TO) {
          // From list elements should come first in the target
          memcpy(t_array+f_list_size, old_array, t_list_size);
        } else {
          memcpy(t_array, old_array, t_list_size);
        }
        do_free(instance, old_array);
      } else {
        if (opts.flags & MERGE_FLAG_FROM_BEFORE_TO) {
          // Do a memmove to move the "to" elements past the list
          memmove(t_array+f_list_size, t_array, t_list_size);
        }
      }
    }

    if (!is_inline) {
      STRUCT_MEMBER(uint8_t*, to, fdesc->offset) = t_array;
    }

    if (!(opts.flags & MERGE_FLAG_FROM_BEFORE_TO)) {
      t_array += t_list_size;
    }

    bool is_primitive = (fdesc->type != PROTOBUF_C_TYPE_STRING &&
                         fdesc->type != PROTOBUF_C_TYPE_BYTES  &&
                         fdesc->type != PROTOBUF_C_TYPE_MESSAGE);

    bool can_do_memcpy = (opts.flags & MERGE_FLAG_MOVE_FIELDS) ||
                         (is_primitive) ||
                         (is_inline && (fdesc->type != PROTOBUF_C_TYPE_MESSAGE));

    if (can_do_memcpy) {
      memcpy(t_array, f_array, n_from*sizeof_elt);
      STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += n_from;
      break;
    }

    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_MESSAGE: {
        for (unsigned i = 0; i < n_from && ok; i++) {
          ProtobufCMessage* src = NULL;
          if (is_inline) {
            src = (ProtobufCMessage *)(f_array + (i * sizeof_elt));
            ProtobufCMessage* dest = (ProtobufCMessage *)(t_array + (i * sizeof_elt));
            ok = protobuf_c_message_copy_usebody(instance, src, dest);
          } else {
            src = *(ProtobufCMessage **)(f_array + (i * sizeof_elt));
            ProtobufCMessage** dest = (ProtobufCMessage **)(t_array + (i * sizeof_elt));
            *dest = protobuf_c_message_duplicate(instance, src, fdesc->msg_desc);
            if (!*dest) {
              ok = FALSE;
            }
          }

          STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += 1;
        }
        break;
      }
      case PROTOBUF_C_TYPE_STRING: {
        char **dest = (char **)t_array;
        char **src  = (char **)f_array;
        for (unsigned i = 0; i < n_from; i++) {
          dest[i] = do_alloc(instance, strlen(src[i])+1);
          strcpy(dest[i], src[i]);
        }
        STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += n_from;
        break;
      }
      case PROTOBUF_C_TYPE_BYTES: {
        ProtobufCBinaryData* dest = (ProtobufCBinaryData *)t_array;
        ProtobufCBinaryData* src =  (ProtobufCBinaryData *)f_array;
        for (unsigned i = 0; i < n_from; i++) {
          dest[i].data = do_alloc(instance, src[i].len);
          memcpy(dest[i].data, src[i].data, src[i].len);
          dest[i].len = src[i].len;
        }
        STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) += n_from;
        break;
      }
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }

  } while(0);

  if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
    STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset) = 0;
    if (!is_inline) {
      if (f_array) do_free(instance, f_array);
      STRUCT_MEMBER(uint8_t*, from, fdesc->offset) = NULL;
    }
  }

  return ok;
}

static protobuf_c_boolean
merge_singular_field(ProtobufCInstance* instance,
                     ProtobufCMessage* from,
                     ProtobufCMessage* to,
                     const ProtobufCFieldDescriptor* fdesc,
                     ProtobufCMergeOptions_t opts)
{
  protobuf_c_boolean ok = TRUE;

  bool is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

  uint32_t qf_f = FALSE, qf_t = FALSE;
  uint8_t* f_field = NULL;
  uint8_t* t_field = NULL;


  if (fdesc->quantifier_offset) {
    qf_f = STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset);
    qf_t = STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset);
  }

  /*
   * Now we have to get the field ptr, if not inline we need
   * the actual data pointer and not the field ptr.
   * For bytes whether it is inline or not we need the field ptr.
   * For one of fields, the quantifier offset doesn't indicate
   * that the field is inline. So some combination of checks here
   */
  bool is_primitive = (fdesc->type != PROTOBUF_C_TYPE_STRING &&
                       fdesc->type != PROTOBUF_C_TYPE_BYTES  &&
                       fdesc->type != PROTOBUF_C_TYPE_MESSAGE);

  if (is_primitive || is_inline || fdesc->type == PROTOBUF_C_TYPE_BYTES) {
    f_field = STRUCT_MEMBER_PTR(uint8_t, from, fdesc->offset);
    t_field = STRUCT_MEMBER_PTR(uint8_t, to, fdesc->offset);

    if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
      qf_f = qf_t = 1;
    }

  } else {

    f_field = STRUCT_MEMBER(uint8_t*, from, fdesc->offset);
    t_field = STRUCT_MEMBER(uint8_t*, to, fdesc->offset);

    if (!(fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
      if (f_field != fdesc->default_value)  qf_f = 1;
      if (t_field != fdesc->default_value)  qf_t = 1;
    }
  }

  if (!qf_f) {
    return ok;
  }

  if (   qf_t
      && !(opts.flags & MERGE_FLAG_TO_BEFORE_FROM)
      && fdesc->type != PROTOBUF_C_TYPE_MESSAGE) {
    return ok;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_MESSAGE: {

      ProtobufCMessage* f_msg = (ProtobufCMessage *)f_field;
      ProtobufCMessage* t_msg = (ProtobufCMessage *)t_field;

      if (!qf_t) {
        if (is_inline) {
          if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
            memcpy(t_msg, f_msg, fdesc->msg_desc->sizeof_message);
          } else {
            ok = protobuf_c_message_copy_usebody(instance, f_msg, t_msg);
          }
        } else {
          if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
            /* Take the pointer! */
            STRUCT_MEMBER(ProtobufCMessage*, to, fdesc->offset) = f_msg;
          } else {
            t_msg = protobuf_c_message_duplicate(instance, f_msg, fdesc->msg_desc);
            if (t_msg) {
              STRUCT_MEMBER(ProtobufCMessage*, to, fdesc->offset) = t_msg;
            } else {
              ok = FALSE;
            }
          }
        }
      } else {
        ok = merge_messages(instance, f_msg, t_msg, opts);
      }
      break;
    }
    case PROTOBUF_C_TYPE_STRING: {

      char* f_string = (char *)f_field;
      char* t_string = (char *)t_field;

      if (is_inline) {
        strcpy(t_string, f_string);
      } else {
        if (t_string != fdesc->default_value) {
          do_free(instance, t_string);
        }

        if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
          // Take away the pointer!
          STRUCT_MEMBER(char*, to, fdesc->offset) = f_string;
        } else {
          // Allocate and copy!
          t_string = (char *)do_alloc(instance, strlen(f_string)+1);
          strcpy(t_string, f_string);
          STRUCT_MEMBER(char*, to, fdesc->offset) = t_string;
        }
      }

      break;
    }
    case PROTOBUF_C_TYPE_BYTES: {

      if (is_inline) {

        ProtobufCFlatBinaryData* f_bd = (ProtobufCFlatBinaryData *)f_field;
        ProtobufCFlatBinaryData* t_bd = (ProtobufCFlatBinaryData *)t_field;

        t_bd->len = f_bd->len;
        memcpy(t_bd->data, f_bd->data, f_bd->len);

      } else {

        ProtobufCBinaryData* f_bd = (ProtobufCBinaryData *)f_field;
        ProtobufCBinaryData* t_bd = (ProtobufCBinaryData *)t_field;

        if (qf_t && t_bd->data) {
          do_free(instance, t_bd->data);
        }

        if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
          // Make away the pointer!
          t_bd->data = f_bd->data;
          t_bd->len  = f_bd->len;
          f_bd->data = NULL;
          f_bd->len = 0;
        } else {
          t_bd->data = (uint8_t *)do_alloc(instance, f_bd->len);
          memcpy(t_bd->data, f_bd->data, f_bd->len);
          t_bd->len  = f_bd->len;
        }
      }
      break;
    }
    default: {
      // Other primitive types!
      memcpy(t_field, f_field, sizeof_elt);
      break;
    }
  }

  if (ok) {
    if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
      if (fdesc->quantifier_offset) {
        STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset) = 0;
      } else {
        STRUCT_MEMBER(uint8_t*, from, fdesc->offset) = NULL;
      }
    }

    if (fdesc->quantifier_offset) {
      STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset) = qf_f;
    }
  }

  return ok;
}

static protobuf_c_boolean
merge_unknowns(ProtobufCInstance* instance,
               ProtobufCMessage* from,
               ProtobufCMessage* to,
               ProtobufCMergeOptions_t opts)
{
  protobuf_c_boolean ok = TRUE;

  if (!from->unknown_buffer) {
    return TRUE;
  }

  ProtobufCMessageUnknownFields* unk_from = from->unknown_buffer;
  ProtobufCMessageUnknownFields* unk_to = to->unknown_buffer;

  if (!unk_to && (opts.flags & MERGE_FLAG_MOVE_FIELDS)) {
    // Take the pointer!
    to->unknown_buffer = unk_from;
    from->unknown_buffer = NULL;
    return TRUE;
  }

  if (!unk_to) {
    unk_to = do_zalloc(instance, sizeof(ProtobufCMessageUnknownFields));
  }

  size_t f_len = sizeof(ProtobufCMessageUnknownField)*unk_from->n_unknown_fields;
  size_t t_len = sizeof(ProtobufCMessageUnknownField)*unk_to->n_unknown_fields;

  size_t index = 0;
  if (opts.flags & MERGE_FLAG_FROM_BEFORE_TO) {
    ProtobufCMessageUnknownField *temp = do_alloc(instance, f_len+t_len);
    if (t_len) {
      memcpy(temp+unk_from->n_unknown_fields, unk_to->unknown_fields, t_len);
      do_free(instance, unk_to->unknown_fields);
    }
    unk_to->unknown_fields = temp;
  } else {
    unk_to->unknown_fields = do_realloc(instance,
                                        unk_to->unknown_fields, f_len+t_len);
    index = unk_to->n_unknown_fields;
  }

  if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
    memcpy(unk_to->unknown_fields+index, unk_from->unknown_fields, f_len);
  } else {
    for (unsigned i = 0; i < unk_from->n_unknown_fields; i++) {
      ProtobufCMessageUnknownField *f_unkn = &unk_from->unknown_fields[i];
      ProtobufCMessageUnknownField *t_unkn = &unk_to->unknown_fields[index++];
      t_unkn->base_.tag = f_unkn->base_.tag;
      t_unkn->base_.unknown_flags = f_unkn->base_.unknown_flags;
      protobuf_c_message_clone_unknown_field(instance, f_unkn, t_unkn);
    }
  }

  to->unknown_buffer = unk_to;
  unk_to->n_unknown_fields += unk_from->n_unknown_fields;

  if (opts.flags & MERGE_FLAG_MOVE_FIELDS) {
    do_free(instance, unk_from->unknown_fields);
    do_free(instance, unk_from);
    from->unknown_buffer = NULL;
  }

  return ok;
}

/**
 * Merge earlier message into a latter message.
 *
 * For numeric types and strings, if the same value appears multiple
 * times, the parser accepts the last value it sees. For embedded
 * message fields, the parser merges multiple instances of the same
 * field. That is, all singular scalar fields in the latter instance
 * replace those in the former, singular embedded messages are merged,
 * and repeated fields are concatenated.
 *
 * The earlier message should be freed after calling this function, as
 * some of its fields may have been reused and changed to their default
 * values during the merge.
 */
static protobuf_c_boolean
merge_messages(ProtobufCInstance* instance,
               ProtobufCMessage *from,
               ProtobufCMessage *to,
               ProtobufCMergeOptions_t opts)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(from));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(to));
  PROTOBUF_C_ASSERT(from->descriptor == to->descriptor);

  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(from));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(to));

  instance = protobuf_c_instance_get(instance);
  protobuf_c_boolean ok = TRUE;

  for (unsigned i = 0; i < to->descriptor->n_fields && ok; i++) {

    const ProtobufCFieldDescriptor* fdesc = &to->descriptor->fields[i];

    switch (fdesc->label) {
      case PROTOBUF_C_LABEL_REPEATED: {

        if (fdesc->ctype) {
          ok = merge_ctype_field(instance, from, to, fdesc, opts);
          continue;
        }

        switch (fdesc->type) {
          case PROTOBUF_C_TYPE_MESSAGE: {
            if (fdesc->msg_desc->rw_flags & RW_PROTOBUF_MOPT_HAS_KEYS) {
              ok = merge_repeated_keyed_msg_field(instance, from, to, fdesc, opts);
              continue;
            }
            // else fall through!
          }
          default: {
            ok = merge_repeated_field(instance, from, to, fdesc, opts);
            break;
          }
        }
        break;
      }
      case PROTOBUF_C_LABEL_OPTIONAL: {
        // Handle one of cases.
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          uint32_t f_oneof = STRUCT_MEMBER(uint32_t, from, fdesc->quantifier_offset);
          if (!f_oneof || f_oneof != fdesc->id) {
            continue;
          }
          int32_t t_oneof = STRUCT_MEMBER(uint32_t, to, fdesc->quantifier_offset);
          if (t_oneof && !(opts.flags & MERGE_FLAG_TO_BEFORE_FROM)) {
            continue;
          }
          if (t_oneof && (t_oneof != f_oneof)) {
            const ProtobufCFieldDescriptor* t_fdesc =
                protobuf_c_message_descriptor_get_field(to->descriptor, t_oneof);
            protobuf_c_message_delete_field(instance, to, t_oneof);
          }
        }
        // Fall through
      }
      case PROTOBUF_C_LABEL_REQUIRED: {
        if (fdesc->ctype) {
          ok = merge_ctype_field(instance, from, to, fdesc, opts);
        } else {
          ok = merge_singular_field(instance, from, to, fdesc, opts);
        }
        break;
      }
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }
  }

  if (ok) {
    ok = merge_unknowns(instance, from, to, opts);
  }
  return ok;
}

static int
unpack_find_matching_repeated_msg(const ProtobufCFieldDescriptor* fdesc,
                                  ProtobufCMessage* parent,
                                  ProtobufCMessage* current,
                                  ProtobufCMessage** match)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(parent));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(current));
  PROTOBUF_C_ASSERT(fdesc);

  const ProtobufCMessageDescriptor *mdesc = (const ProtobufCMessageDescriptor *)fdesc->descriptor;
  *match = NULL;

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  int index = -1;

  if (is_inline) {
    size_t *n_msgs = STRUCT_MEMBER_PTR(size_t, parent, fdesc->quantifier_offset);
    uint8_t *msgs = STRUCT_MEMBER_PTR(uint8_t, parent, fdesc->offset);

    for (unsigned i = 0; i < *n_msgs; i++) {
      ProtobufCMessage *msg = (ProtobufCMessage *)((msgs + ( i * sizeof_elt)));
      if (protobuf_c_message_compare_keys(msg, current, mdesc)) {
        *match = msg;
        index = i;
        break;
      }
    }
  } else {
    size_t *n_msgs = STRUCT_MEMBER_PTR(size_t, parent, fdesc->quantifier_offset);
    ProtobufCMessage **msgs = STRUCT_MEMBER(ProtobufCMessage**, parent, fdesc->offset);

    for (unsigned i = 0; i < *n_msgs; i++) {
      ProtobufCMessage *msg = msgs[i];
      if (protobuf_c_message_compare_keys(msg, current, mdesc)) {
        *match = msg;
        index = i;
        break;
      }
    }
  }

  return index;
}

/**
 * Count packed elements.
 *
 * Given a raw slab of packed-repeated values, determine the number of
 * elements. This function detects certain kinds of errors but not
 * others; the remaining error checking is done by
 * parse_packed_repeated_member().
 */
static protobuf_c_boolean
count_packed_elements(ProtobufCInstance* instance,
                      ProtobufCType type,
                      size_t len,
                      const uint8_t *data,
                      size_t *count_out)
{
  switch (type) {
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      if (len % 4 != 0) {
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                 "length must be a multiple of 4 for fixed-length 32-bit types");
        return FALSE;
      }
      *count_out = len / 4;
      return TRUE;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      if (len % 8 != 0) {
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                 "length must be a multiple of 8 for fixed-length 64-bit types");
        return FALSE;
      }
      *count_out = len / 8;
      return TRUE;
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_ENUM:
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_UINT64:
      *count_out = max_b128_numbers(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_BOOL:
      *count_out = len;
      return TRUE;
    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_BYTES:
    case PROTOBUF_C_TYPE_MESSAGE:
    default:
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                               "bad protobuf-c type %u for packed-repeated", type);
      return FALSE;
  }
}

static inline uint32_t
parse_uint32(unsigned len, const uint8_t *data)
{
  uint32_t rv = data[0] & 0x7f;
  if (len > 1) {
    rv |= ((uint32_t) (data[1] & 0x7f) << 7);
    if (len > 2) {
      rv |= ((uint32_t) (data[2] & 0x7f) << 14);
      if (len > 3) {
        rv |= ((uint32_t) (data[3] & 0x7f) << 21);
        if (len > 4)
          rv |= ((uint32_t) (data[4]) << 28);
      }
    }
  }
  return rv;
}

static inline uint32_t
parse_int32(unsigned len, const uint8_t *data)
{
  return parse_uint32(len, data);
}

static inline int32_t
unzigzag32(uint32_t v)
{
  if (v & 1) {
    return -(v >> 1) - 1;
  }
  return v >> 1;
}

static inline uint32_t
parse_fixed_uint32(const uint8_t *data)
{
#if !defined(WORDS_BIGENDIAN)
  uint32_t t;
  memcpy(&t, data, 4);
  return t;
#else
  return data[0] |
    ((uint32_t) (data[1]) << 8) |
    ((uint32_t) (data[2]) << 16) |
    ((uint32_t) (data[3]) << 24);
#endif
}

static uint64_t
parse_uint64(unsigned len, const uint8_t *data)
{
  unsigned shift, i;
  uint64_t rv;

  if (len < 5) {
    return parse_uint32(len, data);
  }
  rv = ((uint64_t) (data[0] & 0x7f)) |
    ((uint64_t) (data[1] & 0x7f) << 7) |
    ((uint64_t) (data[2] & 0x7f) << 14) |
    ((uint64_t) (data[3] & 0x7f) << 21);
  shift = 28;
  for (i = 4; i < len; i++) {
    rv |= (((uint64_t) (data[i] & 0x7f)) << shift);
    shift += 7;
  }
  return rv;
}

static inline int64_t
unzigzag64(uint64_t v)
{
  if (v & 1) {
    return -(v >> 1) - 1;
  }
  return v >> 1;
}

static inline uint64_t
parse_fixed_uint64(const uint8_t *data)
{
#if !defined(WORDS_BIGENDIAN)
  uint64_t t;
  memcpy(&t, data, 8);
  return t;
#else
  return (uint64_t) parse_fixed_uint32(data) |
    (((uint64_t) parse_fixed_uint32(data + 4)) << 32);
#endif
}

static protobuf_c_boolean
parse_boolean(unsigned len, const uint8_t *data)
{
  unsigned i;
  for (i = 0; i < len; i++) {
    if (data[i] & 0x7f) {
      return TRUE;
    }
  }
  return FALSE;
}

static protobuf_c_boolean
parse_required_member(ProtobufCInstance* instance,
                      ScannedMember *scanned_member,
                      void *member,
                      protobuf_c_boolean maybe_clear)
{
  const ProtobufCFieldDescriptor *fdesc = (const ProtobufCFieldDescriptor*)scanned_member->fdesc;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  unsigned len = scanned_member->len;
  const uint8_t *data = scanned_member->data;
  ProtobufCWireType wire_type = scanned_member->wire_type;

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->unpack);
    size_t prefix_len = scanned_member->length_prefix_len;
    data += prefix_len;
    len -= prefix_len;

    if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                               "parse_required_member: !PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED");
      return 0;
    }
    if (is_inline) {
      return ctype->unpack(instance, ctype, fdesc, len, data, maybe_clear, member);
    }
    void** p = (void**)member;
    if (!maybe_clear || !*p) {
      *p = do_alloc(instance, fdesc->data_size);
      if (ctype->init_usebody) {
        (ctype->init_usebody)(ctype, fdesc, *p);
      }
      maybe_clear = FALSE;
    }
    return ctype->unpack(instance, ctype, fdesc, len, data, maybe_clear, *p);
  }

  switch (scanned_member->fdesc->type) {
    case PROTOBUF_C_TYPE_INT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(uint32_t *) member = parse_int32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_UINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(uint32_t *) member = parse_uint32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_SINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(int32_t *) member = unzigzag32(parse_uint32(len, data));
      return TRUE;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT) {
        return FALSE;
      }
      *(uint32_t *) member = parse_fixed_uint32(data);
      return TRUE;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(uint64_t *) member = parse_uint64(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_SINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(int64_t *) member = unzigzag64(parse_uint64(len, data));
      return TRUE;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT) {
        return FALSE;
      }
      *(uint64_t *) member = parse_fixed_uint64(data);
      return TRUE;
    case PROTOBUF_C_TYPE_BOOL:
      *(protobuf_c_boolean *) member = parse_boolean(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_ENUM:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      *(uint32_t *) member = parse_uint32(len, data);
      return TRUE;
    case PROTOBUF_C_TYPE_STRING: {
      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
        return FALSE;
      }
      data += scanned_member->length_prefix_len;
      len -= scanned_member->length_prefix_len;

      if (is_inline) {
        char *pstr = member;
        size_t buflen = fdesc->data_size;
        if (len > (buflen-1)) {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                   "length-prefixed data too long for inline string field");
          /* ATTN: Put in unknown fields? */
          return FALSE;
        }
        memcpy(pstr, data, len);
        /* null-terminate the string, also clear the rest of the
           buffer so as to be tidy */
        memset(pstr+len, 0, buflen-len);
        return TRUE;
      }

      char **pstr = member;
      if (   maybe_clear
          && *pstr != NULL
          && *pstr != fdesc->default_value) {
        do_free(instance, *pstr);
        *pstr = NULL;
      }

      *pstr = do_alloc(instance, len + 1);
      if (*pstr == NULL) {
        return FALSE;
      }
      memcpy(*pstr, data, len);
      (*pstr)[len] = 0;
      return TRUE;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
        return FALSE;
      }
      data += scanned_member->length_prefix_len;
      len -= scanned_member->length_prefix_len;

      if (is_inline) {
        ProtobufCFlatBinaryData *bd = member;
        size_t buflen = fdesc->data_size - sizeof(ProtobufCFlatBinaryData);
        if (len > buflen) {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                   "length-prefixed data too long for inline bytes field");
          /* ATTN: Put in unknown fields? */
          return FALSE;
        }
        memcpy(bd->data, data, len);
        bd->len = len;
        return TRUE;
      }

      const ProtobufCBinaryData *default_bd
          = (const ProtobufCBinaryData *)fdesc->default_value;
      ProtobufCBinaryData *bd = member;
      if (   maybe_clear
          && bd->data != NULL
          && !(default_bd && bd->data == default_bd->data)) {
        do_free(instance, bd->data);
      }
      bd->data = NULL;

      bd->data = do_alloc(instance, len);
      if (bd->data == NULL) {
        return FALSE;
      }
      memcpy(bd->data, data, len);
      bd->len = len;
      return TRUE;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
        return FALSE;
      }
      data += scanned_member->length_prefix_len;
      len -= scanned_member->length_prefix_len;

      /*
       * A bit of optimization can be done here. If maybe_clear is false
       * and the field is inline, the message can be unpacked directly into
       * the inline field. A memcpy can be avoided.
       */
      ProtobufCMessage *subm
        = protobuf_c_message_unpack(instance, fdesc->descriptor, len, data);
      if (subm == NULL) {
        return FALSE;
      }

      ProtobufCMessage **pmessage = member;
      ProtobufCMessage *inlineptr = member;
      if (is_inline) {
        pmessage = &inlineptr;
      }

      protobuf_c_boolean merge_successful = 1;
      if (   maybe_clear
          && *pmessage != NULL
          && *pmessage != fdesc->default_value) {
        merge_successful = merge_messages(instance, *pmessage, subm, default_unpack);
        if (!is_inline) {
          /* Delete the previous message */
          protobuf_c_message_free_unpacked(instance, *pmessage);
        }
      }
      if (is_inline) {
        /* The member is an inline message (embedded inside its parent) but
         * subm is a outer message. So dont override the header of member */
        protobuf_c_message_memcpy(member, subm);
        /* all the pointers are kept by member, so just free subm */
        do_free(instance, subm);
      } else {
        *pmessage = subm;
      }
      if (!merge_successful) {
        return FALSE;
      }
      return TRUE;
    }
  }
  return FALSE;
}

static protobuf_c_boolean
parse_oneof_member (ProtobufCInstance* instance,
                    ScannedMember *scanned_member,
                    void *member,
                    ProtobufCMessage *message)
{
  uint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,
                                           scanned_member->fdesc->quantifier_offset);

  protobuf_c_boolean is_inline = !!(scanned_member->fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  /* If we have already parsed a member of this oneof, free it. */
  if (*oneof_case != 0) {
    /* lookup field */
    int field_index =
        int_range_lookup(message->descriptor->n_field_ranges,
                         message->descriptor->field_ranges,
                         *oneof_case);
    const ProtobufCFieldDescriptor *old_field =
        message->descriptor->fields + field_index;
    switch (old_field->type) {
      case PROTOBUF_C_TYPE_STRING: {
        if (!is_inline) {
          char **pstr = member;
          const char *def = old_field->default_value;
          if (*pstr != NULL && *pstr != def) {
            do_free(instance, *pstr);
          }
        }
        break;
      }
      case PROTOBUF_C_TYPE_BYTES: {
        if (!is_inline) {
          ProtobufCBinaryData *bd = member;
          const ProtobufCBinaryData *def_bd = old_field->default_value;
          if (bd->data != NULL &&
              (def_bd == NULL || bd->data != def_bd->data)) {
            do_free(instance, bd->data);
          }
        }
        break;
      }
      case PROTOBUF_C_TYPE_MESSAGE: {
        if (!is_inline) {
          ProtobufCMessage **pmessage = member;
          const ProtobufCMessage *def_mess = old_field->default_value;
          if (*pmessage != NULL && *pmessage != def_mess) {
            protobuf_c_message_free_unpacked(instance, *pmessage);
          }
        }
        break;
      }
      default:
        break;
    }

    size_t el_size = sizeof_elt_in_repeated_array(old_field);
    memset (member, 0, el_size);
  }
  if (!parse_required_member (instance, scanned_member, member, TRUE)) {
    return FALSE;
  }

  *oneof_case = scanned_member->tag;
  return TRUE;
}

static protobuf_c_boolean
parse_optional_member(ProtobufCInstance* instance,
                      ScannedMember *scanned_member,
                      void *member,
                      ProtobufCMessage *message)
{
  if (!parse_required_member(instance, scanned_member, member, TRUE)) {
    return FALSE;
  }
  if (scanned_member->fdesc->quantifier_offset != 0) {
    STRUCT_MEMBER(protobuf_c_boolean,
                  message,
                  scanned_member->fdesc->quantifier_offset) = TRUE;
  }
  return TRUE;
}

static protobuf_c_boolean
parse_repeated_member(ProtobufCInstance* instance,
                      ScannedMember *scanned_member,
                      void *member,
                      ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor* fdesc = scanned_member->fdesc;
  size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, fdesc->quantifier_offset);
  size_t curr_index = *p_n;
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  void* side_element = NULL;
  char side_buf[4096];
  bool do_merge = !!!(fdesc->rw_flags & RW_PROTOBUF_FOPT_MERGE_BEHAVIOR);

  if (   fdesc->rw_inline_max
      && curr_index >= fdesc->rw_inline_max) {
    if (!do_merge) {
        return FALSE;
    }
    /* ATTN: Non-message not supported yet */
    if (fdesc->type == PROTOBUF_C_TYPE_MESSAGE) {
      size_t side_size = sizeof_elt_in_repeated_array(fdesc);
      if (side_size > sizeof(side_buf)) {
        side_element = do_alloc(instance, side_size);
      } else {
        side_element = &side_buf[0];
      }
      protobuf_c_message_init(fdesc->msg_desc, (ProtobufCMessage *)side_element);
    }
    if (!side_element) {
      PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                               "inline_max reached %u", fdesc->rw_inline_max);
      return FALSE;
    }

  }

  char *array;
  if (is_inline) {
    array = (char*)member;
  } else {
    array = *(char **)member;
  }
  void *element = array + sizeof_elt * curr_index;
  if (side_element) {
    element = side_element;
  }

  protobuf_c_boolean unpacked = FALSE;
  protobuf_c_boolean ok = FALSE;
  protobuf_c_boolean merged = FALSE;
  if (!parse_required_member(instance, scanned_member, element, FALSE)) {
    goto error;
  }
  unpacked = TRUE;

  if (   fdesc->type == PROTOBUF_C_TYPE_MESSAGE
      && fdesc->msg_desc->rw_flags & RW_PROTOBUF_MOPT_HAS_KEYS) {
    ProtobufCMessage *earlier = NULL, *latter = NULL;
    int index = -1;

    if (is_inline) {
      latter = (ProtobufCMessage *)element;
    } else {
      latter = *(ProtobufCMessage **)element;
    }

    // ATTN: This condition is evaluated to True, if the yang definition
    // has field_merge_behavior set to "none". In which case
    // we wont be trying to find the duplicate messages.
    // See JIRA RIFT-6976 for more details.
    if (do_merge) {
        index = unpack_find_matching_repeated_msg(fdesc, message, latter, &earlier);
    }

    if (NULL != earlier) {
      // There exists a message with same key. Merge the new message with the
      // earlier.
      PROTOBUF_C_ASSERT((index != -1) && (index < curr_index));
      merged = merge_messages(instance, earlier, latter, default_unpack);
      if (!merged) {
        goto error;
      }

      /* Replace the earlier with latter. Free the earlier if not inline.
       * Note: Here we are not reallocting the array. The array is
       * pre-allocated to the number of repeated elements parsed. If there
       * are any merges, the final number of elements in the array will be less
       * than the size of the array. This is ok.
       */
      if (side_element) {
        // Use the protobuf_c_message_memcpy here! side_element is a local variable
        ProtobufCMessage* dest = (ProtobufCMessage *)(array + (sizeof_elt * index));
        protobuf_c_message_memcpy(dest, (ProtobufCMessage *)side_element);
        unpacked = FALSE;
      } else {
        // Ok to call memcpy here!
        memcpy(array + (sizeof_elt * index), array + (sizeof_elt * curr_index), sizeof_elt);
        if (!is_inline) {
          protobuf_c_message_free_unpacked(instance, earlier);
        }
      }
    }
  }
  ok = TRUE;

error:
  /*
   * Success may still be failure.  If the field was unpacked
   * into the side buffer, but it could/was not merged back into
   * the message, then unpack failed.
   */
  if (ok && unpacked && !merged && side_element) {
    PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                             "inline_max reached %u", fdesc->rw_inline_max);
    ok = FALSE;
  }

  /* The repeated count may have increased, even on failure */
  if (unpacked && !merged && !side_element) {
    ++*p_n;
  }

  /* The side buffer may contain a message that needs to be freed */
  if (!ok && unpacked && side_element) {
    protobuf_c_message_free_unpacked_usebody(instance, side_element);
  }

  /* The side buffer must be freed */
  if (side_element && side_element != &side_buf[0]) {
    do_free(instance, side_element);
  }

  return ok;
}

static unsigned
scan_varint(unsigned len, const uint8_t *data)
{
  unsigned i;
  if (len > 10) {
    len = 10;
  }
  for (i = 0; i < len; i++) {
    if ((data[i] & 0x80) == 0) {
      break;
    }
  }
  if (i == len) {
    return 0;
  }
  return i + 1;
}

static protobuf_c_boolean
parse_packed_repeated_member(ProtobufCInstance* instance,
                             ScannedMember *scanned_member,
                             void *member,
                             ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor* fdesc = scanned_member->fdesc;
  size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, fdesc->quantifier_offset);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

  char *array;
  if (fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE) {
    array = (char *) member + sizeof_elt * (*p_n);
  } else {
    array = *(char **) member + sizeof_elt * (*p_n);
  }

  const uint8_t *at = scanned_member->data + scanned_member->length_prefix_len;
  size_t rem = scanned_member->len - scanned_member->length_prefix_len;
  size_t count = 0;
  unsigned i;

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      count = (scanned_member->len - scanned_member->length_prefix_len) / 4;
#if !defined(WORDS_BIGENDIAN)
      goto no_unpacking_needed;
#else
      for (i = 0; i < count; i++) {
        ((uint32_t *) array)[i] = parse_fixed_uint32(at);
        at += 4;
      }
#endif
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      count = (scanned_member->len - scanned_member->length_prefix_len) / 8;
#if !defined(WORDS_BIGENDIAN)
      goto no_unpacking_needed;
#else
      for (i = 0; i < count; i++) {
        ((uint64_t *) array)[i] = parse_fixed_uint64(at);
        at += 8;
      }
      break;
#endif
    case PROTOBUF_C_TYPE_INT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated int32 value");
          return FALSE;
        }
        ((int32_t *) array)[count++] = parse_int32(s, at);
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_SINT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated sint32 value");
          return FALSE;
        }
        ((int32_t *) array)[count++] = unzigzag32(parse_uint32(s, at));
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_ENUM:
    case PROTOBUF_C_TYPE_UINT32:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated enum or uint32 value");
          return FALSE;
        }
        ((uint32_t *) array)[count++] = parse_uint32(s, at);
        at += s;
        rem -= s;
      }
      break;

    case PROTOBUF_C_TYPE_SINT64:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated sint64 value");
          return FALSE;
        }
        ((int64_t *) array)[count++] = unzigzag64(parse_uint64(s, at));
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      while (rem > 0) {
        unsigned s = scan_varint(rem, at);
        if (s == 0) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated int64/uint64 value");
          return FALSE;
        }
        ((int64_t *) array)[count++] = parse_uint64(s, at);
        at += s;
        rem -= s;
      }
      break;
    case PROTOBUF_C_TYPE_BOOL:
      count = rem;
      for (i = 0; i < count; i++) {
        if (at[i] > 1) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "bad packed-repeated boolean value");
          return FALSE;
        }
        ((protobuf_c_boolean *) array)[i] = at[i];
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  *p_n += count;
  return TRUE;

#if !defined(WORDS_BIGENDIAN)
no_unpacking_needed:
  memcpy(array, at, count * sizeof_elt);
  *p_n += count;
  return TRUE;
#endif
}

static protobuf_c_boolean
is_packable_type(ProtobufCType type)
{
  return
    type != PROTOBUF_C_TYPE_STRING &&
    type != PROTOBUF_C_TYPE_BYTES &&
    type != PROTOBUF_C_TYPE_MESSAGE;
}

static protobuf_c_boolean
parse_member(ProtobufCInstance* instance,
             ScannedMember *scanned_member,
             ProtobufCMessage *message)
{
  const ProtobufCFieldDescriptor* fdesc = scanned_member->fdesc;
  void *member;

  if (fdesc == NULL) {
    ProtobufCMessageUnknownFields *unk_buf = message->unknown_buffer;
    PROTOBUF_C_ASSERT(unk_buf && unk_buf->unknown_fields); // Not required, a redundant assert. But its ok.
    ProtobufCMessageUnknownField *unkn = unk_buf->unknown_fields + (unk_buf->n_unknown_fields++);

    unkn->base_.tag = scanned_member->tag;

    unkn->serialized.wire_type = scanned_member->wire_type;
    unkn->serialized.data = do_alloc(instance, scanned_member->len);
    if (unkn->serialized.data == NULL) {
      return FALSE;
    }
    unkn->serialized.len = scanned_member->len;

    memcpy(unkn->serialized.data, scanned_member->data,
           unkn->serialized.len);
    PROTOBUF_C_FLAG_SET(unkn->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                        PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED);

    return TRUE;
  }
  member = (char *) message + fdesc->offset;
  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REQUIRED:
      return parse_required_member(instance, scanned_member, member, TRUE);
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
        return parse_oneof_member(instance, scanned_member, member, message);
      }
      return parse_optional_member(instance, scanned_member, member, message);
    case PROTOBUF_C_LABEL_REPEATED:
      if (scanned_member->wire_type ==
          PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
          (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
           is_packable_type(fdesc->type)))
      {
        return parse_packed_repeated_member(instance, scanned_member, member, message);
      }
      return parse_repeated_member(instance, scanned_member, member, message);
  }
  PROTOBUF_C_ASSERT_NOT_REACHED();
  return 0;
}

void
protobuf_c_message_create_init_value(ProtobufCInstance* instance,
                                     ProtobufCMessageDescriptor* mdesc)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(mdesc));
  instance = protobuf_c_instance_get(instance);

  // Create the init_value message.
  ProtobufCMessage* init_value = (ProtobufCMessage *)do_alloc(instance, mdesc->sizeof_message);
  memset(init_value, 0, mdesc->sizeof_message);

  init_value->descriptor = mdesc;
  protobuf_c_ref_header_create(&init_value->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_OWNED, 0); // ATTN:- Global?

  for (unsigned i = 0; i < mdesc->n_fields; i++) {

    const ProtobufCFieldDescriptor* fdesc = &mdesc->fields[i];
    PROTOBUF_C_ASSERT(fdesc);
    void *field = STRUCT_MEMBER_P(init_value, fdesc->offset);
    bool is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
    size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

    if (fdesc->default_value != NULL) {

      PROTOBUF_C_ASSERT(fdesc->label != PROTOBUF_C_LABEL_REPEATED);
      PROTOBUF_C_ASSERT(fdesc->type != PROTOBUF_C_TYPE_MESSAGE); // protoc-c doesn't support default for messages
      const void *dv = fdesc->default_value;

      switch (fdesc->type) {
        case PROTOBUF_C_TYPE_BYTES:
          if (!is_inline) {
            *((ProtobufCBinaryData *)field) =  *((ProtobufCBinaryData *)dv);
          } else {
            ProtobufCFlatBinaryData *bd = (ProtobufCFlatBinaryData *)field;
            ProtobufCFlatBinaryData *default_bd = (ProtobufCFlatBinaryData *)dv;
            size_t buflen = fdesc->data_size - sizeof(ProtobufCFlatBinaryData);
            PROTOBUF_C_ASSERT(buflen >= default_bd->len);
            memcpy(bd->data, default_bd->data, default_bd->len);
            bd->len = default_bd->len;
          }
          break;
        case PROTOBUF_C_TYPE_STRING: {
          if (!is_inline) {
            *(const void **) field = dv;
            break;
          }
          // else fall through
        }
        default:
          memcpy(field, dv, sizeof_elt);
          break;
      }
      continue;
    }

    if (fdesc->type == PROTOBUF_C_TYPE_MESSAGE) {
      PROTOBUF_C_ASSERT(fdesc->msg_desc);

      if (is_inline) {
        if (fdesc->label != PROTOBUF_C_LABEL_REPEATED) {
          protobuf_c_message_init_inner(init_value, (ProtobufCMessage *)field, fdesc);
        } else {
          for (unsigned c = 0; c < fdesc->rw_inline_max; c++) {
            ProtobufCMessage *child = (ProtobufCMessage *)((uint8_t *)field + (c * sizeof_elt));
            protobuf_c_message_init_inner(init_value, child, fdesc);
          }
        }
      }
    }
  }

  mdesc->init_value = init_value;
}

/**
 * Initialise messages generated by old code.
 *
 * This function is used if desc->message_init == NULL (which occurs
 * for old code, and which would be useful to support allocating
 * descriptors dynamically).
 */
static void
protobuf_c_message_init_generic(const ProtobufCMessageDescriptor *mdesc,
                                ProtobufCMessage *message)
{
  // RIFT unsupported, might need for broker etc
  abort();

  unsigned i;

  memset(message, 0, mdesc->sizeof_message);
  message->descriptor = mdesc;
  for (i = 0; i < mdesc->n_fields; i++) {
    if (mdesc->fields[i].default_value != NULL &&
        mdesc->fields[i].label != PROTOBUF_C_LABEL_REPEATED)
    {
      void *field =
        STRUCT_MEMBER_P(message, mdesc->fields[i].offset);
      const void *dv = mdesc->fields[i].default_value;

      switch (mdesc->fields[i].type) {
        case PROTOBUF_C_TYPE_INT32:
        case PROTOBUF_C_TYPE_SINT32:
        case PROTOBUF_C_TYPE_SFIXED32:
        case PROTOBUF_C_TYPE_UINT32:
        case PROTOBUF_C_TYPE_FIXED32:
        case PROTOBUF_C_TYPE_FLOAT:
        case PROTOBUF_C_TYPE_ENUM:
          memcpy(field, dv, 4);
          break;
        case PROTOBUF_C_TYPE_INT64:
        case PROTOBUF_C_TYPE_SINT64:
        case PROTOBUF_C_TYPE_SFIXED64:
        case PROTOBUF_C_TYPE_UINT64:
        case PROTOBUF_C_TYPE_FIXED64:
        case PROTOBUF_C_TYPE_DOUBLE:
          memcpy(field, dv, 8);
          break;
        case PROTOBUF_C_TYPE_BOOL:
          memcpy(field, dv, sizeof(protobuf_c_boolean));
          break;
        case PROTOBUF_C_TYPE_BYTES:
          memcpy(field, dv, sizeof(ProtobufCBinaryData));
          break;

        case PROTOBUF_C_TYPE_STRING:
        case PROTOBUF_C_TYPE_MESSAGE:
          /*
           * The next line essentially implements a cast
           * from const, which is totally unavoidable.
           */

          /*  ATTN:RIFT INLINE FIXME TBD XXX */
          *(const void **) field = dv;
          break;
      }
    }
  }
}

static protobuf_c_boolean
protobuf_c_message_clone_unknown_field(ProtobufCInstance *instance,
                                       const ProtobufCMessageUnknownField *source_fld,
                                       ProtobufCMessageUnknownField *target_fld)
{
  PROTOBUF_C_ASSERT(source_fld);
  PROTOBUF_C_ASSERT(target_fld);
  instance = protobuf_c_instance_get(instance);

  switch(PROTOBUF_C_FLAG_GET(source_fld->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    ProtobufCUnknownSerialized *user = &target_fld->serialized;

    user->wire_type = source_fld->serialized.wire_type;
    user->data = do_alloc(instance, source_fld->serialized.len);
    if (!user->data) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
           "Clone unknown field failed: No memory.");
      return FALSE;
    }

    user->len = source_fld->serialized.len;
    memcpy(user->data, source_fld->serialized.data, user->len);
    target_fld->base_.tag = source_fld->base_.tag;

    PROTOBUF_C_FLAG_SET(target_fld->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                        PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED);
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    ProtobufCUnknownMessageCast *umcast = &target_fld->cmessage;

    ProtobufCMessage *message = protobuf_c_message_duplicate(instance,
                                source_fld->cmessage.message,
                                source_fld->cmessage.fdesc->descriptor);
    if (message == NULL) {
      return FALSE;
    }
    umcast->fdesc = source_fld->cmessage.fdesc;
    umcast->message = message;
    target_fld->base_.tag = source_fld->base_.tag;

    PROTOBUF_C_FLAG_SET(target_fld->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                        PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST);
  }
  break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

  return TRUE;
}

const ProtobufCMessage*
protobuf_c_unknown_field_cast_message(ProtobufCInstance *instance,
                                      ProtobufCMessageUnknownField *uf,
                                      const ProtobufCFieldDescriptor *fdesc)
{
  PROTOBUF_C_ASSERT(uf);
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(fdesc->type == PROTOBUF_C_TYPE_MESSAGE);

  ProtobufCMessage *message = NULL;
  instance = protobuf_c_instance_get(instance);

  switch(PROTOBUF_C_FLAG_GET(uf->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    const ProtobufCUnknownSerialized *user = &uf->serialized;

    if (user->wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
      break;
    }
    size_t rv = uint32_size(user->len);
    message = protobuf_c_message_unpack(instance, fdesc->descriptor,
                                        user->len - rv,
                                        user->data + rv);
    if (message == NULL) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
           "Message Cast. Unpack failed.");
      break;
    }
    do_free(instance, user->data);

    uf->cmessage.fdesc = fdesc;
    uf->cmessage.message = message;

    PROTOBUF_C_FLAG_SET(uf->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                        PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST);
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    ProtobufCUnknownMessageCast* msgcast = &uf->cmessage;

    if (msgcast->fdesc == fdesc) {
      message = msgcast->message;
    } else {
      message = protobuf_c_message_duplicate(instance,
                             msgcast->message, fdesc->descriptor);

      if (message == NULL) {
        break;
      }
      protobuf_c_message_free_unpacked(instance, uf->cmessage.message);

      uf->cmessage.fdesc = fdesc;
      uf->cmessage.message = message;
    }
  }
    break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

  return message;

}


const ProtobufCUnknownSerialized*
protobuf_c_unknown_field_cast_serialized(ProtobufCInstance *instance,
                                         ProtobufCMessageUnknownField *uf)
{
  PROTOBUF_C_ASSERT(uf);

  instance = protobuf_c_instance_get(instance);

  switch(PROTOBUF_C_FLAG_GET(uf->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
  {
    return &uf->serialized;
  }
  break;
  case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
  {
    size_t len = protobuf_c_message_get_packed_size(instance, uf->cmessage.message);
    size_t rv = uint32_size(len);

    uint8_t *buf = do_alloc(instance, len + rv);
    if (buf == NULL) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
          "Cast to serialized failed. No memory.");
      return NULL;
    }
    uint32_pack(len, buf);
    size_t packed_size = protobuf_c_message_pack(instance, uf->cmessage.message, buf + rv);
    PROTOBUF_C_ASSERT(packed_size == len);

    protobuf_c_message_free_unpacked(instance, uf->cmessage.message);

    uf->serialized.data = buf;
    uf->serialized.len  = packed_size + rv;
    uf->serialized.wire_type = PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;

    PROTOBUF_C_FLAG_SET(uf->base_.unknown_flags, UNKNOWN_UNION_TYPE,
                        PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED);

    return &uf->serialized;
  }
  break;
  default:
    PROTOBUF_C_ASSERT_NOT_REACHED();
  };

  return NULL;
}

/**@}*/

/*
 * ScannedMember slabs (an unpacking implementation detail). Before doing real
 * unpacking, we first scan through the elements to see how many there are (for
 * repeated fields), and which field to use (for non-repeated fields given
 * twice).
 *
 * In order to avoid allocations for small messages, we keep a stack-allocated
 * slab of ScannedMembers of size FIRST_SCANNED_MEMBER_SLAB_SIZE (16). After we
 * fill that up, we allocate each slab twice as large as the previous one.
 */
#define FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2 4

/*
 * The number of slabs, including the stack-allocated ones; choose the number so
 * that we would overflow if we needed a slab larger than provided.
 */
#define MAX_SCANNED_MEMBER_SLAB \
( \
  sizeof(unsigned int)*8 - 1 \
   - BOUND_SIZEOF_SCANNED_MEMBER_LOG2 \
   - FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2 \
)

#define REQUIRED_FIELD_BITMAP_SET(index) \
  (required_fields_bitmap[(index)/8] |= (1<<((index)%8)))

#define REQUIRED_FIELD_BITMAP_IS_SET(index) \
  (required_fields_bitmap[(index)/8] & (1<<((index)%8)))

ProtobufCMessage *
protobuf_c_message_unpack(ProtobufCInstance* instance,
                          const ProtobufCMessageDescriptor *mdesc,
                          size_t len,
                          const uint8_t *data)
{
  return protobuf_c_message_unpack_usebody(instance, mdesc, len, data, NULL);
}

ProtobufCMessage *
protobuf_c_message_unpack_usebody(ProtobufCInstance* instance,
                                  const ProtobufCMessageDescriptor *mdesc,
                                  size_t len,
                                  const uint8_t *data,
                                  ProtobufCMessage *herebody)
{
  ProtobufCMessage *rv;
  size_t rem = len;
  const uint8_t *at = data;
  const ProtobufCFieldDescriptor *last_fdesc = mdesc->fields + 0;
  ScannedMember first_member_slab[1 << FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2];

  /*
   * scanned_member_slabs[i] is an array of arrays of ScannedMember.
   * The first slab (scanned_member_slabs[0] is just a pointer to
   * first_member_slab), above. All subsequent slabs will be allocated
   * using the allocator.
   */
  ScannedMember *scanned_member_slabs[MAX_SCANNED_MEMBER_SLAB + 1];
  unsigned which_slab = 0; /* the slab we are currently populating */
  unsigned in_slab_index = 0; /* number of members in the slab */
  size_t n_unknown = 0;
  unsigned f;
  unsigned j;
  unsigned i_slab;
  unsigned last_fdesc_index = 0;
  unsigned required_fields_bitmap_len;
  unsigned char required_fields_bitmap_stack[16];
  unsigned char *required_fields_bitmap = required_fields_bitmap_stack;
  protobuf_c_boolean required_fields_bitmap_alloced = FALSE;

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(mdesc));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, unpack);

  if (herebody) {
    rv = herebody;
    // Message must be already initialized by the caller!
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(rv));
  } else {
    rv = do_alloc(instance, mdesc->sizeof_message);
  }
  if (!rv)
    return (NULL);
  scanned_member_slabs[0] = first_member_slab;

  required_fields_bitmap_len = (mdesc->n_fields + 7) / 8;
  if (required_fields_bitmap_len > sizeof(required_fields_bitmap_stack)) {
    required_fields_bitmap = do_alloc(instance, required_fields_bitmap_len);
    if (!required_fields_bitmap) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                              "unpack usebody: No memory");
      do_free(instance, rv);
      return (NULL);
    }
    required_fields_bitmap_alloced = TRUE;
  }
  memset(required_fields_bitmap, 0, required_fields_bitmap_len);

  /*
   * Generated code always defines "message_init". However, we provide a
   * fallback for (1) users of old protobuf-c generated-code that do not
   * provide the function, and (2) descriptors constructed from some other
   * source (most likely, direct construction from the .proto file).
   */
  if (!herebody) {
    if (mdesc->init_value != NULL) {
      protobuf_c_message_init(mdesc, rv);
    } else {
      protobuf_c_message_init_generic(mdesc, rv);
    }
  }

  while (rem > 0) {
    uint32_t tag;
    ProtobufCWireType wire_type;
    size_t used = parse_tag_and_wiretype(rem, at, &tag, &wire_type);
    const ProtobufCFieldDescriptor* fdesc;
    ScannedMember tmp;

    if (used == 0) {
      PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                               "error parsing tag/wiretype at offset %u",
                               (unsigned) (at - data));
      goto error_cleanup_during_scan;
    }
    /*
         * \todo Consider optimizing for fdesc[1].id == tag, if fdesc[1]
         * exists!
         */
    if (last_fdesc == NULL || last_fdesc->id != tag) {
      /* lookup field */
      int field_index =
          int_range_lookup(mdesc->n_field_ranges,
               mdesc->field_ranges,
               tag);
      if (field_index < 0) {
        fdesc = NULL;
        n_unknown++;
      } else {
        fdesc = mdesc->fields + field_index;
        last_fdesc = fdesc;
        last_fdesc_index = field_index;
      }
    } else {
      fdesc = last_fdesc;
    }

    if (fdesc != NULL && fdesc->label == PROTOBUF_C_LABEL_REQUIRED)
      REQUIRED_FIELD_BITMAP_SET(last_fdesc_index);

    at += used;
    rem -= used;
    tmp.tag = tag;
    tmp.wire_type = wire_type;
    tmp.fdesc = fdesc;
    tmp.data = at;
    tmp.length_prefix_len = 0;

    switch (wire_type) {
      case PROTOBUF_C_WIRE_TYPE_VARINT: {
        unsigned max_len = rem < 10 ? rem : 10;
        unsigned i;

        for (i = 0; i < max_len; i++) {
          if ((at[i] & 0x80) == 0) {
            break;
          }
        }
        if (i == max_len) {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                   "unterminated varint at offset %u",
                                   (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = i + 1;
        break;
      }
      case PROTOBUF_C_WIRE_TYPE_64BIT:
        if (rem < 8) {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                   "too short after 64bit wiretype at offset %u",
                                   (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = 8;
        break;
      case PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED: {
        size_t pref_len;

        tmp.len = scan_length_prefixed_data(instance, rem, at, &pref_len);
        if (tmp.len == 0) {
          /* NOTE: scan_length_prefixed_data calls UNPACK_ERROR */
          goto error_cleanup_during_scan;
        }
        tmp.length_prefix_len = pref_len;
        break;
      }
      case PROTOBUF_C_WIRE_TYPE_32BIT:
        if (rem < 4) {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                   "too short after 32bit wiretype at offset %u",
                                   (unsigned) (at - data));
          goto error_cleanup_during_scan;
        }
        tmp.len = 4;
        break;
      default:
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                 "unsupported tag %u at offset %u",
                                 wire_type, (unsigned) (at - data));
        goto error_cleanup_during_scan;
    }

    if (in_slab_index == (1U <<
      (which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)))
    {
      size_t size;

      in_slab_index = 0;
      if (which_slab == MAX_SCANNED_MEMBER_SLAB) {
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                 "too many fields");
        goto error_cleanup_during_scan;
      }
      which_slab++;
      size = sizeof(ScannedMember) << (which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2);
      scanned_member_slabs[which_slab] = do_alloc(instance, size);
      if (scanned_member_slabs[which_slab] == NULL)
        goto error_cleanup_during_scan;
    }
    scanned_member_slabs[which_slab][in_slab_index++] = tmp;

    if (fdesc != NULL && fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
      size_t *n = STRUCT_MEMBER_PTR(size_t, rv, fdesc->quantifier_offset);
      if (wire_type == PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
          (0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
           is_packable_type(fdesc->type)))
      {
        size_t count;
        if (!count_packed_elements(instance, fdesc->type,
               tmp.len - tmp.length_prefix_len,
               tmp.data +tmp.length_prefix_len,
               &count))
        {
          PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                   "counting packed elements");
          goto error_cleanup_during_scan;
        }
        *n += count;
      } else {
        *n += 1;
      }
    }

    at += tmp.len;
    rem -= tmp.len;
  }

  /* allocate space for repeated fields, also check that all required fields have been set */
  for (f = 0; f < mdesc->n_fields; f++) {
    const ProtobufCFieldDescriptor* fdesc = mdesc->fields + f;
    if (fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
      size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
      size_t *n_ptr = STRUCT_MEMBER_PTR(size_t, rv, fdesc->quantifier_offset);
      if (*n_ptr != 0) {
        unsigned n = *n_ptr;
        *n_ptr = 0;
        PROTOBUF_C_ASSERT(rv->descriptor != NULL);

#define CLEAR_REMAINING_N_PTRS()                                              \
              for(f++;f < mdesc->n_fields; f++)                               \
                {                                                             \
                  fdesc = mdesc->fields + f;                                  \
                  if (fdesc->label == PROTOBUF_C_LABEL_REPEATED)              \
                    STRUCT_MEMBER (size_t, rv, fdesc->quantifier_offset) = 0; \
                }

        if (!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE)) {
          void *a = do_alloc(instance, sizeof_elt * n);
          if (!a) {
            CLEAR_REMAINING_N_PTRS();
            goto error_cleanup;
          }
          STRUCT_MEMBER(void *, rv, fdesc->offset) = a;
        }
      }
    } else if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
      if (fdesc->default_value == NULL &&
          !REQUIRED_FIELD_BITMAP_IS_SET(f)) {
        CLEAR_REMAINING_N_PTRS();
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, fdesc,
                                 "message '%s': missing required field '%s'",
                                 mdesc->name, fdesc->name);
        goto error_cleanup;
      }
    }
  }
#undef CLEAR_REMAINING_N_PTRS

  /* allocate space for unknown fields */
  if (n_unknown) {
    rv->unknown_buffer = do_zalloc(instance, sizeof(ProtobufCMessageUnknownFields));
    if (!rv->unknown_buffer) {
      goto error_cleanup;
    }
    rv->unknown_buffer->unknown_fields = do_alloc(instance,
                                                  n_unknown * sizeof(ProtobufCMessageUnknownField));
    if (rv->unknown_buffer->unknown_fields == NULL)
      goto error_cleanup;
  }

  /* do real parsing */
  for (i_slab = 0; i_slab <= which_slab; i_slab++) {
    unsigned max = (i_slab == which_slab) ?  in_slab_index : (1U << (i_slab + 4));
    ScannedMember *slab = scanned_member_slabs[i_slab];
    unsigned j;

    for (j = 0; j < max; j++) {
      if (!parse_member(instance, slab + j, rv)) {
        PROTOBUF_C_MESSAGE_ERROR(instance, NULL, NULL,
                                 "error parsing member %s of %s",
                                 slab->fdesc ? slab->fdesc->name : "*unknown-field*",
                                 mdesc->name);
        goto error_cleanup;
      }
    }
  }

  /* cleanup */
  for (j = 1; j <= which_slab; j++) {
    do_free(instance, scanned_member_slabs[j]);
  }
  if (required_fields_bitmap_alloced) {
    do_free(instance, required_fields_bitmap);
  }
  return rv;

error_cleanup:
  if (rv != herebody) {
    protobuf_c_message_free_unpacked(instance, rv);
  }
  for (j = 1; j <= which_slab; j++) {
    do_free(instance, scanned_member_slabs[j]);
  }
  if (required_fields_bitmap_alloced) {
    do_free(instance, required_fields_bitmap);
  }
  return NULL;

error_cleanup_during_scan:
  if (rv != herebody) {
    do_free(instance, rv);
  }
  for (j = 1; j <= which_slab; j++) {
    do_free(instance, scanned_member_slabs[j]);
  }
  if (required_fields_bitmap_alloced) {
    do_free(instance, required_fields_bitmap);
  }
  return NULL;
}

/* === protobuf_c_message_free_unpacked() implementation === */

static void
protobuf_c_message_free_unknown_all(ProtobufCInstance* instance,
                                    ProtobufCMessage *message)
{
  uint32_t union_type  =
      PROTOBUF_C_FLAG_GET(message->ref_hdr.magic_flags, UNKNOWN_BUFFER_UNION);

  if (message->unknown_buffer) {

    if (union_type == PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_UNF) {

      ProtobufCMessageUnknownFields* unk_buf = message->unknown_buffer;

      for (size_t f = 0; f < unk_buf->n_unknown_fields; f++) {
        const ProtobufCMessageUnknownField *ufld = &unk_buf->unknown_fields[f];

        switch(PROTOBUF_C_FLAG_GET(ufld->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
          case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
            do_free(instance, ufld->serialized.data);
            break;
          case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
            protobuf_c_message_free_unpacked(instance, ufld->cmessage.message);
            break;
          default:
            PROTOBUF_C_ASSERT_NOT_REACHED();
        };
      }

      do_free(instance, unk_buf->unknown_fields);
      do_free(instance, unk_buf);
      message->unknown_buffer = NULL;

    } else {

      PROTOBUF_C_ASSERT(union_type == PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_DELTA);
      do_free(instance, message->delete_delta);
      message->delete_delta = NULL;
    }
  }
}

static void
protobuf_c_message_init_field(ProtobufCInstance* instance,
                              ProtobufCMessage *msg,
                              const ProtobufCFieldDescriptor *fdesc)
{
  if (fdesc == NULL) {
    return;
  }

  PROTOBUF_C_ASSERT(instance);
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

  if (fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
    STRUCT_MEMBER(size_t, msg, fdesc->quantifier_offset) = 0;
    if (!is_inline) {
      STRUCT_MEMBER(void*, msg, fdesc->offset) = NULL;
    }
    // ATTN:Do we need to init each elemnets for inline lists? Come back later.
    return;
  }

  if (ctype) {
    if (is_inline) {
      if (ctype->init_usebody) {
        void *member = STRUCT_MEMBER_PTR(void, msg, fdesc->offset);
        ctype->init_usebody(ctype, fdesc, member);
      }
      if (fdesc->quantifier_offset) {
        STRUCT_MEMBER(protobuf_c_boolean, msg, fdesc->quantifier_offset) = 0;
      }
    } else {
      STRUCT_MEMBER(void*, msg, fdesc->offset) = NULL;
    }
    return;
  }

  const void *default_value = fdesc->default_value;
  switch(fdesc->type) {
    case PROTOBUF_C_TYPE_STRING: {
      char *str = STRUCT_MEMBER_PTR(char, msg, fdesc->offset);
      if (is_inline) {
        if (default_value) {
          strncpy(str, fdesc->default_value, fdesc->data_size);
          PROTOBUF_C_ASSERT('\0' == str[fdesc->data_size-1]);
        } else {
          memset(str, 0, fdesc->data_size);
        }
      } else {
        STRUCT_MEMBER(char *, msg, fdesc->offset) = (char*)fdesc->default_value;
      }
      break;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      const ProtobufCBinaryData *default_bd = (const ProtobufCBinaryData *)default_value;
      if (is_inline) {
        ProtobufCFlatBinaryData *bd = STRUCT_MEMBER_PTR(ProtobufCFlatBinaryData, msg, fdesc->offset);
        size_t buflen = fdesc->data_size - sizeof(ProtobufCFlatBinaryData);
        if (default_bd) {
          PROTOBUF_C_ASSERT(buflen >= default_bd->len);
          memcpy(bd->data, default_bd->data, default_bd->len);
          if (buflen > default_bd->len) {
            memset(bd->data + default_bd->len, 0, buflen - default_bd->len);
          }
          bd->len = default_bd->len;
        } else {
          memset(bd->data, 0, buflen);
          bd->len = 0;
        }
      } else {
        ProtobufCBinaryData *bd = STRUCT_MEMBER_PTR(ProtobufCBinaryData, msg, fdesc->offset);
        if (default_bd) {
          *bd = *default_bd;
        } else {
          bd->data = NULL;
          bd->len = 0;
        }
      }
      break;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      if (is_inline) {
        ProtobufCMessage *submsg = STRUCT_MEMBER_PTR(ProtobufCMessage, msg, fdesc->offset);
        protobuf_c_message_init_inner(msg, submsg, fdesc);
      } else {
        // Can messages have default values???
        STRUCT_MEMBER(void*, msg, fdesc->offset) = NULL;
      }
      break;
    }
    default:{
      size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
      void *member = STRUCT_MEMBER_P(msg, fdesc->offset);
      if (fdesc->default_value) {
        memcpy(member, fdesc->default_value, sizeof_elt);
      } else {
         memset(member, 0, sizeof_elt);
      }
      break;
    }
  }

  if (fdesc->quantifier_offset) {
    STRUCT_MEMBER(uint32_t, msg, fdesc->quantifier_offset) = 0;
  }
}

static void
protobuf_c_message_free_field(ProtobufCInstance* instance,
                              ProtobufCMessage *message,
                              const ProtobufCFieldDescriptor *fdesc)

{
  if (fdesc == NULL) {
    return;
  }

  PROTOBUF_C_ASSERT(instance);
  PROTOBUF_C_ASSERT(message);

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

  if (fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
    unsigned i;
    size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
    size_t n = STRUCT_MEMBER(size_t, message, fdesc->quantifier_offset);
    char *arr = NULL;
    if (is_inline) {
      arr = (char*)STRUCT_MEMBER_P(message, fdesc->offset);
    } else {
      arr = STRUCT_MEMBER(char *, message, fdesc->offset);
      if (arr == NULL) {
        return;
      }
    }

    if (ctype) {
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
      if (ctype->free_usebody) {
        for (i = 0; i < n; i++) {
          if (is_inline) {
            ctype->free_usebody(instance, ctype, fdesc, &arr[sizeof_elt*i]);
          } else {
            void* p = *(void**)&arr[sizeof_elt*i];
            ctype->free_usebody(instance, ctype, fdesc, p);
          }
        }
      }
      if (!is_inline && arr != NULL) {
        for (i = 0; i < n; i++) {
          void* p = *(void**)&arr[sizeof_elt*i];
          do_free(instance, p);
        }
        do_free(instance, arr);
      }
      return;
    }

    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_STRING:
        if ((!is_inline) && (arr != NULL)) {
          for (i = 0; i < n; i++) {
            do_free(instance, ((char**)arr)[i]);
          }
        }
        break;
      case PROTOBUF_C_TYPE_BYTES:
        if (!is_inline && (arr != NULL)) {
          for (i = 0; i < n; i++) {
            do_free(instance, ((ProtobufCBinaryData*)arr)[i].data);
          }
        }
        break;
      case PROTOBUF_C_TYPE_MESSAGE:
        if (is_inline) {
          for (i = 0; i < n; i++) {
            ProtobufCMessage *mptr = (ProtobufCMessage*)&arr[sizeof_elt*i];
            PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER(mptr));
            protobuf_c_message_free_unpacked_usebody(instance, mptr);
          }
        } else if (arr) {
          for (i = 0; i < n; i++) {
            protobuf_c_message_free_unpacked(instance, ((ProtobufCMessage**)arr)[i]);
          }
        }
        break;
      default:
        break;
    }

    if (!is_inline && arr != NULL)
      do_free(instance, arr);

    return;
  }

  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    if (is_inline) {
      void *member = STRUCT_MEMBER_PTR(void, message, fdesc->offset);
      if ( fdesc->label == PROTOBUF_C_LABEL_REQUIRED
          || STRUCT_MEMBER(protobuf_c_boolean, message, fdesc->quantifier_offset)) {
        if (ctype->free_usebody) {
          ctype->free_usebody(instance, ctype, fdesc, member);
        }
      }
    } else {
      void *member = STRUCT_MEMBER(void *, message, fdesc->offset);
      if (member && member != fdesc->default_value) {
        if (ctype->free_usebody) {
          ctype->free_usebody(instance, ctype, fdesc, member);
        }
        do_free(instance, member);
      }
    }
    return;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
      if (!is_inline) {
        char *str = STRUCT_MEMBER(char *, message, fdesc->offset);
        if (str && str != fdesc->default_value) {
          do_free(instance, str);
        }
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      if (!is_inline) {
        const ProtobufCBinaryData *default_bd = (const ProtobufCBinaryData *)fdesc->default_value;
        void *data = STRUCT_MEMBER(ProtobufCBinaryData, message, fdesc->offset).data;
        if (data && !(default_bd && data == default_bd->data)) {
          do_free(instance, data);
        }
      }
      break;
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        ProtobufCMessage *sm = STRUCT_MEMBER(ProtobufCMessage *, message, fdesc->offset);
        if (sm && sm != fdesc->default_value) {
          protobuf_c_message_free_unpacked(instance, sm);
        }
      } else {
        ProtobufCMessage *mptr = STRUCT_MEMBER_P(message, fdesc->offset);
        PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER(mptr));
        if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED
            || STRUCT_MEMBER(protobuf_c_boolean, message, fdesc->quantifier_offset)) {
          protobuf_c_message_free_unpacked_usebody(instance, mptr);
        }
      }
      break;
    default:
      break;
  }

  return;
}

static void
protobuf_c_message_free_unpacked_int(ProtobufCInstance* instance,
                                     ProtobufCMessage *message,
                                     int skipbody)
{
  const ProtobufCMessageDescriptor *mdesc = message->descriptor;
  unsigned f;

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, free);

  /* Validate the reference state, reference count and change the ref_state to
   * deleting */
  protobuf_c_ref_header_set_ref_state(&message->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_DELETING);

  for (f = 0; f < mdesc->n_fields; f++) {
    const ProtobufCFieldDescriptor *fdesc = &mdesc->fields[f];
    protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
    const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

    if (   0 != (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)
        && fdesc->id != STRUCT_MEMBER(uint32_t, message, fdesc->quantifier_offset)) {
      /* This is not the selected oneof, skip it */
      continue;
    }

    protobuf_c_message_free_field(instance, message, fdesc);
  }

  /* Change the ref_state to INVALID */
  protobuf_c_ref_header_set_ref_state(&message->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_INVALID);

  protobuf_c_message_free_unknown_all(instance, message);

  if (!skipbody) {
    do_free(instance, message);
  }
}

void
protobuf_c_message_free_unpacked(ProtobufCInstance* instance,
                                 ProtobufCMessage *message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(!PROTOBUF_C_MESSAGE_IS_INNER(message));
  ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
  if (debug_stats) {
    g_atomic_int_inc(&debug_stats->free_outer_count);
  }

  protobuf_c_message_free_unpacked_int(instance, message, FALSE);
}

void
protobuf_c_message_free_unpacked_usebody(ProtobufCInstance* instance,
                                         ProtobufCMessage *message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
  if (debug_stats) {
    g_atomic_int_inc(&debug_stats->free_usebody_count);
  }

  protobuf_c_message_free_unpacked_int(instance, message, TRUE);
}

void
protobuf_c_message_init(const ProtobufCMessageDescriptor *mdesc,
                        ProtobufCMessage *message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(mdesc));
  PROTOBUF_C_ASSERT(NULL != message);

  PROTOBUF_C_ASSERT(mdesc->init_value);
  protobuf_c_message_memcpy(message, mdesc->init_value);
  protobuf_c_ref_header_create(&message->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_OWNED, 0);

  ProtobufCMessageDebugStats* debug_stats = mdesc->debug_stats;
  if (debug_stats) {
    g_atomic_int_inc(&debug_stats->init_count);
  }
}

ProtobufCMessage*
protobuf_c_message_create(ProtobufCInstance* instance,
                          const ProtobufCMessageDescriptor *mdesc)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(mdesc));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, create);

  ProtobufCMessage* msg = do_alloc(instance, mdesc->sizeof_message);
  PROTOBUF_C_ASSERT(msg);
  protobuf_c_message_init(mdesc, msg);
  return msg;
}

protobuf_c_boolean
protobuf_c_message_check(ProtobufCInstance* instance,
                         const ProtobufCMessage *message)
{
  if (!PROTOBUF_C_IS_MESSAGE(message)) {
    return FALSE;
  }

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, check);

  unsigned f;
  for (f = 0; f < message->descriptor->n_fields; f++) {

    const ProtobufCFieldDescriptor* fdesc = &message->descriptor->fields[f];
    protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
    const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
    const void *qfier = (const char*)message + fdesc->quantifier_offset;
    const char *fbase = (const char*)message + fdesc->offset;
    const char *element = fbase;
    size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
    unsigned i;

    if (ctype) {
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
      if (NULL == ctype->check) {
        continue;
      }
      if (fdesc->label == PROTOBUF_C_LABEL_REQUIRED) {
        if (!ctype->check(ctype, fdesc, element)) {
          return FALSE;
        }
      } else if (fdesc->label == PROTOBUF_C_LABEL_OPTIONAL) {
        if (is_inline) {
          if (0 == *(const protobuf_c_boolean*)qfier) {
            continue;
          }
        } else {
          element = *(const char* const*)fbase;
        }
        if (element) {
          if (!ctype->check(ctype, fdesc, element)) {
            return FALSE;
          }
        }
      } else {
        for (i = 0; i < *(const size_t*)qfier; i++) {
          if (is_inline) {
            element = fbase + i*sizeof_elt;
          } else {
            element = (*(const char* const**)fbase)[i];
          }
          if (element == NULL) {
            return FALSE;
          }
          if (!ctype->check(ctype, fdesc, element)) {
            return FALSE;
          }
        }
      }
      continue;
    }

    switch (fdesc->type) {
      case PROTOBUF_C_TYPE_MESSAGE: {
        ProtobufCMessageDescriptor *mdesc = (ProtobufCMessageDescriptor*)fdesc->descriptor;
        switch (fdesc->label) {
          case PROTOBUF_C_LABEL_REQUIRED:
            if (!is_inline) {
              element = *(const char* const*)fbase;
            } else {
              PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER((const ProtobufCMessage*)element));
            }
            if (element == NULL) {
              return FALSE;
            }
            if (!protobuf_c_message_check(instance, (const ProtobufCMessage*)element)) {
              return FALSE;
            }
            break;
          case PROTOBUF_C_LABEL_OPTIONAL:
            if (is_inline) {
              PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER((const ProtobufCMessage*)element));
              if (0 == *(const protobuf_c_boolean*)qfier) {
                break;
              }
            } else {
              element = *(const char* const*)fbase;
            }
            if (element) {
              if (!protobuf_c_message_check(instance, (const ProtobufCMessage*)element)) {
                return FALSE;
              }
            }
            break;
          case PROTOBUF_C_LABEL_REPEATED: {
            if (*(const size_t*)qfier && (!is_inline)
                && *(const char **)fbase == NULL) {
              return FALSE;
            }
            for (i = 0; i < *(const size_t*)qfier; i++) {
              if (is_inline) {
                PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_INNER((const ProtobufCMessage*)element));
                element = fbase + i*sizeof_elt;
              } else {
                element = (*((const char* const**)fbase))[i];
              }
              if (element == NULL) {
                return FALSE;
              }
              if (!protobuf_c_message_check(instance, (const ProtobufCMessage*)element)) {
                return FALSE;
              }
            }
            break;
          }
          default:
            break;
          break;
        }
      } // case PROTOBUF_C_TYPE_MESSAGE
      case PROTOBUF_C_TYPE_STRING: {
        switch (fdesc->label) {
          case PROTOBUF_C_LABEL_REQUIRED:
            if (!is_inline) {
              element = *(const char* const*)fbase;
            }
            if (element == NULL) {
              return FALSE;
            }
            break;
          case PROTOBUF_C_LABEL_OPTIONAL:
            // Nothing to check.
            break;
          case PROTOBUF_C_LABEL_REPEATED: {
            if (!is_inline) {
              const size_t *quantity = (const size_t *)qfier;
              if (*quantity > 0 && *(const char **)fbase == NULL) {
                return FALSE;
              }
              char **string = *(char ***) fbase;
              unsigned j;
              for (j = 0; j < *quantity; j++) {
                if (!string[j]) {
                  return FALSE;
                }
              }
            }
            break;
          }
          default:
            break;
        }
        break;
      } // case PROTOBUF_C_TYPE_STRING
      case PROTOBUF_C_TYPE_BYTES: {
        switch (fdesc->label) {
          case PROTOBUF_C_LABEL_REQUIRED:
            if (!is_inline) {
              ProtobufCBinaryData *bd = (ProtobufCBinaryData *)fbase;
              if (bd->data == NULL) {
                return FALSE;
              }
            }
            break;
          case PROTOBUF_C_LABEL_OPTIONAL:
            if (*(protobuf_c_boolean *)qfier) {
              if (!is_inline) {
                ProtobufCBinaryData *bd = (ProtobufCBinaryData *)fbase;
                if (bd->len > 0 && bd->data == NULL) {
                  return FALSE;
                }
              }
            }
            break;
          case PROTOBUF_C_LABEL_REPEATED: {
            const size_t quantity = *(const size_t *)qfier;
            if (!is_inline) {
              ProtobufCBinaryData *bd = *(ProtobufCBinaryData **) fbase;
              if (quantity > 0 && !bd) {
                return FALSE;
              }
              unsigned j;
              for (j = 0; j < quantity; j++) {
                if (bd[j].data == NULL) {
                  return FALSE;
                }
              }
            }
            break;
          }
        }
        break;
      } // case PROTOBUF_C_TYPE_BYTES
      default: // other primitive fields..
        if (fdesc->label == PROTOBUF_C_LABEL_REPEATED) {
          const size_t *quantity = (const size_t *)qfier;
          if (!is_inline) {
            if (*quantity > 0 && *(void **) fbase == NULL) {
              return FALSE;
            }
          }
        }
        break;
    }
  }
  return TRUE;
}

/* === services === */

typedef void (*GenericHandler) (void *service,
        const ProtobufCMessage *input,
        ProtobufCClosure closure,
        void *closure_data);
void
protobuf_c_service_invoke_internal(ProtobufCService *service,
           unsigned method_index,
           const ProtobufCMessage *input,
           ProtobufCClosure closure,
           void *closure_data)
{
  GenericHandler *handlers;
  GenericHandler handler;

  /*
   * Verify that method_index is within range.  If this fails, you are
   * likely invoking a newly added method on an old service.  (Although
   * other memory corruption bugs can cause this assertion too.)
  */
  PROTOBUF_C_ASSERT(method_index < service->descriptor->n_methods);

  /*
   * Get the array of virtual methods (which are enumerated by the
   * generated code).
   */
  handlers = (GenericHandler *) (service + 1);

  /*
   * Get our method and invoke it.
   * \todo seems like handler==NULL is a situation that needs handling.
   */
  handler = handlers[method_index];
  (*handler)(service, input, closure, closure_data);
}

void
protobuf_c_service_invoke_internal_b(ProtobufCService *service,
             unsigned method_index,
             const ProtobufCMessage *input,
             void *closure_data)
{
  GenericHandler *handlers;
  GenericHandler handler;

  /* client side binding doesn't support invoke_internal_b */
  PROTOBUF_C_ASSERT_NOT_REACHED();

  /*
   * Verify that method_index is within range.  If this fails, you are
   * likely invoking a newly added method on an old service.  (Although
   * other memory corruption bugs can cause this assertion too.)
   */
  PROTOBUF_C_ASSERT(method_index < service->descriptor->n_methods);

  /*
   * Get the array of virtual methods (which are enumerated by the
   * generated code).
   */
  handlers = (GenericHandler *) (service + 1);

  /* Get our method and invoke it. */
  /* TODO: seems like handler==NULL is a situation that needs handling. */
  handler = handlers[method_index];
  (*handler)(service, input, NULL, closure_data);
}

void
protobuf_c_service_generated_init(ProtobufCService *service,
          const ProtobufCServiceDescriptor *descriptor,
          void *rift_ctx,
          ProtobufCServiceDestroy destroy)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_SERVICE_DESCRIPTOR(descriptor));
  service->descriptor = descriptor;
  service->destroy = destroy;
  service->rw_context = rift_ctx;
  service->invoke = protobuf_c_service_invoke_internal;
  service->invoke_b = protobuf_c_service_invoke_internal_b;
  memset(service + 1, 0, descriptor->n_methods * sizeof(GenericHandler));
}

void protobuf_c_service_destroy(ProtobufCService *service)
{
  service->destroy(service);
}

/* --- querying the descriptors --- */

const ProtobufCEnumValue *
protobuf_c_enum_descriptor_get_value_by_name(const ProtobufCEnumDescriptor *edesc,
                                             const char *name)
{
  unsigned start = 0;
  unsigned count = edesc->n_value_names;

  while (count > 1) {
    unsigned mid = start + count / 2;
    int rv = strcmp(edesc->values_by_name[mid].name, name);
    if (rv == 0) {
      return edesc->values + edesc->values_by_name[mid].index;
    }
    if (rv < 0) {
      count = start + count - (mid + 1);
      start = mid + 1;
    } else {
      count = mid - start;
    }
  }
  if (count == 0) {
    return NULL;
  }
  if (strcmp(edesc->values_by_name[start].name, name) == 0) {
    return edesc->values + edesc->values_by_name[start].index;
  }
  return NULL;
}

const ProtobufCEnumValue *
protobuf_c_enum_descriptor_get_value(const ProtobufCEnumDescriptor *edesc,
                                     int value)
{
  int rv = int_range_lookup(edesc->n_value_ranges, edesc->value_ranges, value);
  if (rv < 0) {
    return NULL;
  }
  return edesc->values + rv;
}

const ProtobufCFieldDescriptor *
protobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *mdesc,
                                                const char *name)
{
  unsigned start = 0;
  unsigned count = mdesc->n_fields;
  const ProtobufCFieldDescriptor* fdesc;

  while (count > 1) {
    unsigned mid = start + count / 2;
    int rv;
    fdesc = mdesc->fields + mdesc->fields_sorted_by_name[mid];
    rv = strcmp(fdesc->name, name);
    if (rv == 0) {
      return fdesc;
    }
    if (rv < 0) {
      count = start + count - (mid + 1);
      start = mid + 1;
    } else {
      count = mid - start;
    }
  }
  if (count == 0) {
    return NULL;
  }
  fdesc = mdesc->fields + mdesc->fields_sorted_by_name[start];
  if (strcmp(fdesc->name, name) == 0) {
    return fdesc;
  }
  return NULL;
}

const ProtobufCFieldDescriptor *
protobuf_c_message_descriptor_get_field(const ProtobufCMessageDescriptor *mdesc,
                                        unsigned value)
{
  int rv = int_range_lookup(mdesc->n_field_ranges,mdesc->field_ranges, value);
  if (rv < 0) {
    return NULL;
  }
  return mdesc->fields + rv;
}

const ProtobufCMessageDescriptor*
protobuf_c_message_descriptor_gi_ref(
  const ProtobufCMessageDescriptor *desc)
{
  return desc;
}

void
protobuf_c_message_descriptor_gi_unref(
  const ProtobufCMessageDescriptor *desc)
{
  (void)desc;
}

// ATTN: Quick hack, fix me
int protobuf_c_gi_boxed_zalloc_count = 0;
void*
protobuf_c_gi_boxed_zalloc(
  size_t bytes)
{
  g_atomic_int_inc(&protobuf_c_gi_boxed_zalloc_count);
  return protobuf_c_instance_zalloc(NULL, bytes);
}

int protobuf_c_gi_boxed_free_count = 0;
void
protobuf_c_gi_boxed_free(
  void* p)
{
  g_atomic_int_inc(&protobuf_c_gi_boxed_free_count);
  protobuf_c_instance_free(NULL, p);
}

const ProtobufCMethodDescriptor *
protobuf_c_service_descriptor_get_method_by_name(const ProtobufCServiceDescriptor *sdesc,
                                                 const char *name)
{
  unsigned start = 0;
  unsigned count = sdesc->n_methods;

  while (count > 1) {
    unsigned mid = start + count / 2;
    unsigned mid_index = sdesc->method_indices_by_name[mid];
    const char *mid_name = sdesc->methods[mid_index].name;
    int rv = strcmp(mid_name, name);

    if (rv == 0) {
      return sdesc->methods + sdesc->method_indices_by_name[mid];
    }
    if (rv < 0) {
      count = start + count - (mid + 1);
      start = mid + 1;
    } else {
      count = mid - start;
    }
  }
  if (count == 0) {
    return NULL;
  }
  if (strcmp(sdesc->methods[sdesc->method_indices_by_name[start]].name, name) == 0) {
    return sdesc->methods + sdesc->method_indices_by_name[start];
  }
  return NULL;
}





/* --- RIFT utility hacks --- */

/* ATTN: These are ugly and very inconsistent with the library - please clean these up */
/*
 * Generalized routine to set a field in a previously allocated protobuf
 */
static protobuf_c_boolean
protobuf_c_message_set_field_impl(ProtobufCInstance* instance,
                                  ProtobufCMessage *message,
                                  const ProtobufCFieldDescriptor *fdesc,
                                  ProtobufCMessage **inner_pbcm,
                                  const char *val,
                                  size_t val_len)
{
  PROTOBUF_C_ASSERT(message);
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(val);
  instance = protobuf_c_instance_get(instance);

  /*
     ATTN: This API is too wide - it takes a confusing set of disjoint arguments
     ATTN: This function needs to be split into 2-5 different functions:
      - allocate+/-clear the target required/optional field or new repeated element
      - copy binary to target, using len+data
      - copy binary to target, using base64 string
      - copy primitive to target
      - scanf primitive to target
      - copy string to target
      - provide access to message
   */

  /*
   * NOTE: inner_pcbm is only non-NULL for message types
   * If field isn't a message, but caller expects that it is return an error
   * If field is a message, but caller expects that it is not, return an error
   */
  if (fdesc->type == PROTOBUF_C_TYPE_MESSAGE) {
    if (NULL == inner_pbcm) {
      PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                               "Message type, but no message pointer");
      return FALSE;
    }
  } else {
    if (NULL != inner_pbcm) {
      PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                               "Not message type, but with message pointer");
      return FALSE;
    }
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  char *fbase = (char*)message + fdesc->offset;
  char *element = fbase;
  size_t *qfier = (size_t*)((char*)message + fdesc->quantifier_offset);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  protobuf_c_boolean already_has = FALSE;
  protobuf_c_boolean ret_success = TRUE;

  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REPEATED:
      PROTOBUF_C_ASSERT(fdesc->quantifier_offset);
      if (is_inline) {
        if (*qfier >= fdesc->rw_inline_max) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Max elements already filled for : '%s'",fdesc->name);
          return FALSE;
        }
        element = fbase + sizeof_elt * *qfier;
      } else {
        uint32_t old_sz = (*qfier)*sizeof_elt;
        uint32_t new_sz = (*qfier+1)*sizeof_elt;

        /* ATTN: Should have a realloc! */
        char* new_vec = do_alloc(instance, new_sz);
        if (NULL == new_vec) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Out of memory");
          return FALSE;
        }

        char* old_vec = *(char**)fbase;
        memcpy(new_vec,old_vec,old_sz);
        memset(new_vec+old_sz,0,sizeof_elt);
        do_free(instance, old_vec);

        *(void**)fbase = new_vec;
        element = new_vec + old_sz;
      }
      break;
    case PROTOBUF_C_LABEL_REQUIRED:
      already_has = TRUE;
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (fdesc->quantifier_offset) {
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          // It is ok to type cast to uint32_t as tag number are the same type.
          already_has = (*(uint32_t *)qfier) != 0 ? TRUE: FALSE;
          if (already_has) {
            PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                     "Oneof field already set %u ", (*(uint32_t *)qfier));
            return FALSE;
          }
        } else {
          already_has = *(protobuf_c_boolean*)qfier ? TRUE : FALSE;
        }
      } else {
        already_has = *(void**)fbase ? TRUE : FALSE;
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->from_string);
    void* value;
    if (is_inline) {
      value = element;
    } else {
      if (already_has) {
        value = *(void**)element;
        if (!value) {
          already_has = FALSE;
        }
      }
      if (!already_has) {
        value = do_alloc(instance, fdesc->data_size);
        if (ctype->init_usebody) {
          (ctype->init_usebody)(ctype, fdesc, value);
        }
        *(void**)element = value;
      }
    }
    protobuf_c_boolean success = ctype->from_string(
      instance, ctype, fdesc, val, val_len, already_has, value);
    if (!success) {
      // ATTN: Better status!
      goto fail;
    }
    goto success;
  }

  switch(fdesc->type) {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32: {
      int32_t parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%d%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(int32_t*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32: {
      uint32_t parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%u%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(uint32_t*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64: {
      int64_t parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%" SCNd64 "%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(int64_t*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64: {
      uint64_t parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%" SCNu64 "%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(uint64_t*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_FLOAT: {
      float parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%f%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(float*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_DOUBLE: {
      double parsed = 0;
      char extra[2];
      int rc = sscanf(val,"%lf%1s",&parsed,extra);
      if (1 != rc || isspace(val[0])) {
        // ATTN: Better status!
        goto fail;
      }
      *(double*)element = parsed;
      goto success;
    }
    case PROTOBUF_C_TYPE_BOOL: {
      // ATTN: Really need to have a list of acceptable values here.  What at the standards?
      if (0 == strcmp(val,"true")) {
        *(protobuf_c_boolean *)element = 1;
      } else {
        *(protobuf_c_boolean *)element = 0;
      }
      goto success;
    }
    case PROTOBUF_C_TYPE_ENUM: {
      /*
         ATTN: Allow yang enum values as well?
         ATTN: There really ought to be a different API for XML
         versus string conversion?  Or is string conversion always XML?
       */
      const ProtobufCEnumValue *enum_val
        = protobuf_c_enum_descriptor_get_value_by_name(
            (const ProtobufCEnumDescriptor *)fdesc->descriptor,val);
      if (enum_val) {
        *((int *)element) = enum_val->value;
      } else {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                 "INVALID enum value-string: '%s'",val);
        goto fail;
      }
      goto success;
    }
    case PROTOBUF_C_TYPE_STRING: {
      if (is_inline) {
        if (val_len >= sizeof_elt) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "set field text value too long for inline string field");
          goto fail;
        }
        strncpy(element, val, sizeof_elt);
        PROTOBUF_C_ASSERT('\0' == element[sizeof_elt-1]);
        PROTOBUF_C_ASSERT('\0' == element[val_len]);
        PROTOBUF_C_ASSERT(val_len == 0 || '\0' != element[val_len-1]);
      } else {
        char** pstr = (char**)element;
        if (already_has && *pstr != NULL && *pstr != fdesc->default_value) {
          do_free(instance, *pstr);
          *pstr = NULL;
        }

        *pstr = do_alloc(instance, val_len + 1);
        if (*pstr == NULL) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Out of memory");
          goto fail;
        }
        memcpy(*pstr, val, val_len);
        (*pstr)[val_len] = 0;
      }
      goto success;
    }
    case PROTOBUF_C_TYPE_BYTES: {
      if (is_inline) {
        size_t inline_size = sizeof_elt-sizeof(ProtobufCFlatBinaryData);
        ProtobufCFlatBinaryData *bd = (ProtobufCFlatBinaryData*)element;
        if (val_len > inline_size) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "set field text value too long for inline binary field");
          goto fail;
        }
        memcpy(bd->data, val, val_len);
        if (val_len < inline_size) {
          // zero the rest; it makes memcmp for comparisons work well...
          memset(bd->data+val_len, 0, inline_size-val_len);
        }
        bd->len = val_len;
      } else {
        ProtobufCBinaryData *bd = (ProtobufCBinaryData*)element;
        if (already_has&& bd->data != NULL && bd->data != fdesc->default_value) {
          do_free(instance, bd->data);
          bd->data = NULL;
        }

        bd->data = do_alloc(instance, val_len);
        if (bd->data == NULL) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Out of memory");
          goto fail;
        }
        memcpy(bd->data, val, val_len);
        bd->len = val_len;
      }
      goto success;
    }
    case PROTOBUF_C_TYPE_MESSAGE: {
      PROTOBUF_C_ASSERT('\0' == val[0]);
      PROTOBUF_C_ASSERT(inner_pbcm);
      PROTOBUF_C_ASSERT(NULL == *inner_pbcm);
      const ProtobufCMessageDescriptor *inner_mdesc
        = (const ProtobufCMessageDescriptor *)fdesc->descriptor;
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(inner_mdesc));

      if (is_inline) {
        *inner_pbcm = (ProtobufCMessage*) element;
        if (!already_has) {
          protobuf_c_message_init_inner(message, *inner_pbcm, fdesc);
        }
        /* ATTN: Destroy the message that is already here? */
        /* ATTN: What about replacing fields by keys? */
      } else {
        PROTOBUF_C_ASSERT(inner_mdesc);
        ProtobufCMessage** pmsg = (ProtobufCMessage**)element;
        if (!(already_has&& *pmsg != NULL && *pmsg != fdesc->default_value)) {
          *pmsg = do_alloc(instance, inner_mdesc->sizeof_message);
          if (*pmsg == NULL) {
            PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                     "Out of memory");
            goto fail;
          }
          protobuf_c_message_init(inner_mdesc, *pmsg);
        }
        *inner_pbcm = *pmsg;
      }
      goto success;
    }
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
      goto fail;
  }

fail:
  ret_success = FALSE;

success:
  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REPEATED:
      ++*qfier;
      break;
    case PROTOBUF_C_LABEL_REQUIRED:
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (fdesc->quantifier_offset) {
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          *(uint32_t *)qfier = fdesc->id;
        } else {
          *(protobuf_c_boolean*)qfier = TRUE;
        }
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  if (!ret_success) {
    // Need to undo, by deleting the field.
    switch (fdesc->label) {
      case PROTOBUF_C_LABEL_REPEATED:
        protobuf_c_message_delete_field_index(instance, message, fdesc->id, *qfier-1);
        break;
      case PROTOBUF_C_LABEL_REQUIRED:
      case PROTOBUF_C_LABEL_OPTIONAL:
        protobuf_c_message_delete_field(
            instance, message, fdesc->id);
        break;
    }
  }
  return ret_success;
}

protobuf_c_boolean
protobuf_c_message_set_field_message(ProtobufCInstance* instance,
                                     ProtobufCMessage *message,
                                     const ProtobufCFieldDescriptor *fdesc,
                                     ProtobufCMessage **inner_pbcm)
{
  PROTOBUF_C_ASSERT(fdesc);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, set_field_msg);

  if (PROTOBUF_C_TYPE_MESSAGE != fdesc->type) {
    PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                             "Cannot set message on non-message field");
    return FALSE;
  }

  return protobuf_c_message_set_field_impl(instance, message, fdesc, inner_pbcm, "", 0);
}

protobuf_c_boolean
protobuf_c_message_set_field_text_value(ProtobufCInstance* instance,
                                        ProtobufCMessage *message,
                                        const ProtobufCFieldDescriptor *fdesc,
                                        const char *val,
                                        size_t val_len)
{
  PROTOBUF_C_ASSERT(fdesc);

  uint32_t v_uint32 = 0;
  int32_t v_int32 = 0;
  uint64_t v_uint64 = 0;
  int64_t v_int64 = 0;
  float v_float = 0.0;
  double v_double = 0.0;
  protobuf_c_boolean v_bool = 0;

  char extra[2];
  ProtobufCFieldInfo finfo;
  memset (&finfo, 0, sizeof (finfo));
  finfo.fdesc = fdesc;

  instance = protobuf_c_instance_get(instance);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {

    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->from_string);

    // ATTN:- Should this also use protobuf_c_instance alloc function?
    void *v_ctype = alloca(fdesc->data_size);
    PROTOBUF_C_ASSERT (v_ctype);

    if (ctype->init_usebody) {
      (ctype->init_usebody)(ctype, fdesc, v_ctype);
    }

    protobuf_c_boolean success = ctype->from_string(
        instance, ctype, fdesc, val, val_len, false, v_ctype);

    if (!success) {
      return false;
    }

    finfo.element = v_ctype;
    protobuf_c_boolean rc = protobuf_c_message_set_field(instance, message, &finfo);

    if (ctype->free_usebody) {
      ctype->free_usebody(instance, ctype, fdesc, v_ctype);
    }

    return rc;
  }

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_MESSAGE:
      PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                               "Cannot set text value on message");
      return FALSE;
    case PROTOBUF_C_TYPE_BYTES:
      /* ATTN: Really should only accept NUL-terminated base64 here!! */
      /* empty bytes may be null pointer */
      if (!val) {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                 "No pointer for bytes value");
        return FALSE;
      }
      finfo.element = val;
      finfo.len = val_len;
      break;
    case PROTOBUF_C_TYPE_ENUM: {
      /* pointer cannot be null */
      PROTOBUF_C_ASSERT(val);
      const ProtobufCEnumValue *enum_val
          = protobuf_c_enum_descriptor_get_value_by_name(
              (const ProtobufCEnumDescriptor *)fdesc->descriptor,val);
      if (enum_val) {
        v_int32 = enum_val->value;
        finfo.element = &v_int32;
      } else {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                 "INVALID enum value-string: '%s'",val);
        return false;
      }
      break;
    }
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32: {

      int rc = sscanf(val,"%d%1s",&v_int32,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_int32;
      break;
    }
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32: {
      int rc = sscanf(val,"%u%1s",&v_uint32,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_uint32;
      break;
    }
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64: {
      int rc = sscanf(val,"%" SCNd64 "%1s",&v_int64,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_int64;
      break;
    }
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64: {
      int rc = sscanf(val,"%" SCNu64 "%1s",&v_uint64,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_uint64;
      break;
    }
    case PROTOBUF_C_TYPE_FLOAT: {
      int rc = sscanf(val,"%f%1s",&v_float,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_float;
      break;
    }
    case PROTOBUF_C_TYPE_DOUBLE: {
      int rc = sscanf(val,"%lf%1s",&v_double,extra);
      if (1 != rc || isspace(val[0])) {
        return false;
      }
      finfo.element = &v_double;
      break;
    }
    case PROTOBUF_C_TYPE_BOOL: {
      // ATTN: Really need to have a list of acceptable values here.
      // What at the standards?
      if (0 == strcmp(val,"true")) {
        v_bool = 1;
      } else if (0 == strcmp (val, "false")) {
        v_bool = 0;
      } else {
        return false;
      }
      finfo.element = &v_bool;
      break;
    }
    case PROTOBUF_C_TYPE_STRING:
      /* empty string must be at least ""; pointer cannot be null */
      PROTOBUF_C_ASSERT(val);
      finfo.element = val;
      finfo.len = strlen (val);
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
      break;
  }

  return protobuf_c_message_set_field(instance, message, &finfo);
}


protobuf_c_boolean
protobuf_c_message_set_field(ProtobufCInstance* instance,
                             ProtobufCMessage *message,
                             ProtobufCFieldInfo *finfo)
{
  PROTOBUF_C_ASSERT(message);
  PROTOBUF_C_ASSERT(finfo);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, set_field);

  const ProtobufCFieldDescriptor *fdesc = finfo->fdesc;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  char *fbase = (char*)message + fdesc->offset;
  char *element = fbase;
  size_t *qfier = (size_t*)((char*)message + fdesc->quantifier_offset);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);
  protobuf_c_boolean already_has = FALSE;
  protobuf_c_boolean ret_success = TRUE;

  // ATTN: This function should validate that the field does belong in
  // this message??
  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REPEATED:
      PROTOBUF_C_ASSERT(fdesc->quantifier_offset);
      if (is_inline) {
        if (*qfier >= fdesc->rw_inline_max) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Max elements already filled for : '%s'",fdesc->name);
          return FALSE;
        }
        element = fbase + sizeof_elt * *qfier;
      } else {
        uint32_t old_sz = (*qfier)*sizeof_elt;
        uint32_t new_sz = (*qfier+1)*sizeof_elt;

        /* ATTN: Should have a realloc! */
        char* new_vec = do_alloc(instance, new_sz);
        if (NULL == new_vec) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Out of memory");
          return FALSE;
        }

        char* old_vec = *(char**)fbase;
        memcpy(new_vec,old_vec,old_sz);
        memset(new_vec+old_sz,0,sizeof_elt);
        do_free(instance, old_vec);

        *(void**)fbase = new_vec;
        element = new_vec + old_sz;
      }
      break;
    case PROTOBUF_C_LABEL_REQUIRED:
      already_has = TRUE;
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (fdesc->quantifier_offset) {
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          // It is ok to type cast to uint32_t as tag number are the same type.
          already_has = (*(uint32_t *)qfier) != 0 ? TRUE: FALSE;
          if (already_has) {
            PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                     "Oneof field already set %u ", (*(uint32_t *)qfier));
            return FALSE;
          }
        } else {
          already_has = *(protobuf_c_boolean*)qfier ? TRUE : FALSE;
        }
      } else {
        already_has = *(void**)fbase ? TRUE : FALSE;
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->deep_copy);
    void* value;
    if (is_inline) {
      value = element;
    } else {
      if (already_has) {
        value = *(void**)element;
        if (!value) {
          already_has = FALSE;
        }
      }
      if (!already_has) {
        value = do_alloc(instance, fdesc->data_size);
        if (ctype->init_usebody) {
          (ctype->init_usebody)(ctype, fdesc, value);
        }
        *(void**)element = value;
      }
    }
    protobuf_c_boolean success = ctype->deep_copy(
        instance, ctype, fdesc, finfo->element, already_has, value);
    if (!success) {
      goto fail;
    }
    goto success;
  }

  switch(fdesc->type) {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_ENUM:
      *((int *)element) = *(int *)finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32:
      *(uint32_t*)element = *(uint32_t *) finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
      *(int64_t*)element = *(int64_t *) finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64:
      *(uint64_t*)element = *(uint64_t *) finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_FLOAT:
      *(float*)element = *(float *)finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_DOUBLE:
      *(double*)element =*(double *)finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_BOOL:
      *(protobuf_c_boolean *)element = *(protobuf_c_boolean *)finfo->element;
      goto success;

    case PROTOBUF_C_TYPE_STRING: {
      PROTOBUF_C_ASSERT(finfo->element);
      finfo->len = strlen ((const char *) (finfo->element));

      if (is_inline) {
        if (finfo->len >= sizeof_elt) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "set field text value too long for inline string field");
          goto fail;
        }

        strncpy(element, (const char *) finfo->element, sizeof_elt);
        PROTOBUF_C_ASSERT('\0' == element[sizeof_elt-1]);
        goto success;
      }

      char** pstr = (char**)element;
      if (already_has && *pstr != NULL && *pstr != fdesc->default_value) {
        do_free(instance, *pstr);
        *pstr = NULL;
      }

      *pstr = do_alloc(instance, finfo->len + 1);
      if (*pstr == NULL) {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                 "Out of memory");
        goto fail;
      }
      memcpy(*pstr, finfo->element, finfo->len);
      (*pstr)[finfo->len] = 0;
      goto success;
    }

    case PROTOBUF_C_TYPE_BYTES:
      if (is_inline) {
        size_t inline_size = sizeof_elt-sizeof(ProtobufCFlatBinaryData);
        ProtobufCFlatBinaryData *bd = (ProtobufCFlatBinaryData*)element;
        if (finfo->len > inline_size) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "set field text value too long for inline binary field");
          goto fail;
        }
        memcpy(bd->data, finfo->element, finfo->len);
        if (finfo->len < inline_size) {
          // zero the rest; it makes memcmp for comparisons work well...
          memset(bd->data+finfo->len, 0, inline_size-finfo->len);
        }
        bd->len = finfo->len;
      } else {
        ProtobufCBinaryData *bd = (ProtobufCBinaryData*)element;
        if (   already_has
               && bd->data != NULL
               && bd->data != fdesc->default_value) {
          do_free(instance, bd->data);
          bd->data = NULL;
        }

        bd->data = do_alloc(instance, finfo->len);
        if (bd->data == NULL) {
          PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                   "Out of memory");
          goto fail;
        }
        memcpy(bd->data, finfo->element, finfo->len);
        bd->len = finfo->len;
      }
      goto success;

    case PROTOBUF_C_TYPE_MESSAGE: {
      const ProtobufCMessageDescriptor *inner_mdesc
          = (const ProtobufCMessageDescriptor *)fdesc->descriptor;
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(inner_mdesc));

      if (is_inline) {
        ProtobufCMessage *inner = (ProtobufCMessage*) element;
        protobuf_c_message_init_inner(message, inner, fdesc);
        if (!protobuf_c_message_copy_usebody(instance,
                                             (ProtobufCMessage *)finfo->element,
                                             inner)) {
          goto fail;
        }
        goto success;
      }

      ProtobufCMessage** pmsg = (ProtobufCMessage**)element;
      *pmsg = protobuf_c_message_duplicate (instance,
                                            (ProtobufCMessage *)finfo->element,
                                            inner_mdesc);
      if (*pmsg == NULL) {
        PROTOBUF_C_MESSAGE_ERROR(instance, message, fdesc,
                                 "Out of memory");
        goto fail;
      }
      goto success;
    }

    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
      goto fail;
  }

fail:
  ret_success = FALSE;

success:
  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REPEATED:
      ++*qfier;
      break;
    case PROTOBUF_C_LABEL_REQUIRED:
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (fdesc->quantifier_offset) {
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          *(uint32_t *)qfier = fdesc->id;
        } else {
          *(protobuf_c_boolean*)qfier = TRUE;
        }
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }
  if (!ret_success) {
    // Need to undo, by deleting the field.
    switch (fdesc->label) {
      case PROTOBUF_C_LABEL_REPEATED:
        protobuf_c_message_delete_field_index(
            instance, message, fdesc->id, *qfier-1);
        break;
      case PROTOBUF_C_LABEL_REQUIRED:
      case PROTOBUF_C_LABEL_OPTIONAL:
        protobuf_c_message_delete_field(
            instance, message, fdesc->id);
        break;
    }
  }
  return ret_success;
}

#define PROTOBUF_C_CHAR_BUF_ALLOC(char_buf_, instance_, size_) \
  if ((char_buf_)->free_buf) { \
    PROTOBUF_C_ASSERT((char_buf_)->buffer != &((char_buf_)->stack_buf[0])); \
    do_free (instance_, (char_buf_)->buffer); \
  } \
  (char_buf_)->buffer   = (char *)do_alloc (instance_, size_); \
  (char_buf_)->buf_len  = size_; \
  (char_buf_)->free_buf = TRUE;

protobuf_c_boolean protobuf_c_field_info_get_xml(
  const ProtobufCFieldInfo* finfo,
  ProtobufCCharBuffer* xml_buf)
{
  PROTOBUF_C_ASSERT(finfo);
  PROTOBUF_C_ASSERT(finfo->element);
  const ProtobufCFieldDescriptor *fdesc = finfo->fdesc;
  PROTOBUF_C_ASSERT(fdesc);

  PROTOBUF_C_ASSERT(xml_buf);
  ProtobufCInstance *instance =
      protobuf_c_instance_get(xml_buf->instance);

  PROTOBUF_C_INC_STATS(instance, fcall, get_finfo_txt);

  /*
   * Handle the easy cases first - all of the numbers are just stuffed
   * into fixed size buffer, without caring about some unused bytes.
   */
  char* retbuf = xml_buf->buffer;
  size_t retsize = xml_buf->buf_len;

  PROTOBUF_C_ASSERT (retbuf && retsize);

  int printlen = 0;
  double dbl;
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
      printlen = snprintf( retbuf, retsize, "%d", *(int32_t*)finfo->element );
      goto check_len;
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32:
      printlen = snprintf( retbuf, retsize, "%u", *(uint32_t*)finfo->element );
      goto check_len;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
      /* ATTN: Handle yang:decimal64 */
      printlen = snprintf( retbuf, retsize, "%" PRId64, *(int64_t*)finfo->element );
      goto check_len;
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64:
      /* ATTN: Handle yang:decimal64 */
      printlen = snprintf( retbuf, retsize, "%" PRIu64, *(uint64_t*)finfo->element );
      goto check_len;
    case PROTOBUF_C_TYPE_BOOL:
      /* ATTN: Handle yang:empty? */
      if (*(protobuf_c_boolean *)finfo->element) {
        printlen = snprintf( retbuf, retsize, "true" );
      } else {
        printlen = snprintf( retbuf, retsize, "false" );
      }
      goto check_len;

    case PROTOBUF_C_TYPE_DOUBLE:
      dbl = *(double*)finfo->element;
      goto handle_dbl;
    case PROTOBUF_C_TYPE_FLOAT:
      dbl = *(float*)finfo->element;
      goto handle_dbl;

    handle_dbl:
      /* ATTN: Handle yang:decimal64 */
      printlen = snprintf( retbuf, retsize, "%f", dbl );
      goto check_len;

    check_len:
      PROTOBUF_C_ASSERT(printlen > 0);
      PROTOBUF_C_ASSERT(printlen < (int)retsize);
      return TRUE;

    case PROTOBUF_C_TYPE_ENUM: {
      /* ATTN: This really needs to get the yang enum value, NOT the proto enum value! */
      const ProtobufCEnumDescriptor* edesc = fdesc->enum_desc;
      const ProtobufCEnumValue* enum_val
        = protobuf_c_enum_descriptor_get_value( edesc, *(int32_t*)finfo->element );
      if (NULL == enum_val) {
        // ATTN: At least treat as number?
        return FALSE;
      }

      size_t strsize = 1 + strlen(enum_val->name);
      if ( retsize < strsize ) {
        PROTOBUF_C_CHAR_BUF_ALLOC(xml_buf, instance, strsize);
        retbuf = xml_buf->buffer;
      }
      memcpy( retbuf, enum_val->name, strsize );
      return TRUE;
    }

    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_BYTES:
      /* may require ctype special handling */
      break;

    case PROTOBUF_C_TYPE_MESSAGE:
      PROTOBUF_C_MESSAGE_ERROR(
        instance, NULL, fdesc,
        "Attempted to convert message to string");
      return FALSE;

    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (PROTOBUF_C_TYPE_STRING == fdesc->type) {
    if (NULL == ctype) {

      size_t strsize = 1 + strlen( (char*)finfo->element );
      if ( retsize < strsize ) {
        PROTOBUF_C_CHAR_BUF_ALLOC(xml_buf, instance, strsize);
        retbuf = xml_buf->buffer;
      }
      memcpy( retbuf, finfo->element, strsize );
      return TRUE;
    }

    PROTOBUF_C_ASSERT(ctype->to_string);

    // Iterate until conversion succeeds or out of memory.
    while(1) {

      size_t new_retsize = retsize;
      protobuf_c_boolean ok = ctype->to_string( ctype, fdesc, finfo->element, &new_retsize, retbuf );
      if (ok) {
        break;
      }

      if (retsize < 1024*1024) {
        new_retsize = retsize * 4;
      } else {
        new_retsize = retsize * 2;
      }
      PROTOBUF_C_ASSERT(new_retsize > retsize);
      PROTOBUF_C_CHAR_BUF_ALLOC(xml_buf, instance, new_retsize);

      retbuf  = xml_buf->buffer;
      retsize = new_retsize;
    }

    return TRUE;
  }

  /* ATTN: yang:bits */

  PROTOBUF_C_ASSERT(PROTOBUF_C_TYPE_BYTES == fdesc->type);
  size_t binsize = finfo->len;
  void* binbuf = (void*)finfo->element;
  uint8_t stackbuf[16*1024];
  if (NULL == ctype) {
    goto b64_encode;
  }

  binbuf = stackbuf;
  binsize = sizeof(stackbuf);

  // Iterate until conversion to real bytes succeeds or out of memory.
  while(1) {
    size_t tmp_binsize = binsize;
    protobuf_c_boolean ok = ctype->to_string( ctype, fdesc, finfo->element, &tmp_binsize, binbuf );
    if (ok) {
      PROTOBUF_C_ASSERT(binsize >= tmp_binsize);
      binsize = tmp_binsize;
      break;
    }

    size_t new_binsize = binsize * 4;
    PROTOBUF_C_ASSERT(new_binsize > binsize);
    if (binbuf != (void*)&stackbuf) {
      do_free( instance, binbuf );
    }
    binbuf = do_alloc( instance, new_binsize );
    binsize = new_binsize;
  }

b64_encode:;
  size_t b64len = pbc_b64_get_encoded_str_len(binsize, 0);
  if ( retsize < b64len ) {
    PROTOBUF_C_CHAR_BUF_ALLOC(xml_buf, instance, b64len);
    retbuf = xml_buf->buffer;
  }
  uint32_t actsize = 0;
  protobuf_c_boolean ok = pbc_b64_encode( binbuf, binsize, retbuf, b64len, 0, &actsize );
  PROTOBUF_C_ASSERT(ok);
  PROTOBUF_C_ASSERT(actsize <= b64len);

  if (   binbuf != (void*)&stackbuf
      && binbuf != finfo->element) {
    do_free( instance, binbuf );
  }

  return TRUE;
}

protobuf_c_boolean
protobuf_c_field_get_text_value(ProtobufCInstance* instance,
                                const ProtobufCFieldDescriptor* fdesc,
                                char *value_str,
                                size_t *value_str_len, /* IN/OUT */
                                void *value)
{
  PROTOBUF_C_ASSERT(value_str);
  PROTOBUF_C_ASSERT(value_str_len);
  PROTOBUF_C_ASSERT(value);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, get_field_txt);

  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
    PROTOBUF_C_ASSERT(ctype->to_string);
    return ctype->to_string(ctype, fdesc, value, value_str_len, value_str);
  }

  size_t maxlen = *value_str_len;
  *value_str_len = 0;
  PROTOBUF_C_ASSERT(maxlen);
  value_str[0] = 0;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  int len = 0;
  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
      len = snprintf (value_str, maxlen, "%d", *((int32_t *)value));
      break;
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32:
      len = snprintf (value_str, maxlen, "%u",  *((uint32_t *)value));
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
      len = snprintf (value_str, maxlen, "%" PRId64 ,*((int64_t *)value));
      break;
    case PROTOBUF_C_TYPE_DOUBLE:
      len = snprintf (value_str, maxlen, "%f", *((double *)value));
      break;
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64:
      len = snprintf (value_str, maxlen, "%" PRIu64 "", *((uint64_t *)value));
      break;
    case PROTOBUF_C_TYPE_FLOAT:
      len = snprintf (value_str, maxlen, "%f", *((float *)value));
      break;
    case PROTOBUF_C_TYPE_BOOL:
      /// assumes that protobuf bools are tightly packed
      if (*(protobuf_c_boolean *) value) {
        len = snprintf (value_str, maxlen, "true");
      } else {
        len = snprintf (value_str, maxlen, "false");
      }
      break;
    case PROTOBUF_C_TYPE_ENUM: {
      const ProtobufCEnumValue *enum_val
          = protobuf_c_enum_descriptor_get_value(
              (const ProtobufCEnumDescriptor *)fdesc->descriptor, *((unsigned int *)value));
      if (enum_val) {
        len = snprintf (value_str, maxlen, "%s", enum_val->name);
      } else {
        return FALSE;
      }
      break;
    }
    case PROTOBUF_C_TYPE_STRING: {
      const char *string_to_print = (const char *)value;
      if (is_inline) {
        /* must be NUL-terminated! */
        PROTOBUF_C_ASSERT(string_to_print[fdesc->data_size-1] == '\0');
      }
      len = snprintf (value_str, maxlen, "%s", string_to_print);
      break;
    }
    case PROTOBUF_C_TYPE_BYTES:
      if (is_inline) {
        ProtobufCFlatBinaryData *data = (ProtobufCFlatBinaryData *)value;
        if (maxlen < data->len) {
          return FALSE;
        }
        memcpy(value_str, data->data, data->len);
        *value_str_len = data->len;
      } else {
        ProtobufCBinaryData *data = (ProtobufCBinaryData *)value;
        if (maxlen < data->len) {
          return FALSE;
        }
        memcpy(value_str, data->data, data->len);
        *value_str_len = data->len;
      }
      return TRUE;
    default:
      return FALSE;
  }
  if (len < 0 || len >= maxlen) {
    return FALSE;
  }
  *value_str_len = len;
  return TRUE;
}

static size_t
protobuf_c_message_get_field_count_and_start(const ProtobufCMessage *base,
                                             const ProtobufCFieldDescriptor* fdesc,
                                             void **flat,
                                             void **dynamic)
{
  uint16_t msg_count = 0;
  void *flat_ptr = NULL;
  void **ptr_ptr = NULL;
  const protobuf_c_boolean *qfier
      = (const protobuf_c_boolean *)((const char*)base + fdesc->quantifier_offset);

  uint32_t *oneof_case = NULL;
  if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
    oneof_case =  (uint32_t *)((const char*)base + fdesc->quantifier_offset);
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);

  switch (fdesc->type) {
    case PROTOBUF_C_TYPE_MESSAGE:
    case PROTOBUF_C_TYPE_STRING:
      switch (fdesc->label) {
        case PROTOBUF_C_LABEL_REPEATED:
          msg_count = *(const size_t*)qfier;
          if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
            flat_ptr = (char *) base + fdesc->offset;
          } else {
            ptr_ptr = *(void ***)((char *)base + fdesc->offset);
          }
          break;
        case PROTOBUF_C_LABEL_OPTIONAL:
          if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
            if (fdesc->quantifier_offset) {
              if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
                if (*oneof_case != fdesc->id) {
                  break; // This field is not set for oneof.
                }
              } else {
                if (!*qfier) {
                  break;
                }
              }
            }
          }
          /**** FALL THROUGH ****/
        case PROTOBUF_C_LABEL_REQUIRED:
          msg_count = 1;
          if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
            flat_ptr = (char *) base + fdesc->offset;
          } else {
            ptr_ptr = (void **)((char *)base + fdesc->offset);
            if (*ptr_ptr == NULL) {
              msg_count = 0;
            }
          }
          break;
        default:
          PROTOBUF_C_ASSERT_NOT_REACHED();
      }
      break;
    case PROTOBUF_C_TYPE_BYTES:
      switch (fdesc->label) {
        case PROTOBUF_C_LABEL_REPEATED:
          msg_count = *(const size_t*)qfier;

          if (fdesc->ctype) { // Ctypes and bytes rep are different.
            if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
              flat_ptr = (char *)base + fdesc->offset;
            } else {
              ptr_ptr = *(void ***)((char *)base + fdesc->offset);
            }
          } else {
            if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
              flat_ptr = (char *)base + fdesc->offset;
            } else {
              /* ATTN: This returns a different kind of pointer for bytes!
                 This API is dangerously inconsistent!
                 */
              ptr_ptr = (void **)((char *)base + fdesc->offset);
            }
          }
          break;
        case PROTOBUF_C_LABEL_OPTIONAL:
          if (fdesc->quantifier_offset) {
            if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
              if (*oneof_case != fdesc->id) {
                break; // This field is not set for oneof.
              }
            } else if (!*qfier) {
              break;
            }
          }
          /**** FALL THROUGH ****/
        case PROTOBUF_C_LABEL_REQUIRED:
          /*
             ATTN: This returns a different kind of pointer for bytes!
             This API is dangerously inconsistent!
           */
          msg_count = 1;
          flat_ptr = (char *) base + fdesc->offset;
          if (fdesc->ctype && !is_inline) {
            flat_ptr = NULL;
            ptr_ptr = (void **)((char *)base + fdesc->offset);
            if (*ptr_ptr == NULL) {
              msg_count = 0;
            }
          }
          break;
        default:
          PROTOBUF_C_ASSERT_NOT_REACHED();
      }
      break;
    default:
      // all other simple types
      switch (fdesc->label) {
        case PROTOBUF_C_LABEL_REPEATED:
          msg_count = *(const size_t*)qfier;
          if (fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
            flat_ptr = (char *)base + fdesc->offset;
          } else {
            ptr_ptr = (void **)((char *) base + fdesc->offset);
          }
          break;
        case PROTOBUF_C_LABEL_OPTIONAL:
          if (fdesc->quantifier_offset) {
            if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
              if (*oneof_case != fdesc->id) {
                break; // This field is not set for oneof.
              }
            } else if (!*qfier) {
              break;
            }
          }
          /**** FALL THROUGH ****/
        case PROTOBUF_C_LABEL_REQUIRED:
          msg_count = 1;
          flat_ptr = (char *)base + fdesc->offset;
          break;
        default:
          PROTOBUF_C_ASSERT_NOT_REACHED();
      }
      break;
  }

  *flat = flat_ptr;
  *dynamic = ptr_ptr;
  return msg_count;
}

size_t
protobuf_c_message_get_field_count(const ProtobufCMessage *base,
                                   const ProtobufCFieldDescriptor* fdesc)
{
  void *flat = 0, *dynamic = 0;

  size_t count = protobuf_c_message_get_field_count_and_start (base, fdesc, &flat, &dynamic);
  return count;
}

size_t
protobuf_c_message_get_field_count_and_offset(const ProtobufCMessage *base,
                                              const ProtobufCFieldDescriptor* fdesc,
                                              void **msg_ptr,
                                              size_t *offset,
                                              protobuf_c_boolean* array_of_ptrs)
{
  PROTOBUF_C_ASSERT(base);
  PROTOBUF_C_ASSERT(msg_ptr);
  PROTOBUF_C_ASSERT(offset);
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(array_of_ptrs);

  *offset = 0;
  *array_of_ptrs = FALSE;

  void *flat = NULL;
  void *dynamic = NULL;

  size_t count = protobuf_c_message_get_field_count_and_start (base, fdesc, &flat, &dynamic);

  if (0 == count) {
    return count;
  }

  if (flat) {
    *msg_ptr = flat;
  } else {
    *msg_ptr = *(void **)dynamic;
  }

  if (count < 2) {
    // no offset needs to be found.
    return count;
  }

  PROTOBUF_C_ASSERT(PROTOBUF_C_LABEL_REPEATED == fdesc->label);
  *offset = sizeof_elt_in_repeated_array(fdesc);
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);

  if (   !is_inline
      && (   PROTOBUF_C_TYPE_STRING == fdesc->type
          || PROTOBUF_C_TYPE_MESSAGE == fdesc->type
          || fdesc->ctype)) {
    /*
       ATTN: The way BYTES is handled here is screwy
     */
    *array_of_ptrs = TRUE;
    *msg_ptr = dynamic;
  }
  return count;
}

size_t
protobuf_c_message_get_field_desc_count_and_offset(const ProtobufCMessage *base,
                                                   unsigned field_tag,
                                                   const ProtobufCFieldDescriptor **fdesc,
                                                   void **msg_ptr,
                                                   size_t *offset,
                                                   protobuf_c_boolean* array_of_ptrs)
{
  PROTOBUF_C_ASSERT(base);
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(msg_ptr);
  PROTOBUF_C_ASSERT(offset);
  PROTOBUF_C_ASSERT(array_of_ptrs);

  *fdesc = NULL;
  *msg_ptr = NULL;
  *offset = 0;
  *array_of_ptrs = FALSE;

  *fdesc = protobuf_c_message_descriptor_get_field(base->descriptor, field_tag);

  if (!(*fdesc)) {
    return 0;
  }

  return protobuf_c_message_get_field_count_and_offset(base, *fdesc, msg_ptr, offset,
                                                array_of_ptrs);
}

protobuf_c_boolean
protobuf_c_message_get_field_instance(ProtobufCInstance *instance,
                                      const ProtobufCMessage *message,
                                      const ProtobufCFieldDescriptor *fdesc,
                                      unsigned repeated_index,
                                      ProtobufCFieldInfo *finfo)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(finfo);
  PROTOBUF_C_ASSERT(fdesc);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, get_field);

  finfo->fdesc = fdesc;
  finfo->len = 0;
  finfo->element = (char*)message + fdesc->offset;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  protobuf_c_boolean is_oneof = !!(fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF);
  size_t *qfier = (size_t*)((char*)message + fdesc->quantifier_offset);
  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

  // Make sure the desired field and index already exists (this
  // API does not create fields).
  switch (fdesc->label) {
    case PROTOBUF_C_LABEL_REPEATED:
      PROTOBUF_C_ASSERT(fdesc->quantifier_offset);
      if (repeated_index >= *qfier) {
        return FALSE;
      }
      if (is_inline) {
        finfo->element = (char*)finfo->element + sizeof_elt * repeated_index;
      } else {
        finfo->element = *(char**)finfo->element + sizeof_elt * repeated_index;
      }
      break;
    case PROTOBUF_C_LABEL_REQUIRED:
      if (repeated_index) {
        return FALSE;
      }
      if (PROTOBUF_C_TYPE_STRING  == fdesc->type ||
          PROTOBUF_C_TYPE_MESSAGE == fdesc->type ||
          NULL != fdesc->ctype) {
        if (!is_inline) {
          if (!*((void **)finfo->element)) {
            return FALSE;
          }
        }
      }
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      if (repeated_index) {
        return FALSE;
      }
      if (fdesc->quantifier_offset) {
        if (is_oneof) {
          if ((*(uint32_t*)qfier) != fdesc->id) {
            return FALSE;
          }
        } else {
          if (!*(protobuf_c_boolean*)qfier) {
            return FALSE;
          }
        }
      } else {
        if (!*(void**)finfo->element) {
          return FALSE;
        }
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
      return FALSE;
  }

  // Fixup ctype to point to the real element.  ctype is more special than proto type.
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
  if (ctype) {
    if (!is_inline) {
      finfo->element = *(void**)finfo->element;
    }
    return TRUE;
  }

  // Fixup pointy types to remove the indirection
  switch(fdesc->type) {
    case PROTOBUF_C_TYPE_STRING:
      if (!is_inline) {
        finfo->element = *(char**)finfo->element;
      }
      finfo->len = strlen((const char*)finfo->element);
      return TRUE;
    case PROTOBUF_C_TYPE_BYTES: {
      if (is_inline) {
        ProtobufCFlatBinaryData *bd = (ProtobufCFlatBinaryData*)finfo->element;
        finfo->len = bd->len;
        finfo->element = &bd->data[0];
      } else {
        ProtobufCBinaryData *bd = (ProtobufCBinaryData*)finfo->element;
        finfo->len = bd->len;
        finfo->element = bd->data;
      }
      return TRUE;
    }
    case PROTOBUF_C_TYPE_MESSAGE:
      if (!is_inline) {
        finfo->element = *(ProtobufCMessage**)finfo->element;
      }
      finfo->len = fdesc->msg_desc->sizeof_message;
      return TRUE;
    default:
      finfo->len = sizeof_elt;
      // Other types need no fixups.
      break;
  }

  return TRUE;
}


/* --- RIFT usability enhancements --- */

uint8_t *
protobuf_c_message_serialize(ProtobufCInstance* instance,
                             const ProtobufCMessage *message,
                             size_t *size)
{
  return protobuf_c_message_serialize_opts(
    instance,
    message,
    &protobuf_c_pack_opts_default,
    size);
}

uint8_t *
protobuf_c_message_serialize_opts(ProtobufCInstance* instance,
                                  const ProtobufCMessage *message,
                                  const ProtobufCPackOptions* opts,
                                  size_t *size)
{

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
#if 0
  if (!PROTOBUF_C_IS_MESSAGE(message)) {
    return NULL;
  }
#endif

  PROTOBUF_C_ASSERT(size);
  PROTOBUF_C_ASSERT(opts);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, serialize);

  *size = protobuf_c_message_get_packed_size_opts(message, opts);

  uint8_t* buf = (uint8_t*)do_alloc(instance, *size);
  size_t actual_size = protobuf_c_message_pack_opts(instance, message, opts, buf);

  PROTOBUF_C_ASSERT(actual_size == (*size));
  return buf;
}

static void
protobuf_c_message_copy_delta(ProtobufCInstance* instance,
                              const ProtobufCMessage *from,
                              ProtobufCMessage* to)
{
  PROTOBUF_C_ASSERT(from->descriptor == to->descriptor);

  if (PROTOBUF_C_MESSAGE_IS_DELTA(from)) {

    PROTOBUF_C_ASSERT(from->delete_delta);
    PROTOBUF_C_ASSERT(!PROTOBUF_C_MESSAGE_IS_DELTA(to));
    PROTOBUF_C_ASSERT(!to->unknown_buffer);

    to->delete_delta = protobuf_c_instance_alloc(
        instance, sizeof(ProtobufCDeleteDelta));

    to->delete_delta->me        = from->delete_delta->me;
    to->delete_delta->child_tag = from->delete_delta->child_tag;

    PROTOBUF_C_FLAG_SET(
        to->ref_hdr.magic_flags, UNKNOWN_BUFFER_UNION, PROTOBUF_C_FLAG_UNKNOWN_BUFFER_UNION_DELTA);

  } else {
    PROTOBUF_C_ASSERT(!from->unknown_buffer); // Should not have unknown fields
  }

  unsigned i = 0;
  for (i = 0; i < from->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor* fdesc = from->descriptor->fields + i;
    if (fdesc->type != PROTOBUF_C_TYPE_MESSAGE) {
      continue;
    }

    ProtobufCFieldInfo finfo1 = {NULL}, finfo2 = {NULL};
    for (size_t n = 0;
         protobuf_c_message_get_field_instance(instance, from, fdesc, n, &finfo1) &&
         protobuf_c_message_get_field_instance(instance, to, fdesc, n, &finfo2);
         ++n) {

      PROTOBUF_C_ASSERT(finfo1.element && finfo2.element);
      protobuf_c_message_copy_delta(instance, finfo1.element, (ProtobufCMessage*)finfo2.element);
    }
  }
}

static bool
protobuf_c_message_is_delta_deep(ProtobufCInstance* instance,
                                 const ProtobufCMessage* msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));

  if (PROTOBUF_C_MESSAGE_IS_DELTA(msg)) {
    return true;
  }

  unsigned i = 0;
  for (i = 0; i < msg->descriptor->n_fields; i++) {
    const ProtobufCFieldDescriptor* fdesc = msg->descriptor->fields + i;
    if (fdesc->type != PROTOBUF_C_TYPE_MESSAGE) {
      continue;
    }

    ProtobufCFieldInfo finfo = {NULL};
    for (size_t n = 0;
         protobuf_c_message_get_field_instance(instance, msg, fdesc, n, &finfo);
         ++n) {
      if (protobuf_c_message_is_delta_deep(instance, (const ProtobufCMessage*)finfo.element)) {
        return true;
      }
    }
  }

  return false;
}

// ATTN:- This is a temporary solution to allow copy of deltas
// until 4165 is fixed.
ProtobufCMessage*
protobuf_c_message_duplicate_allow_deltas(ProtobufCInstance* instance,
                                          const ProtobufCMessage *message,
                                          const ProtobufCMessageDescriptor *mdesc)
{
  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_ASSERT(instance);

  bool is_delta = protobuf_c_message_is_delta_deep(instance, message);

  ProtobufCPackOptions pack_opts = protobuf_c_pack_opts_default;
  if (is_delta) {
    PROTOBUF_C_ASSERT(message->descriptor == mdesc);
    pack_opts.discard_unknown = TRUE;
  }

  ProtobufCMessage *out = protobuf_c_message_duplicate_opts(
      instance, message, mdesc, &pack_opts);

  if (out && is_delta) {
    protobuf_c_message_copy_delta(instance, message, out);
  }

  return out;
}

uint8_t *
protobuf_c_message_serialize_append(ProtobufCInstance* instance,
                             const ProtobufCMessage *message,
                             uint8_t *in_buffer,
                             size_t *bsize)
{
  return protobuf_c_message_serialize_append_opts(
    instance,
    message,
    &protobuf_c_pack_opts_default,
    in_buffer,
    bsize);
}

uint8_t *
protobuf_c_message_serialize_append_opts(ProtobufCInstance* instance,
                                  const ProtobufCMessage *message,
                                  const ProtobufCPackOptions* opts,
                                  uint8_t *in_buffer,
                                  size_t *bsize)
{

  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
#if 0
  if (!PROTOBUF_C_IS_MESSAGE(message)) {
    return NULL;
  }
#endif

  PROTOBUF_C_ASSERT(opts);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, serialize);

  size_t append_size = protobuf_c_message_get_packed_size_opts(message, opts);

  uint8_t* buf = (uint8_t*)do_realloc(instance, in_buffer, *bsize+append_size);
  PROTOBUF_C_ASSERT(buf);
  size_t actual_size = protobuf_c_message_pack_opts(instance, message, opts, buf+*bsize);

  PROTOBUF_C_ASSERT(actual_size == append_size);
  *bsize += append_size;
  return buf;
}

ProtobufCMessage*
protobuf_c_message_duplicate(ProtobufCInstance* instance,
                             const ProtobufCMessage *message,
                             const ProtobufCMessageDescriptor *mdesc)
{
  return protobuf_c_message_duplicate_opts(
    instance,
    message,
    mdesc,
    &protobuf_c_pack_opts_default);
}

ProtobufCMessage*
protobuf_c_message_duplicate_opts(ProtobufCInstance* instance,
                                  const ProtobufCMessage *message,
                                  const ProtobufCMessageDescriptor *mdesc,
                                  const ProtobufCPackOptions* opts)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE_DESCRIPTOR(mdesc));
  PROTOBUF_C_ASSERT(opts);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, duplicate);

  uint8_t stackbuf[4096];
  uint8_t* buf = NULL;
  size_t size = protobuf_c_message_get_packed_size_opts(message, opts);
  if (size <= sizeof(stackbuf)) {
    buf = stackbuf;
  } else {
    buf = (uint8_t*)do_alloc(instance, size);
  }
  size_t actual_size = protobuf_c_message_pack_opts(instance, message, opts, buf);
  PROTOBUF_C_ASSERT(actual_size == size);

  ProtobufCMessage* out_msg = protobuf_c_message_unpack(instance, mdesc, size, buf);

  if (buf != stackbuf) {
    do_free(instance, buf);
  }

  return out_msg;
}

protobuf_c_boolean
protobuf_c_message_copy_usebody(ProtobufCInstance* instance,
                                const ProtobufCMessage *in_msg,
                                ProtobufCMessage *out_msg)
{
  return protobuf_c_message_copy_usebody_opts(
    instance,
    in_msg,
    &protobuf_c_pack_opts_default,
    out_msg);

}

protobuf_c_boolean
protobuf_c_message_copy_usebody_opts(ProtobufCInstance* instance,
                                     const ProtobufCMessage *in_msg,
                                     const ProtobufCPackOptions* opts,
                                     ProtobufCMessage *out_msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(in_msg));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(out_msg));
  PROTOBUF_C_ASSERT(opts);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, copy);

  uint8_t stackbuf[4096];
  uint8_t* buf = NULL;
  size_t size = protobuf_c_message_get_packed_size_opts(in_msg, opts);
  if (size <= sizeof(stackbuf)) {
    buf = stackbuf;
  } else {
    buf = (uint8_t*)do_alloc(instance, size);
  }
  size_t actual_size = protobuf_c_message_pack_opts(instance, in_msg, opts, buf);
  PROTOBUF_C_ASSERT(actual_size == size);

  ProtobufCMessage* dup_out = protobuf_c_message_unpack_usebody(
      instance, out_msg->descriptor, size, buf, out_msg);

  if (buf != stackbuf) {
    do_free(instance, buf);
  }

  return (dup_out == out_msg);
}

ProtobufCMessage *
protobuf_c_message_get_sub_message (const ProtobufCMessage *parent,
                                    unsigned int field_id,
                                    unsigned int index)
{
  PROTOBUF_C_ASSERT(parent->descriptor->n_fields >= field_id);
  const ProtobufCFieldDescriptor *fld = &parent->descriptor->fields[field_id];

  if (fld->type != PROTOBUF_C_TYPE_MESSAGE) {
    return NULL;
  }

  if (PROTOBUF_C_LABEL_REPEATED == fld->label) {
    unsigned int count = *((unsigned int *) ((char *)parent + fld->quantifier_offset));
    if (!count) {
      return NULL;
    }

    PROTOBUF_C_ASSERT(index < count);

    if (!(fld->rw_flags & RW_PROTOBUF_FOPT_INLINE)) {
      ProtobufCMessage **array_of_ptr =
          *(ProtobufCMessage ***)((char *)parent + fld->offset);
      return (array_of_ptr[index]);
    }
    return (ProtobufCMessage *)((char *)parent + fld->offset + fld->data_size * index);
  }

  if (!(fld->rw_flags & RW_PROTOBUF_FOPT_INLINE)) {
    return *((ProtobufCMessage **)((char *)parent + fld->offset));
  }

  return (ProtobufCMessage *)((char *)parent + fld->offset);
}

uint8_t
protobuf_c_message_is_field_present(ProtobufCMessage *parent,
                                    unsigned int index)
{
  const ProtobufCFieldDescriptor *fld = &parent->descriptor->fields[index];
  bool check_qntfr = false;

  switch (fld->label) {
    case PROTOBUF_C_LABEL_REQUIRED:
      return 1;
    case PROTOBUF_C_LABEL_REPEATED:
      check_qntfr = true;
      break;
    case PROTOBUF_C_LABEL_OPTIONAL:
      switch (fld->type) {
        case PROTOBUF_C_TYPE_STRING:
        case PROTOBUF_C_TYPE_BYTES:
        case PROTOBUF_C_TYPE_MESSAGE:
          if (fld->rw_flags & RW_PROTOBUF_FOPT_INLINE) {
            check_qntfr = true;
          }
          break;
        default:
          check_qntfr = true;
          break;
      }
      break;
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  if (check_qntfr) {
    if (*(unsigned int *) ((char *)parent + fld->quantifier_offset)) {
      return 1;
    }
    return 0;
  }

  char **value = (char **) ((char *)parent + fld->offset);
  if (*value) {
    return 1;
  }

  return 0;
}


static protobuf_c_boolean
protobuf_c_message_delete_unknown_field(ProtobufCInstance* instance,
                                        ProtobufCMessage *msg,
                                        unsigned field_number)
{
  ProtobufCMessageUnknownField *field_start = NULL;
  instance = protobuf_c_instance_get(instance);

  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  if (!msg->unknown_buffer) {
    return FALSE;
  }

  ProtobufCMessageUnknownFields* unk_buf = msg->unknown_buffer;
  unsigned n_unfields = unk_buf->n_unknown_fields;
  int start_index = -1, end_index = -1;

  int i = 0;
  while (i < n_unfields) {
    if (unk_buf->unknown_fields[i].base_.tag == field_number) {
      /* There could be multiple occurance of a field with same tag.
         (unknown repeated fields). */
      if (start_index == -1) {
        field_start = (unk_buf->unknown_fields + i);
        start_index = end_index = i;
      } else {
        end_index = i;
      }
    }

    if (field_start && (i > end_index || i+1 == n_unfields)) {
      // Delete the unknown-fields that are contiguous in one shot.
      unsigned n_cunf = (end_index - start_index + 1);
      for (unsigned j = 0; j < n_cunf; j++) {
        const ProtobufCMessageUnknownField *ufld = &field_start[j];

        switch (PROTOBUF_C_FLAG_GET(ufld->base_.unknown_flags, UNKNOWN_UNION_TYPE)) {
        case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED:
          do_free(instance, ufld->serialized.data);
          break;
        case PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_MESSAGE_CAST:
          protobuf_c_message_free_unpacked(instance, ufld->cmessage.message);
          break;
        default:
          PROTOBUF_C_ASSERT_NOT_REACHED();
        };

      }

      if (n_unfields - n_cunf) {
        // It is ok to pass zero size to memmove, memmove handles it.
        memmove(field_start, (field_start + n_cunf),
                (n_unfields - end_index -1)*sizeof(ProtobufCMessageUnknownField));
        n_unfields -= n_cunf;
      } else {
        do_free(instance, unk_buf->unknown_fields);
        do_free(instance, unk_buf);
        msg->unknown_buffer = NULL;
        return TRUE;
      }

      i = start_index + 1;
      start_index = end_index = -1;
      field_start = NULL;
      continue;
    }

    i++;
  }

  if (unk_buf->n_unknown_fields == n_unfields) {
    return FALSE; //Unknown field not present.
  }

  unk_buf->n_unknown_fields = n_unfields;
  return TRUE;
}

protobuf_c_boolean
protobuf_c_message_delete_field(ProtobufCInstance* instance,
                                ProtobufCMessage *msg,
                                unsigned field_number)
{
  PROTOBUF_C_ASSERT(msg);
  PROTOBUF_C_ASSERT(field_number);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, delete_field);

  const ProtobufCFieldDescriptor *fdesc
      = protobuf_c_message_descriptor_get_field(msg->descriptor, field_number);

  if ((fdesc == NULL) && (msg->unknown_buffer == NULL)) {
    // Field not present.
    PROTOBUF_C_MESSAGE_ERROR(instance, msg, NULL,
                             "Field descrptor is NULL or n_unknown_fields is zero");
    return FALSE;
  }

  if ((fdesc == NULL) && (msg->unknown_buffer)) {
    // Could be in unknown fields list.
    return protobuf_c_message_delete_unknown_field(instance, msg, field_number);
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;

  if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
    uint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, msg, fdesc->quantifier_offset);
    if (*oneof_case != fdesc->id) {
      PROTOBUF_C_MESSAGE_ERROR(instance, msg, fdesc,
                             "field is not set for oneof"); //FIXME
      return FALSE; // This field is not set for the oneof case.
    }
  }

  /*
   * Required fields cannot be deleted.  However, they can be reset to
   * the default, and pointy required fields can certainly have
   * non-standard values deleted, on the way to replacing them with other
   * values. So, allow "delete" of required fields.
   */
  protobuf_c_message_free_field(instance, msg, fdesc);
  protobuf_c_message_init_field(instance, msg, fdesc);
  return TRUE;
}

protobuf_c_boolean
protobuf_c_message_delete_field_index(ProtobufCInstance* instance,
                                      ProtobufCMessage *msg,
                                      unsigned field_number,
                                      unsigned index)
{
  const ProtobufCFieldDescriptor *fdesc = NULL;
  PROTOBUF_C_ASSERT(msg);

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, delete_field);

  fdesc = protobuf_c_message_descriptor_get_field(msg->descriptor, field_number);
  if ((fdesc == NULL) || (fdesc->label == PROTOBUF_C_LABEL_REQUIRED)){
    // Required field cannot be deleted.
    PROTOBUF_C_MESSAGE_ERROR(instance, msg, NULL,
                             "field descr is NULL or label is required");
    return FALSE;
  }

  if (fdesc->label == PROTOBUF_C_LABEL_OPTIONAL) {
    if (index != 0) {
      // Non zero index for optional field.
      PROTOBUF_C_MESSAGE_ERROR(instance, msg, NULL,
                               "Non zero index for optional field");
      return FALSE;
    } else {
      return (protobuf_c_message_delete_field(instance, msg, field_number));
    }
  }

  size_t n = STRUCT_MEMBER(size_t, msg, fdesc->quantifier_offset);
  if ((index < 0) || (index >= n)) {
    // Out-of-range index.
    PROTOBUF_C_MESSAGE_ERROR(instance, msg, fdesc,
                             "Out-of-range index");
    return FALSE;
  }

  protobuf_c_boolean is_inline = !!(fdesc->rw_flags&RW_PROTOBUF_FOPT_INLINE);
  char *arr;
  if (is_inline) {
    arr = (char*)STRUCT_MEMBER_P(msg, fdesc->offset);
  } else {
    arr = STRUCT_MEMBER(char *, msg, fdesc->offset);
    if (arr == NULL) {
      return FALSE;
    }
  }

  if ((is_inline) && (index >= fdesc->rw_inline_max)) {
    // Out-of-range index
    PROTOBUF_C_MESSAGE_ERROR(instance, msg, fdesc,
                             "Out-of-range index");
    return FALSE;
  }

  size_t sizeof_elt = sizeof_elt_in_repeated_array(fdesc);

  if (!is_inline) {
    const ProtobufCCTypeDescriptor *ctype = fdesc->ctype;
    if (ctype) {
      PROTOBUF_C_ASSERT(PROTOBUF_C_IS_COMPLEX_FIELD(fdesc));
      if (ctype->free_usebody) {
        ctype->free_usebody(instance, ctype, fdesc, ((void**)arr)[index]);
      }
      do_free(instance, ((void**)arr)[index]);
    } else {
      switch (fdesc->type) {
        case PROTOBUF_C_TYPE_STRING:
          do_free(instance, ((char **) arr)[index]);
          break;
        case PROTOBUF_C_TYPE_BYTES:
          do_free(instance, ((ProtobufCBinaryData *)arr)[index].data);
          break;
        case PROTOBUF_C_TYPE_MESSAGE:
          protobuf_c_message_free_unpacked(instance, ((ProtobufCMessage **)arr)[index]);
          break;
        default:
          break;
      }
    }
  }

  arr += (index * sizeof_elt);
  if (--n) {
    memmove(arr, (arr+sizeof_elt), ((n-index)*sizeof_elt));
  } else {
    if (!is_inline) {
      do_free(instance, STRUCT_MEMBER(void *, msg, fdesc->offset));
      STRUCT_MEMBER(void *, msg, fdesc->offset) = NULL;
    }
  }

  STRUCT_MEMBER(size_t, msg, fdesc->quantifier_offset) = n;
  return TRUE;
}

protobuf_c_boolean
protobuf_c_message_delete_unknown_all(ProtobufCInstance* instance,
                                      ProtobufCMessage *message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(message));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, delete_unknown);

  protobuf_c_message_free_unknown_all(instance, message);

  protobuf_c_boolean retval = TRUE;
  const ProtobufCMessageDescriptor *mdesc = message->descriptor;
  for (size_t f = 0; f < mdesc->n_fields; ++f) {
    const ProtobufCFieldDescriptor *fdesc = &mdesc->fields[f];
    if (fdesc->type != PROTOBUF_C_TYPE_MESSAGE) {
      continue;
    }
    ProtobufCFieldInfo finfo;
    for (size_t n = 0;
         protobuf_c_message_get_field_instance(instance, message, fdesc, n, &finfo);
         ++n) {
      protobuf_c_boolean ok
          = protobuf_c_message_delete_unknown_all(
              instance,
              (ProtobufCMessage*)finfo.element);
      retval = retval && ok;
    }
  }
  return retval;
}

int
protobuf_c_field_info_compare(
  const ProtobufCFieldInfo* a_finfo,
  const ProtobufCFieldInfo* b_finfo)
{
  PROTOBUF_C_ASSERT(a_finfo);
  PROTOBUF_C_ASSERT(b_finfo);
  const ProtobufCFieldDescriptor* a_fdesc = a_finfo->fdesc;
  const ProtobufCFieldDescriptor* b_fdesc = b_finfo->fdesc;
  PROTOBUF_C_ASSERT((NULL != a_fdesc) || (NULL != b_fdesc));

  // Types must match (or one type is implied).
  ProtobufCType type = (a_fdesc ? a_fdesc : b_fdesc)->type;
  PROTOBUF_C_ASSERT((NULL == b_fdesc) || (type == b_fdesc->type));

  switch (type) {
    case PROTOBUF_C_TYPE_INT32:
    case PROTOBUF_C_TYPE_SINT32:
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_UINT32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_BOOL:
    case PROTOBUF_C_TYPE_ENUM:
      PROTOBUF_C_ASSERT(a_finfo->element);
      PROTOBUF_C_ASSERT(b_finfo->element);
      return memcmp( a_finfo->element, b_finfo->element, sizeof(uint32_t) );

    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_SINT64:
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_UINT64:
    case PROTOBUF_C_TYPE_FIXED64:
      PROTOBUF_C_ASSERT(a_finfo->element);
      PROTOBUF_C_ASSERT(b_finfo->element);
      return memcmp( a_finfo->element, b_finfo->element, sizeof(uint64_t) );

    case PROTOBUF_C_TYPE_FLOAT:
      PROTOBUF_C_ASSERT(a_finfo->element);
      PROTOBUF_C_ASSERT(b_finfo->element);
      return memcmp( a_finfo->element, b_finfo->element, sizeof(float) );

    case PROTOBUF_C_TYPE_DOUBLE:
      PROTOBUF_C_ASSERT(a_finfo->element);
      PROTOBUF_C_ASSERT(b_finfo->element);
      return memcmp( a_finfo->element, b_finfo->element, sizeof(double) );

    case PROTOBUF_C_TYPE_STRING:
    case PROTOBUF_C_TYPE_BYTES:
      // Need to check ctype first
      break;

    default:
      // Not valid for PROTOBUF_C_TYPE_MESSAGE
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  ProtobufCInstance* instance = protobuf_c_instance_get(NULL);

  void* a_buf = NULL;
  void* b_buf = NULL;
  ProtobufCFieldInfo a_tmp_finfo;
  ProtobufCFieldInfo b_tmp_finfo;

  const ProtobufCCTypeDescriptor* a_ctype = a_fdesc ? a_fdesc->ctype : NULL;
  const ProtobufCCTypeDescriptor* b_ctype = b_fdesc ? b_fdesc->ctype : NULL;
  if (a_ctype || b_ctype) {
    const ProtobufCCTypeCompare a_compare = a_ctype ? a_ctype->compare : NULL;
    const ProtobufCCTypeCompare b_compare = b_ctype ? b_ctype->compare : NULL;

    // Compatible ctypes?
    if (   a_compare != NULL
        && a_compare == b_compare) {
      return a_compare( a_ctype, a_fdesc, a_finfo->element, b_finfo->element );
    }

    // Incompatible ctypes; have to convert to serialized representation.
    if (a_ctype) {
      PROTOBUF_C_ASSERT(a_ctype->get_packed_size);
      PROTOBUF_C_ASSERT(a_ctype->pack);
      a_tmp_finfo = *a_finfo;
      a_finfo = &a_tmp_finfo;

      a_tmp_finfo.len = a_ctype->get_packed_size( a_ctype, a_fdesc, a_finfo->element );
      a_buf = do_alloc( instance, a_tmp_finfo.len+1 );
      a_tmp_finfo.element = a_buf;

      size_t bytes = a_ctype->pack( a_ctype, a_fdesc, a_tmp_finfo.element, 0 );
      PROTOBUF_C_ASSERT(bytes == a_tmp_finfo.len);

      // String pack is not NUL-terminated. Add one, just in case.
      ((char*)a_tmp_finfo.element)[bytes] = 0;
    }

    if (b_ctype) {
      PROTOBUF_C_ASSERT(b_ctype->get_packed_size);
      PROTOBUF_C_ASSERT(b_ctype->pack);
      b_tmp_finfo = *b_finfo;
      b_finfo = &b_tmp_finfo;

      b_tmp_finfo.len = b_ctype->get_packed_size( b_ctype, b_fdesc, b_finfo->element );
      b_buf = do_alloc( instance, b_tmp_finfo.len+1 );
      b_tmp_finfo.element = b_buf;

      size_t bytes = b_ctype->pack( b_ctype, b_fdesc, b_tmp_finfo.element, 0 );
      PROTOBUF_C_ASSERT(bytes == b_tmp_finfo.len);

      // String pack is not NUL-terminated. Add one, just in case.
      ((char*)b_tmp_finfo.element)[bytes] = 0;
    }
  }

  int rc = 0;
  if (PROTOBUF_C_TYPE_STRING == type) {
    rc = strcmp( a_finfo->element, b_finfo->element );
  } else {
    PROTOBUF_C_ASSERT(PROTOBUF_C_TYPE_BYTES == type);
    size_t len = a_finfo->len < b_finfo->len ? a_finfo->len : b_finfo->len;
    rc = memcmp( a_finfo->element, b_finfo->element, len );
    if (0 == rc) {
      // Prefix match. Go by number of bytes.
      rc = (int)a_finfo->len - (int)b_finfo->len;
    }
  }

  do_free( instance, a_buf );
  do_free( instance, b_buf );
  return rc;
}

static int
compare_field_counted(
    ProtobufCInstance *instance,
    const ProtobufCMessage *a_msg,
    const ProtobufCFieldDescriptor *a_fdesc,
    const ProtobufCMessage *b_msg,
    const ProtobufCFieldDescriptor *b_fdesc,
    size_t start_index,
    size_t limit_index,
    size_t* compare_fail_index)
{
  PROTOBUF_C_ASSERT(instance);
  PROTOBUF_C_ASSERT(a_msg);
  PROTOBUF_C_ASSERT(a_fdesc);
  PROTOBUF_C_ASSERT(b_msg);
  PROTOBUF_C_ASSERT(b_fdesc);
  
  for (size_t i = start_index; i < limit_index; ++i) {
    ProtobufCFieldInfo a_finfo;
    protobuf_c_boolean a_ok = protobuf_c_message_get_field_instance(
      instance, a_msg, a_fdesc, i, &a_finfo );

    ProtobufCFieldInfo b_finfo;
    protobuf_c_boolean b_ok = protobuf_c_message_get_field_instance(
      instance, b_msg, b_fdesc, i, &b_finfo );

    int rc = (int)!!a_ok - (int)!!b_ok;
    if (a_ok && b_ok) {
      rc = protobuf_c_field_info_compare( &a_finfo, &b_finfo );
    }

    if (rc) {
      if (compare_fail_index) {
        *compare_fail_index = i;
        return rc;
      }
    }
  }

  // No differences.
  return 0;
}

static void
update_diff_state(const ProtobufCMessage *msg,
                  const ProtobufCFieldDescriptor *desc,
                  ProtobufCDiffLocation *loc,
                  size_t list_index)
{
  loc->fld_info.fdesc = desc;

  if (loc->fld_info.fdesc) {
    protobuf_c_boolean is_inline = !!(desc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
    size_t sizeof_elt = sizeof_elt_in_repeated_array(desc);
    void *data = STRUCT_MEMBER_PTR(void, msg, desc->offset);

    // FieldInfo element directly points to the data
    // Client code can directly dereference the generic pointer
    // as per the data type.
    switch (desc->label) {
      case PROTOBUF_C_LABEL_REPEATED:
        if (desc->type == PROTOBUF_C_TYPE_STRING) {
          if (is_inline) {
            loc->fld_info.element = (char*)data + list_index * sizeof_elt;
          } else {
            data = *(char**)data + list_index * sizeof_elt;
            loc->fld_info.element = *(char**)data;
          }
        } else {
          loc->fld_info.element = (char*)data + list_index * sizeof_elt;
        }
        break;
      default:
        if (desc->type == PROTOBUF_C_TYPE_STRING) {
          if (is_inline) {
            loc->fld_info.element = data;
          } else {
            loc->fld_info.element = *(char**)data;
          }
        } else {
          loc->fld_info.element = data;
        }
    };

    // Length is populated only for BYTES type.
    if (desc->type == PROTOBUF_C_TYPE_BYTES) {
      if (is_inline) {
        loc->fld_info.len = ((ProtobufCFlatBinaryData*)loc->fld_info.element)->len;
      } else {
        loc->fld_info.len = ((ProtobufCBinaryData*)loc->fld_info.element)->len;
      }
    }
  }

  loc->message = msg;
  loc->list_index = list_index;

  return;
}


/*
 * Internal structures and API for stack
 */

typedef enum LastStackedLoc {
  DEFAULT,
  DURING_FIELD_ONLY,
  DURING_REPEATED_ONLY,
} LastStackedLoc;


typedef struct ProtobufCDiffStkData {
  const ProtobufCMessage *message;
} ProtobufCDiffStkData;


typedef struct ProtobufCDiffStkNode {
  ProtobufCDiffStkData a;
  ProtobufCDiffStkData b;
  int32_t fld_index;
  int32_t list_index; // index within the list
  LastStackedLoc loc;
} ProtobufCDiffStkNode;


// An intrusive stack for
// storing diff info in nested
// messages
typedef struct DiffStack {
  ProtobufCDiffStkNode stk[RW_DIFF_MAX_STACK_SIZE];
  size_t elems;
}DiffStack;



/*
 * Functions acting on the stack
 */
static void
diff_stack_init(DiffStack *stkptr) {
  stkptr->elems = 0;
  memset(&stkptr->stk[0], 0, sizeof(stkptr->stk));
}

static size_t
diff_stack_get_elems(const DiffStack *stkptr) {
  return stkptr->elems;
}

static bool
diff_stack_is_empty(const DiffStack *stkptr) {
  return stkptr->elems == 0;
}

static void
diff_stack_push(DiffStack *stkptr, ProtobufCDiffStkNode data)
{
  PROTOBUF_C_ASSERT(stkptr->elems != RW_DIFF_MAX_STACK_SIZE);
  uint32_t elems = stkptr->elems;

  stkptr->stk[elems] = data;
  stkptr->elems++;
}

static ProtobufCDiffStkNode*
diff_stack_peek(DiffStack *stkptr)
{
  uint32_t elems = stkptr->elems;
  return &stkptr->stk[elems - 1];
}

static void
diff_stack_pop(DiffStack *stkptr)
{
  if (stkptr->elems == 0) return;
  stkptr->elems--;
}

static ProtobufCDiffStkNode*
diff_stack_get_elem_at(DiffStack *stkptr, int32_t idx)
{
  if (idx > (stkptr->elems - 1) ||
      idx < 0) {
    return NULL;
  }
  return &stkptr->stk[idx];
}

static void
emplace_data_on_stack(DiffStack *stkptr,
                      const ProtobufCMessage *a_msg,
                      const ProtobufCMessage *b_msg)
{
  PROTOBUF_C_ASSERT(stkptr->elems != RW_DIFF_MAX_STACK_SIZE);
  uint32_t elems = stkptr->elems;

  stkptr->stk[elems].a.message = a_msg;
  stkptr->stk[elems].b.message = b_msg;

  stkptr->stk[elems].fld_index = -1;
  stkptr->stk[elems].list_index = -1;
  stkptr->stk[elems].loc = DEFAULT;

  stkptr->elems++;
}


static void
diff_stack_update_top_location(DiffStack *stkptr,
                               int32_t fld_index,
                               int32_t list_index,
                               LastStackedLoc loc)
{
  ProtobufCDiffStkNode *node = diff_stack_peek(stkptr);
  node->fld_index = fld_index;
  node->list_index = list_index;
  node->loc = loc;
}


// Private State maintained during iteration
typedef union ProtobufCDiffStatePrivate {

  struct ProtobufCDiffStateImpl {
    ProtobufCDiffStatus status;
    ProtobufCInstance *instance;
    const ProtobufCMessage *a_msg;
    const ProtobufCMessage *b_msg;
    ProtobufCDiffOptions opts;
    ProtobufCDiffLocation a_loc;
    ProtobufCDiffLocation b_loc;
    ProtobufCDiffInfo diff_info;
    //ATTN: This could be on heap as well
    DiffStack stk;
  } ist;

  // ATTN: Need some kind of static_assert
  // here
  char opaque[RW_DIFF_STATE_SIZE];

} ProtobufCDiffStatePrivate;

#undef UPDATE_MESSAGE_STATE
#define UPDATE_MESSAGE_STATE(reason)                      \
    update_diff_state(a_msg, a_fdesc,    \
        &state->ist.a_loc, last_list_index);              \
    update_diff_state(b_msg, b_fdesc,    \
        &state->ist.b_loc, last_list_index);              \
    state->ist.diff_info.mismatch_reason = reason;

/* This function does a DFS on the protobuf
 * message till it finds a mismatch, at which point
 * it saves the stack and returns the mimatched entry
 * to the caller.
 * The saved stack is used to continue from the next
 * valid field within the protobuf message
 */
static size_t
protobuf_c_message_diff_int_impl(
        ProtobufCDiffStatePrivate *state)
{
  DiffStack *stk = &state->ist.stk;

  if (diff_stack_is_empty(stk)) {
    emplace_data_on_stack(stk, state->ist.a_msg,
                          state->ist.b_msg);
  }

  while (!diff_stack_is_empty(stk)) {
    ProtobufCDiffStkNode* node = diff_stack_peek(stk);
    LastStackedLoc loc = node->loc;

    const ProtobufCMessage *a_msg = node->a.message;
    const ProtobufCMessage *b_msg = node->b.message;
    const ProtobufCMessageDescriptor *a_desc = a_msg->descriptor;
    const ProtobufCMessageDescriptor *b_desc = b_msg->descriptor;

    int32_t last_fld_no = node->fld_index;
    size_t last_list_index = node->list_index;
    size_t fail_index = 0;

    // Figure out where exactly we were last time
    uint32_t min_fields = PROTOBUF_C_MIN(a_desc->n_fields, b_desc->n_fields);

    switch (loc) {
      case DEFAULT:
        last_fld_no++;
        last_list_index++;
        break;
      case DURING_FIELD_ONLY:
        last_fld_no++;
        break;
      case DURING_REPEATED_ONLY:
        last_list_index++;
        break;
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }

    if (last_fld_no < min_fields) {
      const ProtobufCFieldDescriptor *a_fdesc = &a_desc->fields[last_fld_no];
      const ProtobufCFieldDescriptor *b_fdesc = &b_desc->fields[last_fld_no];

      size_t a_count = protobuf_c_message_get_field_count(a_msg, a_fdesc);
      size_t b_count = protobuf_c_message_get_field_count(b_msg, b_fdesc);

      protobuf_c_boolean is_inline = !!(a_fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
      ProtobufCMessage *a_inner_msg = NULL, *b_inner_msg = NULL;

      switch (a_fdesc->label) {
        case PROTOBUF_C_LABEL_OPTIONAL:
          if (0 != (a_fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
            //TODO: Handle oneof
            PROTOBUF_C_ASSERT_NOT_REACHED();
          }

          if (a_count != b_count) {
            UPDATE_MESSAGE_STATE(PROTOBUF_C_FIELD_EXIST_MISMATCH);
            diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
            return 1;
          }

          if (a_count == 0) {
            // Dont bother checking their differences
            diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
            continue;
          }
          // FALLTHROUGH

        case PROTOBUF_C_LABEL_REQUIRED:
          if (PROTOBUF_C_TYPE_MESSAGE == a_fdesc->type) {
            a_inner_msg = protobuf_c_message_get_sub_message(a_msg, last_fld_no, 0);
            b_inner_msg = protobuf_c_message_get_sub_message(b_msg, last_fld_no, 0);

            diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
            emplace_data_on_stack(stk, a_inner_msg, b_inner_msg);
            continue;
          }

          if (0 != compare_field_counted( state->ist.instance,
                     a_msg, a_fdesc,
                     b_msg, b_fdesc,
                     0, 1, &fail_index)) {
            UPDATE_MESSAGE_STATE(PROTOBUF_C_FIELD_VALUE_MISMATCH);
            diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
            return 1;
          }

          diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
          continue;

        case PROTOBUF_C_LABEL_REPEATED:
          a_count = protobuf_c_message_get_field_count(a_msg, a_fdesc);
          b_count = protobuf_c_message_get_field_count(b_msg, b_fdesc);
          size_t min_count = PROTOBUF_C_MIN(a_count, b_count);

          if (PROTOBUF_C_TYPE_MESSAGE == a_fdesc->type) {
            if (last_list_index < min_count) {
              a_inner_msg = protobuf_c_message_get_sub_message(a_msg, last_fld_no, last_list_index);
              b_inner_msg = protobuf_c_message_get_sub_message(b_msg, last_fld_no, last_list_index);

              diff_stack_update_top_location(stk, last_fld_no, last_list_index, DURING_REPEATED_ONLY);
              emplace_data_on_stack(stk, a_inner_msg, b_inner_msg);
            } else {
              diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
            }
            continue;
          }

          PROTOBUF_C_ASSERT(last_list_index <= min_count);
          if (0 != compare_field_counted( state->ist.instance,
                     a_msg, a_fdesc,
                     b_msg, b_fdesc,
                     last_list_index, min_count, &last_list_index)) {
              UPDATE_MESSAGE_STATE(PROTOBUF_C_FIELD_VALUE_MISMATCH);
              // Update the top stack so as to start from here
              // for the 'next' call
              // Note that we are updating the location as 'REPEATED'
              // otherwise in the next interation it will go on for
              // the next field in the message
              diff_stack_update_top_location(stk, last_fld_no, last_list_index, DURING_REPEATED_ONLY);
              return 1;
          }

          // Since we are comparing the whole array at a time,
          // we need to update the FIELD in the next iteration
          diff_stack_update_top_location(stk, last_fld_no, 0, DURING_FIELD_ONLY);
          continue;

        default:
          PROTOBUF_C_ASSERT_NOT_REACHED();
      }
    }
    diff_stack_pop(stk);
  }

  return 0;
}
#undef UPDATE_MESSAGE_STATE

static size_t
protobuf_c_message_diff_int(
              ProtobufCDiffStatePrivate *state)
{
  return protobuf_c_message_diff_int_impl(state);
}

void
protobuf_c_diff_start(ProtobufCInstance *instance,
                      protobuf_c_diff_state_t *st,
                      const ProtobufCMessage *a_msg,
                      const ProtobufCMessage *b_msg,
                      const ProtobufCDiffOptions opts)
{
  // This should ideally be compile time assert
  PROTOBUF_C_ASSERT(sizeof(protobuf_c_diff_state_t) >= sizeof(ProtobufCDiffStatePrivate));
  PROTOBUF_C_ASSERT(st);
  PROTOBUF_C_ASSERT(a_msg);
  PROTOBUF_C_ASSERT(b_msg);
  PROTOBUF_C_ASSERT(a_msg->descriptor == b_msg->descriptor);

  PROTOBUF_C_ASSERT((opts.diff_opts & PROTOBUF_C_DIFF_STOP_AT_FIRST) ||
                    (opts.diff_opts & PROTOBUF_C_DIFF_FIND_ALL));
  // Both flags must not be on
  PROTOBUF_C_ASSERT(!((opts.diff_opts & PROTOBUF_C_DIFF_STOP_AT_FIRST) &&
                     (opts.diff_opts & PROTOBUF_C_DIFF_FIND_ALL)));

  // Initialize the state
  memset(st, 0, RW_DIFF_STATE_SIZE);
  ProtobufCDiffStatePrivate *state = NULL;
  state = (ProtobufCDiffStatePrivate*)st;

  state->ist.status = PROTOBUF_C_DIFF_STATUS_INIT;
  state->ist.instance = protobuf_c_instance_get(instance);
  state->ist.a_msg = a_msg;
  state->ist.b_msg = b_msg;
  state->ist.opts = opts;
  state->ist.diff_info.a = &state->ist.a_loc;
  state->ist.diff_info.b = &state->ist.b_loc;
  state->ist.diff_info.mismatch_reason = PROTOBUF_C_NO_MISMATCH;
  diff_stack_init(&state->ist.stk);

  return;
}

const ProtobufCDiffInfo*
protobuf_c_diff_next(
        protobuf_c_diff_state_t *st)
{
  PROTOBUF_C_ASSERT(st);

  size_t ret_code = 0;
  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;

  PROTOBUF_C_ASSERT((state->ist.status == PROTOBUF_C_DIFF_STATUS_ACTIVE ||
                     state->ist.status == PROTOBUF_C_DIFF_STATUS_INIT));

  bool stop_at_first = !!(state->ist.opts.diff_opts & PROTOBUF_C_DIFF_STOP_AT_FIRST);

  if (stop_at_first && state->ist.status == PROTOBUF_C_DIFF_STATUS_ACTIVE) {
    return NULL;
  }

  if (state->ist.status == PROTOBUF_C_DIFF_STATUS_INIT) {
    state->ist.status = PROTOBUF_C_DIFF_STATUS_ACTIVE;
  }

  ret_code = protobuf_c_message_diff_int(state);

  if (ret_code) {
    return &state->ist.diff_info;
  }

  // Check for unknown fields
  // ATTN: Only checking unknown fields for a_msg which
  // is the target protobuf message
  if (state->ist.a_msg->unknown_buffer) {

    update_diff_state(state->ist.a_msg, NULL,
          &state->ist.a_loc, 0);
    state->ist.a_loc.fld_info.element = state->ist.a_msg->unknown_buffer->unknown_fields;
    state->ist.a_loc.fld_info.len = state->ist.a_msg->unknown_buffer->n_unknown_fields;

    update_diff_state(state->ist.b_msg, NULL,
        &state->ist.a_loc, 0);

    state->ist.b_loc.fld_info.element = NULL;
    state->ist.b_loc.fld_info.len = 0;

    if (state->ist.b_msg->unknown_buffer) {
      state->ist.b_loc.fld_info.element = state->ist.b_msg->unknown_buffer->unknown_fields;
      state->ist.b_loc.fld_info.len = state->ist.b_msg->unknown_buffer->n_unknown_fields;
    }

    state->ist.diff_info.mismatch_reason = PROTOBUF_C_UNKNOWN_FIELDS_MISMATCH;

    // No more difference can be found from here.
    // Moving the state machine to next state.
    state->ist.status = PROTOBUF_C_DIFF_STATUS_DONE;

    return &state->ist.diff_info;
  }

  return NULL;
}


protobuf_c_boolean
protobuf_c_diff_done(
        protobuf_c_diff_state_t *st)
{
  PROTOBUF_C_ASSERT(st);
  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;

  // Since we have not allocated anything on heap
  // we don have to deallocate anything.
  // If in future we do allocate, then manage
  // freeing of resources here.
  memset(st, 0, RW_DIFF_STATE_SIZE);
  state->ist.status = PROTOBUF_C_DIFF_STATUS_DONE;

  return TRUE;
}



protobuf_c_boolean
protobuf_c_diff_iter_init(ProtobufCMessage *msg,
                          ProtobufCDiffIterRes *iter,
                          protobuf_c_diff_state_t *st)
{
  PROTOBUF_C_ASSERT(iter);
  PROTOBUF_C_ASSERT(st);

  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;

  if (!(state->ist.status == PROTOBUF_C_DIFF_STATUS_ACTIVE ||
    state->ist.status == PROTOBUF_C_DIFF_STATUS_INIT)) {
    return FALSE;
  }

  iter->magic = PROTOBUF_C_DIFF_ITER_INITIALIZER;
  iter->result.message = NULL;
  iter->visited_elem = -1;
  iter->msg_order = TRUE;

  // Get the first element from the stack
  ProtobufCDiffStkNode *stk_node = diff_stack_get_elem_at(&state->ist.stk, 0);

  if (stk_node == NULL) {
    return FALSE;
  }

  if (msg == stk_node->a.message) {
    iter->msg_order = TRUE;
  } else if (msg == stk_node->b.message) {
    iter->msg_order = FALSE;
  } else {
    PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  return TRUE;
}

protobuf_c_boolean
protobuf_c_diff_iter_change_path_up(ProtobufCDiffIterRes *iter,
                                    protobuf_c_diff_state_t *st)
{
  PROTOBUF_C_ASSERT(iter);
  PROTOBUF_C_ASSERT(st);
  PROTOBUF_C_ASSERT(iter->magic == PROTOBUF_C_DIFF_ITER_INITIALIZER);

  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;

  ProtobufCDiffStkNode *stk_node =
                diff_stack_get_elem_at(&state->ist.stk,
                                       iter->visited_elem + 1);

  if (stk_node == NULL) {
    iter->result.message = NULL;
    return FALSE;
  }

  ProtobufCDiffLocation loc;

  if (iter->msg_order) {
    iter->result.message = stk_node->a.message;
  } else {
    iter->result.message = stk_node->b.message;
  }

  update_diff_state(iter->result.message,
                                  &iter->result.message->descriptor->fields[stk_node->fld_index],
                                  &loc,
                                  stk_node->list_index);

  iter->result.fld_info = loc.fld_info;
  iter->result.list_index = stk_node->list_index;

  iter->visited_elem++;

  return TRUE;
}

protobuf_c_boolean
protobuf_c_diff_iter_change_path_down(ProtobufCDiffIterRes *iter,
                                      protobuf_c_diff_state_t *st)
{
  PROTOBUF_C_ASSERT(iter);
  PROTOBUF_C_ASSERT(st);
  PROTOBUF_C_ASSERT(iter->magic == PROTOBUF_C_DIFF_ITER_INITIALIZER);

  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;

  ProtobufCDiffStkNode *stk_node =
                diff_stack_get_elem_at(&state->ist.stk,
                                       iter->visited_elem - 1);

  if (stk_node == NULL) {
    iter->result.message = NULL;
    return FALSE;
  }

  ProtobufCDiffLocation loc;

  if (iter->msg_order) {
    iter->result.message = stk_node->a.message;
    update_diff_state(stk_node->a.message,
                                    &stk_node->a.message->descriptor->fields[stk_node->fld_index],
                                    &loc,
                                    stk_node->list_index);
  } else {
    iter->result.message = stk_node->b.message;
    update_diff_state(stk_node->b.message,
                                    &stk_node->b.message->descriptor->fields[stk_node->fld_index],
                                    &loc,
                                    stk_node->list_index);
  }

  iter->result.fld_info = loc.fld_info;
  iter->result.list_index = stk_node->list_index;

  iter->visited_elem--;

  return TRUE;
}


static size_t
protobuf_print_value(const ProtobufCFieldInfo *finfo,
                     char *buffer,
                     size_t max_write_size)
{
  PROTOBUF_C_ASSERT(finfo);
  PROTOBUF_C_ASSERT(buffer);

  if (!finfo->fdesc) return 0;

  size_t byte_len = 0;
  size_t written = 0;

  switch (finfo->fdesc->type) {
  case PROTOBUF_C_TYPE_INT32:
  case PROTOBUF_C_TYPE_SINT32:
  case PROTOBUF_C_TYPE_SFIXED32:
  case PROTOBUF_C_TYPE_FIXED32:
  case PROTOBUF_C_TYPE_BOOL:
  case PROTOBUF_C_TYPE_ENUM:
    written += snprintf(buffer, max_write_size, "%d", *(int32_t*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_UINT32:
    written += snprintf(buffer, max_write_size, "%u", *(uint32_t*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_INT64:
  case PROTOBUF_C_TYPE_SINT64:
  case PROTOBUF_C_TYPE_SFIXED64:
  case PROTOBUF_C_TYPE_FIXED64:
    written += snprintf(buffer, max_write_size, "%" PRId64, *(int64_t*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_UINT64:
    written += snprintf(buffer, max_write_size, "%" PRIu64, *(uint64_t*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_FLOAT:
    written += snprintf(buffer, max_write_size, "%f", *(float*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_DOUBLE:
    written += snprintf(buffer, max_write_size, "%lf", *(double*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_STRING:
    written += snprintf(buffer, max_write_size, "%s", (char*)finfo->element);
    break;
  case PROTOBUF_C_TYPE_BYTES:
    byte_len = PROTOBUF_C_MIN(max_write_size, finfo->len);
    written += snprintf(buffer, byte_len, "%02X", (char*)finfo->element);
    break;
  default:
    written += snprintf(buffer, max_write_size, "%s : %d", "Unknown type", finfo->fdesc->type);
  };

  return written;
}

protobuf_c_boolean
protobuf_c_diff_print_str(protobuf_c_diff_state_t *st,
                          protobuf_c_diff_print_buffer_t *print_buffer)
{
  PROTOBUF_C_ASSERT(st);
  PROTOBUF_C_ASSERT(print_buffer);

  ProtobufCDiffStatePrivate *state = (ProtobufCDiffStatePrivate*)st;
  PROTOBUF_C_ASSERT(state->ist.status = PROTOBUF_C_DIFF_STATUS_ACTIVE);

  const ProtobufCDiffInfo *di = &state->ist.diff_info;
  size_t written = 0;
  uint8_t* buffer = (uint8_t*)print_buffer;

  /*
   * Diff string format
   * <-Reason-><-Msg A fdesc name-><-Msg B fdesc name -><-Msg A value -><-Msg B value ->
   * 20 bytes         20 bytes          20 bytes           150 bytes       150 bytes
   */

  memset(buffer, 0, RW_DIFF_MAX_DIFF_PRINT_SIZE);
  const char *reason = NULL;

  // Provide mismatch reason
  switch (di->mismatch_reason) {
  case PROTOBUF_C_FIELD_VALUE_MISMATCH:
    reason = "ValueMismatch";
    break;
  case PROTOBUF_C_FIELD_EXIST_MISMATCH:
    reason = "OptionalMismatch";
    break;
  case PROTOBUF_C_NO_MISMATCH:
    reason = "NoMismatch";
    break;
  case PROTOBUF_C_UNKNOWN_FIELDS_MISMATCH:
    reason = "UnknownField";
    break;
  default:
    reason = "Unknown";
  };

  written += snprintf(buffer + written, 20, "%s;", reason);

  // Provide Field name for Message A
  written += snprintf(buffer + written, 20, "%s;", di->a->fld_info.fdesc->name);

  // Provide Field name for Message B
  written += snprintf(buffer + written, 20, "%s;", di->b->fld_info.fdesc->name);

  // Provide Field value for Message A
  char tmp[150] = {0,};
  protobuf_print_value(&di->a->fld_info, tmp, 150 - 1);
  written += snprintf(buffer + written, 150, "%s;", tmp);

  // Provide Field value for Message B
  memset(&tmp[0], 0, sizeof(tmp));
  protobuf_print_value(&di->b->fld_info, tmp, 150 - 1);
  written += snprintf(buffer + written, 150, "%s;", tmp);

  return TRUE;
}


protobuf_c_boolean
protobuf_c_message_is_equal_deep(
  ProtobufCInstance* instance,
  const ProtobufCMessage *a_msg,
  const ProtobufCMessage *b_msg)
{
  return protobuf_c_message_is_equal_deep_opts(instance, a_msg, b_msg,
          &protobuf_c_pack_opts_default);
}


protobuf_c_boolean
protobuf_c_message_is_equal_deep_opts(
  ProtobufCInstance* instance,
  const ProtobufCMessage *a_msg,
  const ProtobufCMessage *b_msg,
  const ProtobufCPackOptions* opts)
{
  /* ATTN: Reimplement in terms of diff() */
  /* ATTN: Reimplement to compare without serializing */

  if (!PROTOBUF_C_IS_MESSAGE(a_msg)) {
    return FALSE;
  }
  if (!PROTOBUF_C_IS_MESSAGE(b_msg)) {
    return FALSE;
  }

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, is_equal);

  uint8_t a_stackbuf[4096];
  uint8_t* a_buf = NULL;
  size_t a_size = protobuf_c_message_get_packed_size_opts(a_msg, opts);

  if (a_size <= sizeof(a_stackbuf)) {
    a_buf = a_stackbuf;
  } else {
    a_buf = (uint8_t*)do_alloc(instance, a_size);
  }
  size_t actual_size = protobuf_c_message_pack_opts(instance, a_msg, opts, a_buf);
  PROTOBUF_C_ASSERT(actual_size == a_size);

  uint8_t b_stackbuf[4096];
  uint8_t* b_buf = NULL;
  size_t b_size = protobuf_c_message_get_packed_size_opts(b_msg, opts);
  if (b_size <= sizeof(b_stackbuf)) {
    b_buf = b_stackbuf;
  } else {
    b_buf = (uint8_t*)do_alloc(instance, b_size);
  }
  actual_size = protobuf_c_message_pack_opts(instance, b_msg, opts, b_buf);
  PROTOBUF_C_ASSERT(actual_size == b_size);

  if (a_size != b_size) {
    return FALSE;
  }

  protobuf_c_boolean retval = (0 == memcmp(a_buf, b_buf, a_size));

  if (a_buf != a_stackbuf) {
    do_free(instance, a_buf);
  }
  if (b_buf != b_stackbuf) {
    do_free(instance, b_buf);
  }

  return retval;
}


protobuf_c_boolean
protobuf_c_message_merge(ProtobufCInstance* instance,
                         const ProtobufCMessage* from,
                         ProtobufCMessage* to)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(from));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(to));

  protobuf_c_boolean ret_val = FALSE;

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, merge);

  //both the messages should be of same type.
  if (from->descriptor != to->descriptor) {
    PROTOBUF_C_MESSAGE_ERROR(instance, from, NULL,
                             "Merge Error: Descriptors (%x:%x) are different",
                             from->descriptor,
                             to->descriptor);
    return FALSE;
  }

  ProtobufCMergeOptions_t opts = { MERGE_FLAG_COPY_FIELDS | MERGE_FLAG_TO_BEFORE_FROM };
  ret_val = merge_messages(instance, (ProtobufCMessage *)from, to, opts);
  return ret_val;
}

protobuf_c_boolean
protobuf_c_message_merge_new(ProtobufCInstance* instance,
                             const ProtobufCMessage* from,
                             ProtobufCMessage* to)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(from));
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(to));

  protobuf_c_boolean ret_val = FALSE;

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, merge);

  //both the messages should be of same type.
  if (from->descriptor != to->descriptor) {
    PROTOBUF_C_MESSAGE_ERROR(instance, from, NULL,
                             "Merge Error: Descriptors (%x:%x) are different",
                             from->descriptor,
                             to->descriptor);
    return FALSE;
  }

  ProtobufCMergeOptions_t opts = { MERGE_FLAG_COPY_FIELDS | MERGE_FLAG_FROM_BEFORE_TO};
  ret_val = merge_messages(instance, (ProtobufCMessage *)from, to, opts);
  return ret_val;
}

const char*
protobuf_c_message_get_gi_typename(const ProtobufCMessage* message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  if (message->descriptor->gi_descriptor) {
    return message->descriptor->gi_descriptor->name;
  }
  return NULL;
}

const ProtobufCMessageDescriptor*
protobuf_c_message_retrieve_descriptor(const ProtobufCMessage* message)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  return message->descriptor;
}

protobuf_c_boolean
protobuf_c_ctype_init_memset(const ProtobufCCTypeDescriptor* ctype,
                             const ProtobufCFieldDescriptor* fdesc,
                             void* member)
{
  (void)ctype;
  memset(member,0,fdesc->data_size);
  return TRUE;
}

void
protobuf_c_ctype_free_noop(ProtobufCInstance* instance,
                           const ProtobufCCTypeDescriptor* ctype,
                           const ProtobufCFieldDescriptor* fdesc,
                           void* member)
{
  (void)instance;
  (void)ctype;
  (void)fdesc;
  (void)member;
}

protobuf_c_boolean
protobuf_c_ctype_check_noop(const ProtobufCCTypeDescriptor* ctype,
                            const ProtobufCFieldDescriptor* fdesc,
                            const void* member)
{
  (void)ctype;
  (void)fdesc;
  (void)member;
  return TRUE;
}

protobuf_c_boolean
protobuf_c_ctype_deep_copy_memcpy(ProtobufCInstance* instance,
                                  const ProtobufCCTypeDescriptor* ctype,
                                  const ProtobufCFieldDescriptor* fdesc,
                                  const void* copy_from,
                                  protobuf_c_boolean maybe_clear,
                                  void* copy_to)
{
  (void)instance;
  (void)ctype;
  (void)maybe_clear;
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(copy_from);
  PROTOBUF_C_ASSERT(copy_to);
  memcpy(copy_to,copy_from,fdesc->data_size);
  return TRUE;
}

int
protobuf_c_ctype_compare_memcmp(const ProtobufCCTypeDescriptor* ctype,
                                const ProtobufCFieldDescriptor* fdesc,
                                const void* a,
                                const void* b)
{
  (void)ctype;
  PROTOBUF_C_ASSERT(fdesc);
  PROTOBUF_C_ASSERT(a);
  PROTOBUF_C_ASSERT(b);
  return memcmp(a,b,fdesc->data_size);
}

/*
 * ATTN: This function is exactly same as
 * protobuf_c_message_is_field_present.
 */

static protobuf_c_boolean
protobuf_c_message_has_field_int(const ProtobufCMessage *msg,
                                 const ProtobufCFieldDescriptor *fdesc)
{
  protobuf_c_boolean ret = FALSE;
  protobuf_c_boolean is_inline = !!(fdesc->rw_flags & RW_PROTOBUF_FOPT_INLINE);
  uint32_t qf_value = 0;

  if (fdesc->quantifier_offset) {
    qf_value = STRUCT_MEMBER(uint32_t, msg, fdesc->quantifier_offset);
  }

  switch(fdesc->label) {
    case PROTOBUF_C_LABEL_REQUIRED: {
      ret = TRUE;
      if (!is_inline) { // The presence for required field can always be TRUE??
        if (fdesc->type == PROTOBUF_C_TYPE_MESSAGE ||
            fdesc->type == PROTOBUF_C_TYPE_STRING) {
          if (STRUCT_MEMBER(void*, msg, fdesc->offset) == NULL) {
            ret = FALSE;
          }
        }
      }
      break;
    }
    case PROTOBUF_C_LABEL_OPTIONAL: {
      if (fdesc->quantifier_offset != 0) {
        if (fdesc->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
          if (fdesc->id == qf_value) {
            ret = TRUE;
          }
        } else if (qf_value) {
          ret = TRUE;
        }
      } else {
        PROTOBUF_C_ASSERT(!is_inline);
        if (STRUCT_MEMBER(void*, msg, fdesc->offset) != fdesc->default_value) {
          ret = TRUE;
        }
      }
      break;
    }
    case PROTOBUF_C_LABEL_REPEATED:{
      if (qf_value != 0) {
        ret = TRUE;
      }
      break;
    }
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  return ret;
}

protobuf_c_boolean
protobuf_c_message_has_field_by_name(ProtobufCInstance* instance,
                                     const ProtobufCMessage *msg,
                                     const char *fname)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, has_field);

  const ProtobufCFieldDescriptor *fdesc = NULL;
  fdesc = protobuf_c_message_descriptor_get_field_by_name(msg->descriptor, fname);
  if (!fdesc) {
    return FALSE;
  }

  return protobuf_c_message_has_field_int(msg, fdesc);
}

protobuf_c_boolean
protobuf_c_message_has_field(ProtobufCInstance* instance,
                             const ProtobufCMessage *msg,
                             uint32_t id)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));

  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_INC_STATS(instance, fcall, has_field);

  const ProtobufCFieldDescriptor* fdesc
      = protobuf_c_message_descriptor_get_field(msg->descriptor, id);
  if (!fdesc) {
    return FALSE;
  }

  return protobuf_c_message_has_field_int(msg, fdesc);
}

protobuf_c_boolean
protobuf_c_message_has_field_with_value(
    const ProtobufCMessage *msg,
    const char *fname,
    const ProtobufCFieldInfo* value_finfo)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));

  const ProtobufCFieldDescriptor* msg_fdesc
      = protobuf_c_message_descriptor_get_field_by_name(msg->descriptor, fname);
  if (!msg_fdesc) {
    return FALSE;
  }

  PROTOBUF_C_ASSERT(PROTOBUF_C_LABEL_REPEATED != msg_fdesc->label);

  if (   (PROTOBUF_C_TYPE_MESSAGE == msg_fdesc->type)
      || (!protobuf_c_message_has_field_int (msg, msg_fdesc)) ) {
    return false;
  }

  ProtobufCFieldInfo msg_finfo;
  protobuf_c_boolean found_data = protobuf_c_message_get_field_instance(
      NULL, msg, msg_fdesc, 0, &msg_finfo );
  if (!found_data) {
    return false;
  }

  return 0 == protobuf_c_field_info_compare( &msg_finfo, value_finfo );
}

size_t
protobuf_c_message_pack_unknown_fields(ProtobufCInstance *instance,
                                       const ProtobufCMessage* msg,
                                       uint8_t *out)
{
  size_t rv = 0;
  instance = protobuf_c_instance_get(instance);

  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  if (msg->unknown_buffer) {
    for (unsigned i = 0; i < msg->unknown_buffer->n_unknown_fields; i++) {
      rv += unknown_field_pack(instance, &msg->unknown_buffer->unknown_fields[i], out + rv);
    }
  }

  return rv;
}

size_t
protobuf_c_message_get_unknown_fields_pack_size(const ProtobufCMessage* msg)
{
  size_t rv = 0;

  PROTOBUF_C_ASSERT(PROTOBUF_C_MESSAGE_IS_DATA(msg));

  if (msg->unknown_buffer) {
    for (unsigned i = 0; i < msg->unknown_buffer->n_unknown_fields; i++) {
      rv += unknown_field_get_packed_size(&msg->unknown_buffer->unknown_fields[i]);
    }
  }

  return rv;
}

size_t
protobuf_c_message_pack_tag(uint32_t id, uint8_t *out)
{
  return tag_pack(id, out);
}

size_t
protobuf_c_message_pack_uint32(uint32_t value, uint8_t *out)
{
  return uint32_pack(value, out);
}

size_t
protobuf_c_message_get_uint32_size(uint32_t v)
{
  return uint32_size(v);
}

size_t
protobuf_c_message_get_tag_size(unsigned number)
{
  return get_tag_size(number);
}

size_t
protobuf_c_message_get_field_size(const ProtobufCFieldDescriptor* fdesc)
{
  PROTOBUF_C_ASSERT(fdesc);
  return sizeof_elt_in_repeated_array(fdesc);
}

G_DEFINE_POINTER_TYPE(ProtobufCMessage, protobuf_c_message);
G_DEFINE_POINTER_TYPE(ProtobufCMessageDescriptor, protobuf_c_message_descriptor);
G_DEFINE_POINTER_TYPE(ProtobufCFieldDescriptor, protobuf_c_field_descriptor);
G_DEFINE_POINTER_TYPE(ProtobufCInstance, protobuf_c_instance);

const char **
protobuf_c_message_descriptor_get_field_names(const ProtobufCMessageDescriptor *desc)
{
  const char **array = (const char **)malloc (sizeof(char *) * (desc->n_fields+1));
  size_t i;

  for (i = 0; i < desc->n_fields; i++) {
    array[i] = desc->fields[i].c_name;
  }
  array[i] = 0;
  return array;
}

const char **
protobuf_c_message_descriptor_get_key_names(const ProtobufCMessageDescriptor *desc)
{
  const char **array = (const char **)malloc (sizeof(char *) * (desc->n_fields+1));
  size_t out = 0;
  for (size_t i = 0; i < desc->n_fields; i++) {
    if (desc->fields[i].rw_flags & RW_PROTOBUF_FOPT_KEY) {
      array[out] = desc->fields[i].c_name;
      ++out;
    }
  }
  array[out] = 0;
  return array;
}

const char *
protobuf_c_message_descriptor_get_gi_typename(const ProtobufCMessageDescriptor *desc)
{
  if (desc->gi_descriptor) {
    return desc->gi_descriptor->name;
  }
  return NULL;
}

protobuf_c_boolean
protobuf_c_field_descriptor_is_list(const ProtobufCFieldDescriptor *desc)
{
  if ((PROTOBUF_C_LABEL_REPEATED  == desc->label) &&
      (PROTOBUF_C_TYPE_MESSAGE == desc->type)) {
    return true;
  }
  return false;
}

/* === ProtobufCReferenceHeader APIs === */
void
protobuf_c_ref_header_create(ProtobufCReferenceHeader* ref_hdr,
                          ProtobufCReferenceState state,
                          intptr_t union_val)
{
  ref_hdr->magic_flags = PROTOBUF_C_FLAG_MAGIC_NUMBER_V1;
  ref_hdr->ref_flags = PROTOBUF_C_CREATE_REF_FLAG(state);
  if (state == PROTOBUF_C_FLAG_REF_STATE_COUNTED ||
      state == PROTOBUF_C_FLAG_REF_STATE_SHARED) {
    PROTOBUF_C_FLAG_SET(ref_hdr->ref_flags, REF_COUNT, 1);
  }
  ref_hdr->outer_offset = union_val;
}

static ProtobufCReferenceHeader*
protobuf_c_ref_header_get_outer(ProtobufCReferenceHeader* ref_hdr)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));

  ProtobufCReferenceState ref_state =
      PROTOBUF_C_FLAG_GET(ref_hdr->ref_flags, REF_STATE);

  while (ref_state == PROTOBUF_C_FLAG_REF_STATE_INNER) {
    intptr_t my_addr = (intptr_t)ref_hdr;
    intptr_t outer_addr = my_addr - ref_hdr->outer_offset;
    ref_hdr = (ProtobufCReferenceHeader *)outer_addr;
    PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));
    ref_state = PROTOBUF_C_FLAG_GET(ref_hdr->ref_flags, REF_STATE);
  }

  return ref_hdr;
}

ProtobufCReferenceHeader*
protobuf_c_ref_header_ref(ProtobufCReferenceHeader* ref_hdr)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));
  ProtobufCReferenceHeader* ret_obj = ref_hdr;

  bool success = false;
  while (!success) {

    uint32_t ref_flags = g_atomic_int_get(&ref_hdr->ref_flags);
    uint32_t ref_count = PROTOBUF_C_FLAG_GET(ref_flags, REF_COUNT);

    if (ref_count == PROTOBUF_C_FLAG_REF_COUNT_MAX) {
      return ret_obj; // Stay forever.
    }

    ProtobufCReferenceState ref_state = PROTOBUF_C_FLAG_GET(ref_flags, REF_STATE);
    uint32_t nref_flags = ref_flags;

    switch(ref_state) {

      case PROTOBUF_C_FLAG_REF_STATE_INNER: {
        // Lookup the outer most message!
        ref_hdr = protobuf_c_ref_header_get_outer(ref_hdr);
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_GLOBAL: {
        success = true; // No-op
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_OWNED: {
        /*
         * This msg was created by c/c++ code and it is being
         * passed first time to the managed language.
         * Set the ref_state to SHARED and start reference counting.
         */
        PROTOBUF_C_ASSERT(ref_count == 0);
        // Compute the new value of the flag. Set the ref count to 1 and state to SHARED
        PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, 1);
        PROTOBUF_C_FLAG_SET(nref_flags, REF_STATE, PROTOBUF_C_FLAG_REF_STATE_SHARED);
        g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
        /* Success or failure continue here. If compare and swap was success,
         * then based on the new ref flag it will continue below. Else it will
         * switch based on what is the latest ref_state.
         */
        continue;
      }
      case PROTOBUF_C_FLAG_REF_STATE_SHARED: {
        /*
         * This msg was created by c/c++ code and this state was
         * explicity set by the c/c++ code or it was set when the
         * message was passed first time to the managed language.
         */
        PROTOBUF_C_ASSERT(ref_count); // Ref count cannot be zero here!
        ref_count++;
        PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, ref_count);
        success = g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_COUNTED: {
        /*
         * This message was created by the managed language.
         * Increment the reference count.
         */
        PROTOBUF_C_ASSERT(ref_count); // Ref count cannot be zero here!
        ref_count++;
        PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, ref_count);
        success = g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_PRIVATE:
      case PROTOBUF_C_FLAG_REF_STATE_UNKNOWN:
      case PROTOBUF_C_FLAG_REF_STATE_DELETING:
      case PROTOBUF_C_FLAG_REF_STATE_INVALID:
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }
  }

  return ret_obj;
}

void
protobuf_c_ref_header_unref(ProtobufCReferenceHeader* ref_hdr,
                            ProtobufCRefObjectFree free_func)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));

  bool success = false;

  while (!success) {

    uint32_t ref_flags = g_atomic_int_get(&ref_hdr->ref_flags);
    uint32_t ref_count = PROTOBUF_C_FLAG_GET(ref_flags, REF_COUNT);

    ProtobufCReferenceState ref_state = PROTOBUF_C_FLAG_GET(ref_flags, REF_STATE);
    uint32_t nref_flags = ref_flags;

    switch(ref_state) {
      case PROTOBUF_C_FLAG_REF_STATE_INNER: {
        ref_hdr = protobuf_c_ref_header_get_outer(ref_hdr);
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_GLOBAL: {
        success = true; // no-op
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_COUNTED: {
        PROTOBUF_C_ASSERT(ref_count);
        if (ref_count == 1) {
          free_func(ref_hdr);
          success = true;
        } else {
          ref_count--;
          PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, ref_count);
          success = g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
        }
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_SHARED: {
        PROTOBUF_C_ASSERT(ref_count >= 2);
        ref_count--;
        PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, ref_count);
        success = g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_PRIVATE:
      case PROTOBUF_C_FLAG_REF_STATE_OWNED:
      case PROTOBUF_C_FLAG_REF_STATE_DELETING:
      case PROTOBUF_C_FLAG_REF_STATE_INVALID:
      case PROTOBUF_C_FLAG_REF_STATE_UNKNOWN:
      default:
        PROTOBUF_C_ASSERT_NOT_REACHED();
    }
  }
}

uint8_t ref_state_table[][PROTOBUF_C_FLAG_REF_STATE_MASK] = {
  { 1, 0, 0, 0, 0, 0, 0, 0, 0 }, /* UNKNOWN (Cannot change ref state) */
  { 0, 1, 0, 0, 0, 0, 0, 1, 0 }, /* INNER (DELETING) */
  { 0, 0, 1, 0, 0, 0, 0, 0, 0 }, /* GLOBAL (Cannot change ref state) */
  { 0, 0, 0, 1, 0, 0, 0, 1, 0 }, /* PRIVATE (DELETING) */
  { 0, 0, 0, 1, 1, 1, 1, 1, 0 }, /* OWNED (PRIVATE, SHARED, COUNTED, DELETING) */
  { 0, 0, 0, 0, 0, 1, 1, 1, 0 }, /* SHARED (COUNTED, DELETING) */
  { 0, 0, 0, 0, 0, 0, 1, 1, 0 }, /* COUNTED (DELETING) */
  { 0, 0, 0, 0, 0, 0, 0, 1, 1 }, /* DELETING (INVALID) */
  { 0, 0, 0, 0, 0, 0, 0, 0, 1 } /* INVALID (Cannot change ref state) */
};

void
protobuf_c_ref_header_set_ref_state(ProtobufCReferenceHeader* ref_hdr,
                                    ProtobufCReferenceState new_rs)
{
  bool success = false;

  while (!success) {

    uint32_t ref_flags = g_atomic_int_get(&ref_hdr->ref_flags);
    ProtobufCReferenceState old_rs = PROTOBUF_C_FLAG_GET(ref_flags, REF_STATE);

    if (old_rs == new_rs) {
      return;
    }

    PROTOBUF_C_ASSERT(ref_state_table[old_rs][new_rs]);

    uint32_t ref_count = PROTOBUF_C_FLAG_GET(ref_flags, REF_COUNT);
    uint32_t nref_flags = ref_flags;

    switch (old_rs) {
      case PROTOBUF_C_FLAG_REF_STATE_OWNED: {
        PROTOBUF_C_ASSERT(!ref_count);
        if (new_rs == PROTOBUF_C_FLAG_REF_STATE_SHARED ||
            new_rs == PROTOBUF_C_FLAG_REF_STATE_COUNTED) {
          ref_count++;
        }
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_SHARED:
      case PROTOBUF_C_FLAG_REF_STATE_COUNTED: {
        PROTOBUF_C_ASSERT(ref_count);
        if (new_rs == PROTOBUF_C_FLAG_REF_STATE_DELETING) {
            PROTOBUF_C_ASSERT(ref_count == 1);
        }
        break;
      }
      case PROTOBUF_C_FLAG_REF_STATE_INNER:
      case PROTOBUF_C_FLAG_REF_STATE_PRIVATE:
        PROTOBUF_C_ASSERT(!ref_count);
        break;
      default:
        break;
    }

    PROTOBUF_C_FLAG_SET(nref_flags, REF_STATE, new_rs);
    PROTOBUF_C_FLAG_SET(nref_flags, REF_COUNT, ref_count);
    success = g_atomic_int_compare_and_exchange(&ref_hdr->ref_flags, ref_flags, nref_flags);
  }
}

static ProtobufCReferenceState
protobuf_c_ref_header_get_ref_state(const ProtobufCReferenceHeader* ref_hdr)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));
  uint32_t ref_flags = g_atomic_int_get(&ref_hdr->ref_flags);
  return (ProtobufCReferenceState)PROTOBUF_C_FLAG_GET(ref_flags, REF_STATE);
}

static uint32_t
protobuf_c_ref_header_get_ref_count(const ProtobufCReferenceHeader* ref_hdr)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_VALID_REF_HDR(ref_hdr));
  uint32_t ref_flags = g_atomic_int_get(&ref_hdr->ref_flags);
  return PROTOBUF_C_FLAG_GET(ref_flags, REF_COUNT);
}

/* === ProtobufCMessage Reference Couting related APIs === */

ProtobufCMessage*
protobuf_c_message_gi_create(ProtobufCInstance* instance,
                             const ProtobufCMessageDescriptor *mdesc)
{
  ProtobufCMessage* msg = NULL;
  msg = protobuf_c_message_create(instance, mdesc);
  PROTOBUF_C_ASSERT(msg);
  protobuf_c_ref_header_set_ref_state(&msg->ref_hdr, PROTOBUF_C_FLAG_REF_STATE_COUNTED);
  return msg;
}

ProtobufCGiMessageBox*
protobuf_c_message_gi_new_adopt(
  ProtobufCMessage* message,
  ProtobufCGiMessageBox* parent )
{
  PROTOBUF_C_ASSERT(message);
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(message));
  const ProtobufCMessageGiDescriptor* gi_desc = message->descriptor->gi_descriptor;
  if (!gi_desc) {
    return NULL;
  }

  PROTOBUF_C_ASSERT(gi_desc->boxed_size >= sizeof(ProtobufCGiMessageBox));
  ProtobufCGiMessageBox* gi_boxed = protobuf_c_gi_boxed_zalloc(gi_desc->boxed_size);
  ProtobufCGiMessageBase* gi_base = &gi_boxed->gi_base;
  gi_base->magic = PROTOBUF_C_GI_BOX_MAGIC;
  gi_base->ref_count = 1;
  gi_boxed->message = message;

  if (NULL != parent) {
    gi_base->parent = parent;
    PROTOBUF_C_ASSERT(parent->message);
    const ProtobufCMessageGiDescriptor* pgi_desc = parent->message->descriptor->gi_descriptor;
    PROTOBUF_C_ASSERT(pgi_desc);
    gi_base->parent_unref = pgi_desc->unref;
  }

  ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
  if (debug_stats) {
    g_atomic_int_inc(&debug_stats->gi_new_adopt_count);
  }
  return gi_boxed;
}

ProtobufCGiMessageBox*
protobuf_c_message_gi_ref(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));
  int old_ref_cnt = g_atomic_int_add(&gi_base->ref_count, 1);
  PROTOBUF_C_ASSERT(old_ref_cnt >= 1);

  ProtobufCMessage* message = gi_boxed->message;
  if (message) {
    ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
    if (debug_stats) {
      g_atomic_int_inc(&debug_stats->gi_ref_count);
    }
  }

  return gi_boxed;
}

void
protobuf_c_message_gi_reparent(
  ProtobufCGiMessageBox* parent_boxed,
  ProtobufCGiMessageBox* child_boxed )
{
  ProtobufCGiMessageBase* child_base = &child_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(child_base));
  ProtobufCGiMessageBase* parent_base = &parent_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(parent_base));

  if (child_base->parent != parent_boxed) {
    child_base->parent = parent_boxed;
    PROTOBUF_C_ASSERT(parent_boxed->message);
    const ProtobufCMessageGiDescriptor* pgi_desc = parent_boxed->message->descriptor->gi_descriptor;
    PROTOBUF_C_ASSERT(pgi_desc);
    child_base->parent_unref = pgi_desc->unref;

    protobuf_c_message_gi_ref(parent_boxed);
    protobuf_c_message_gi_ref(child_boxed);
  }
}

void
protobuf_c_message_gi_invalidate_start(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));

  ProtobufCMessage* message = gi_boxed->message;
  if (message) {
    ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
    if (debug_stats) {
      int ref_cnt = g_atomic_int_get(&gi_base->ref_count);
      g_atomic_int_add(&debug_stats->gi_invalidate_count, ref_cnt);
    }
  }
  gi_boxed->message = NULL;
}

void
protobuf_c_message_gi_invalidate_complete(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));

  ProtobufCGiMessageBox* parent = gi_base->parent;
  if (parent != NULL) {
    ProtobufCMessageGiUnref parent_unref = gi_base->parent_unref;
    gi_base->parent = NULL;
    if (parent_unref) {
      gi_base->parent_unref = NULL;
      parent_unref(parent);
    }
  }
}

void
protobuf_c_message_gi_become_zombie(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));
  PROTOBUF_C_ASSERT(gi_base->parent);

  ProtobufCMessage* message = gi_boxed->message;
  if (message) {
    ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
    if (debug_stats) {
      int ref_cnt = g_atomic_int_get(&gi_base->ref_count);
      g_atomic_int_add(&debug_stats->gi_zombie_count, ref_cnt);
    }
  }

  ProtobufCMessageGiUnref parent_unref = gi_base->parent_unref;
  gi_base->parent_unref = NULL;
  parent_unref(gi_base->parent);
}

void
protobuf_c_message_gi_revive_zombie(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));
  PROTOBUF_C_ASSERT(gi_base->parent);

  ProtobufCMessage* message = gi_boxed->message;
  if (message) {
    ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
    if (debug_stats) {
      int ref_cnt = g_atomic_int_get(&gi_base->ref_count);
      g_atomic_int_add(&debug_stats->gi_revive_count, ref_cnt);
    }
  }

  PROTOBUF_C_ASSERT(gi_base->parent->message);
  const ProtobufCMessageGiDescriptor* pgi_desc = gi_base->parent->message->descriptor->gi_descriptor;
  PROTOBUF_C_ASSERT(pgi_desc);
  gi_base->parent_unref = pgi_desc->unref;

  protobuf_c_message_gi_ref(gi_base->parent);
}

protobuf_c_boolean
protobuf_c_message_gi_unref(
  ProtobufCGiMessageBox* gi_boxed )
{
  ProtobufCGiMessageBase *gi_base = &gi_boxed->gi_base;
  PROTOBUF_C_ASSERT(PROTOBUF_C_GI_BASE_IS_GOOD(gi_base));

  ProtobufCMessage* message = gi_boxed->message;
  if (message) {
    ProtobufCMessageDebugStats* debug_stats = message->descriptor->debug_stats;
    if (debug_stats) {
      g_atomic_int_inc(&debug_stats->gi_unref_count);
    }
  }

  PROTOBUF_C_GI_MUTEX_GUARD_AUTO_RELEASE();
  int old_ref_cnt = g_atomic_int_add(&gi_base->ref_count, -1);
  switch (old_ref_cnt) {
    case 0:
      PROTOBUF_C_ASSERT(!"Unref of free PB GI box");
      break;
    case 1:
      if (gi_base->parent != NULL) {
        // Root message frees the entire hierarchy, so forget the message pointer
        // ATTN: What happens when the messages themselves are ref counted?
        gi_boxed->message = NULL;
      }
      return TRUE;
    case 2: {
      ProtobufCGiMessageBox *parent = gi_base->parent;
      if (parent != NULL) {
        protobuf_c_message_gi_become_zombie(gi_boxed);
      }
      break;
    }
    default:
      PROTOBUF_C_ASSERT(old_ref_cnt > 2); // negative not allowed
      break;
  }
  return FALSE;
}

#define PROTOBUF_C_GI_GUARD_LOCKED_MAGIC 0x6472617547636250
#define PROTOBUF_C_GI_GUARD_RELEASED_MAGIC 0x2D72617547636250

pthread_mutex_t protobuf_c_global_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

intptr_t
protobuf_c_gi_mutex_guard_lock(void)
{
  int err = pthread_mutex_lock(&protobuf_c_global_mutex);
  PROTOBUF_C_ASSERT(0 == err);
  return PROTOBUF_C_GI_GUARD_LOCKED_MAGIC;
}

void
protobuf_c_gi_mutex_guard_release(
  intptr_t* guard)
{
  switch (*guard) {
    case PROTOBUF_C_GI_GUARD_LOCKED_MAGIC: {
      int err = pthread_mutex_unlock(&protobuf_c_global_mutex);
      PROTOBUF_C_ASSERT(0 == err);
      *guard = PROTOBUF_C_GI_GUARD_RELEASED_MAGIC;
      return;
    }
    case PROTOBUF_C_GI_GUARD_RELEASED_MAGIC:
      return;
  }
  PROTOBUF_C_ASSERT_NOT_REACHED();
}

ProtobufCMessage*
protobuf_c_message_ref(ProtobufCMessage* msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  ProtobufCReferenceHeader* ref_hdr = protobuf_c_ref_header_ref(&msg->ref_hdr);
  PROTOBUF_C_ASSERT(ref_hdr == &msg->ref_hdr);
  return msg;
}

static void
protobuf_c_message_free_callback(ProtobufCReferenceHeader* ref_hdr)
{
  ProtobufCMessage* msg = (ProtobufCMessage *)ref_hdr;
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  protobuf_c_message_free_unpacked(NULL, msg);
}

void
protobuf_c_message_unref(ProtobufCMessage* msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(msg));
  protobuf_c_ref_header_unref(&msg->ref_hdr, protobuf_c_message_free_callback);
}

void
protobuf_c_message_unref_or_free_child(ProtobufCInstance* instance,
                                       ProtobufCMessage* child_msg)
{
  PROTOBUF_C_ASSERT(PROTOBUF_C_IS_MESSAGE(child_msg));

  uint32_t ref_count = protobuf_c_ref_header_get_ref_count(&child_msg->ref_hdr);
  if (ref_count >= 2) {
    protobuf_c_ref_header_unref(&child_msg->ref_hdr, protobuf_c_message_free_callback);
    return;
  }
  protobuf_c_message_free_unpacked(instance, child_msg);
}

/// ATTN: Convert this to use UF union.
protobuf_c_boolean
protobuf_c_unknown_parse_scalar_type(ProtobufCInstance* instance,
                                     const ProtobufCMessageUnknownField* unkn_field,
                                     ProtobufCType type,
                                     ProtobufCScalarFieldUnion* out)
{
  PROTOBUF_C_ASSERT(unkn_field);
  instance = protobuf_c_instance_get(instance);
  PROTOBUF_C_ASSERT(instance);

  uint32_t ut =
      PROTOBUF_C_FLAG_GET(unkn_field->base_.unknown_flags, UNKNOWN_UNION_TYPE);
  PROTOBUF_C_ASSERT(ut == PROTOBUF_C_FLAG_UNKNOWN_UNION_TYPE_SERIALIZED);

  ProtobufCWireType wire_type = unkn_field->serialized.wire_type;
  uint8_t* data = unkn_field->serialized.data;
  size_t len = unkn_field->serialized.len;

  switch (type) {
    case PROTOBUF_C_TYPE_INT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
         return FALSE;
      }
      out->int32_v = parse_int32(len, data);
      break;
    case PROTOBUF_C_TYPE_UINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      out->uint32_v = parse_uint32(len, data);
      break;
    case PROTOBUF_C_TYPE_SINT32:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      out->int32_v = unzigzag32(parse_uint32(len, data));
      break;
    case PROTOBUF_C_TYPE_SFIXED32:
    case PROTOBUF_C_TYPE_FIXED32:
    case PROTOBUF_C_TYPE_FLOAT:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT) {
        return FALSE;
      }
      out->uint32_v = parse_fixed_uint32(data);
      break;
    case PROTOBUF_C_TYPE_INT64:
    case PROTOBUF_C_TYPE_UINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      out->uint64_v = parse_uint64(len, data);
      break;
    case PROTOBUF_C_TYPE_SINT64:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      out->int64_v = unzigzag64(parse_uint64(len, data));
      break;
    case PROTOBUF_C_TYPE_SFIXED64:
    case PROTOBUF_C_TYPE_FIXED64:
    case PROTOBUF_C_TYPE_DOUBLE:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT) {
        return FALSE;
      }
      out->uint64_v = parse_fixed_uint64(data);
      break;
    case PROTOBUF_C_TYPE_BOOL:
      out->uint32_v = parse_boolean(len, data);
      break;
    case PROTOBUF_C_TYPE_ENUM:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT) {
        return FALSE;
      }
      out->uint32_v = parse_uint32(len, data);
      break;
    case PROTOBUF_C_TYPE_STRING:
      if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED) {
        return FALSE;
      }
      size_t movel = 0;
      uint32_t slen = scan_length_prefixed_data(instance, len, data, &movel);
      PROTOBUF_C_ASSERT(slen);
      slen -= movel;
      out->char_v = do_alloc(instance, slen+1);
      memcpy(out->char_v, data+movel, slen);
      out->char_v[slen] = 0;
      break;
    case PROTOBUF_C_TYPE_BYTES:
      // ATTN: Handle this
    default:
      PROTOBUF_C_ASSERT_NOT_REACHED();
  }

  return TRUE;
}
