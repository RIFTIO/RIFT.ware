#!/usr/bin/python

# 
#   Copyright 2016 RIFT.IO Inc
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

import sys
import re
import argparse
import os.path
import tempfile

def strip_list(l):
    """Strip all the strings in the list of the 
    leading and trailing whilte space.
    """
    return ([s.strip() for s in l])

def un_camel_lower(s):
    """Converts the camel case to lowercase strings.

    Example conversions:
    CamelCase -> camel_case
    IPAddress -> ip_address
    """    
    return re.sub('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))',
                  r'_\1', s).lower()

    # A simpler version for less courageous
    # s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', s1)
    # return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

def un_camel_upper(s):
    """Converts the camel case to uppercase strings.

    Example conversions:
    CamelCase -> camel_case
    IPAddress -> ip_address
    """              
    return re.sub('((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))',
                  r'_\1', s).upper()

class VapiC(object):
    """Auto generates the code for writing C peas extension.
    """
    gen_prototype = False
    vapi_lines = []           # list of lines from vapi file
    auto_c_lines = []      # list of autogenerated c lines
    auto_h_lines = []       # list of autogenerated header lines
    
    namespaces = []               # list of namespaces
    namespace = ''                # namespace
    namespace_process_flag = True # if true 'process_namespace' function will
                                  # be called before 'process_interface'
    valaclass = ''                # vala class name
    valaintf  = ''                # vala interface name
    valaintf_parents = ''         # vala interface parents
    decls     = []    # declarations in a class or interface block
    valatype  = ''    # current block type (class or interface)
    
    
    def __init__(self, gen_prototype):
        self.gen_prototype = gen_prototype

    def parse_ccode(self, line):
        ccodes = {}
        m = re.match(r'.*\[CCode[ ]+\((.*)\)\]', line)
        if m:
            ccode_str = m.group(1).strip()
            ccode_list = ccode_str.split(',')
            for ccode in ccode_list:
                pair = ccode.split('=')
                pair[0] = pair[0].strip()
                pair[1] = pair[1].strip().strip('"')                
                ccodes[pair[0]] = pair[1]

        return ccodes
            
    def process_class(self, phase):
        pass

    def get_cprefix(self):
        cprefix = ''
        if (args.plugin_prefix):
            cprefix = args.plugin_prefix
        elif not self.cprefix:
            for name in self.namespaces:
                if cprefix:
                    cprefix = cprefix + name
                else:
                    cprefix = name
        else:
            cprefix = self.cprefix
            
        return cprefix

    def get_lower_case_cprefix(self):
        lower_case_cprefix = ''
        if (args.plugin_prefix):
            lower_case_cprefix = un_camel_lower(args.plugin_prefix)
        elif not self.lower_case_cprefix:
            for name in self.namespaces:
                if lower_case_cprefix:
                    lower_case_cprefix = (lower_case_cprefix + "_" +
                                          un_camel_lower(name))
                else:
                    lower_case_cprefix = un_camel_lower(name)
        else:
            lower_case_cprefix = self.lower_case_cprefix

        return lower_case_cprefix

    def autogen_extension_definitions(self, cprefix, lower_case_cprefix, phase):            
        if phase == 'peas_register_types_phase':
            self.auto_h_lines.append('#define ' + lower_case_cprefix.upper() +
                                     '_C_EXTENSION_TYPE (' + lower_case_cprefix +
                                     '_c_extension_get_type())')
            self.auto_h_lines.append('')
            self.auto_h_lines.append('typedef struct _' + cprefix +
                                     'CExtension       ' + cprefix + 'CExtension;')
            self.auto_h_lines.append('typedef struct _' + cprefix +
                                     'CExtensionClass ' + cprefix + 'CExtensionClass;')
            self.auto_h_lines.append('')
                                    
            self.auto_h_lines.append('struct _' + cprefix + 'CExtension {')
            self.auto_h_lines.append('  PeasExtensionBase parent_instance;')
            self.auto_h_lines.append('};')
            self.auto_h_lines.append('')

            self.auto_h_lines.append('struct _' + cprefix + 'CExtensionClass {')
            self.auto_h_lines.append('  PeasExtensionBaseClass parent_class;')
            self.auto_h_lines.append('};')
            self.auto_h_lines.append('')

            self.auto_h_lines.append('GType ' + lower_case_cprefix +
                                     '_c_extension_get_type (void) G_GNUC_CONST;')
            self.auto_h_lines.append('')            
        return

        
    def namespace_autogen_h_lines(self, phase):
        if phase == 'peas_register_types_phase':
            self.auto_h_lines.append('G_BEGIN_DECLS')
            self.auto_h_lines.append('')
            self.auto_h_lines.append('G_MODULE_EXPORT void peas_register_types(' +
                                     'PeasObjectModule *module);')
            self.auto_h_lines.append('')

        cprefix = self.get_cprefix()
        lower_case_cprefix = self.get_lower_case_cprefix()
        lower_case_cprefix = lower_case_cprefix.rstrip('_')
        upper_case_cprefix = lower_case_cprefix.upper()
        self.autogen_extension_definitions(cprefix, lower_case_cprefix, phase)        
        return
        

    def namespace_autogen_c_lines(self, phase):
        cprefix = self.get_cprefix()
        lower_case_cprefix = self.get_lower_case_cprefix()
        lower_case_cprefix = lower_case_cprefix.rstrip('_')

        
        if phase == 'c_iface_init_phase':
            if self.gen_prototype:
                self.auto_c_lines.append('static void')
                self.auto_c_lines.append(lower_case_cprefix +
                                    '_c_extension_init(' +
                                    cprefix + 'CExtension *plugin)')
                self.auto_c_lines.append('{')
                self.auto_c_lines.append('}')
                self.auto_c_lines.append('')
                                    
                self.auto_c_lines.append('static void')
                self.auto_c_lines.append(lower_case_cprefix +
                                    '_c_extension_class_init(' +
                                    cprefix + 'CExtensionClass *klass)')
                self.auto_c_lines.append('{')
                self.auto_c_lines.append('}')
                self.auto_c_lines.append('')
                
                self.auto_c_lines.append('static void')
                self.auto_c_lines.append(lower_case_cprefix +
                                    '_c_extension_class_finalize(' +
                                    cprefix + 'CExtensionClass *klass)')
                self.auto_c_lines.append('{')
                self.auto_c_lines.append('}')
                self.auto_c_lines.append('')

        elif phase == 'g_define_dynamic_type_phase':
            self.auto_c_lines.append('G_DEFINE_DYNAMIC_TYPE_EXTENDED(' +
                                cprefix +
                                'CExtension,')
            self.auto_c_lines.append('        ' +
                                lower_case_cprefix +
                                '_c_extension,')
            self.auto_c_lines.append('        PEAS_TYPE_EXTENSION_BASE,')
            self.auto_c_lines.append('        0,')

        elif phase == 'peas_register_types_phase':
            self.auto_c_lines.append('G_MODULE_EXPORT void')
            self.auto_c_lines.append('peas_register_types(PeasObjectModule *module)')
            self.auto_c_lines.append('{')
            self.auto_c_lines.append('  ' + lower_case_cprefix +
                                '_c_extension_register_type(G_TYPE_MODULE(module));')
            
        return

    def process_namespace(self, phase):
        self.namespace_autogen_c_lines(phase)
        self.namespace_autogen_h_lines(phase)

    def interface_autogen_h_lines(self, phase):
        cprefix = self.get_cprefix() + self.valaintf
        lower_case_cprefix = self.get_lower_case_cprefix()
        lower_case_cprefix = lower_case_cprefix.rstrip('_') + '_' + un_camel_lower(self.valaintf)
        upper_case_cprefix = lower_case_cprefix.upper()

        if phase == 'peas_register_types_phase':
            namespace_str = ''
            for n in self.namespaces:
                if namespace_str:                
                    namespace_str = namespace_str + '.' + n
                else:
                    namespace_str = n
                
            namespace_str = namespace_str + '.' + self.valaintf
        
            self.auto_h_lines.append('//')
            self.auto_h_lines.append('//' + namespace_str)
            self.auto_h_lines.append('//')
            
        self.autogen_extension_definitions(cprefix, lower_case_cprefix, phase)        
        return
        
    def interface_autogen_c_lines(self, phase):
        cprefix = self.get_cprefix()
        lower_case_cprefix = self.get_lower_case_cprefix()
        lower_case_cprefix = lower_case_cprefix.rstrip('_')
        upper_case_cprefix = lower_case_cprefix.upper()

        if phase == 'g_define_dynamic_type_phase':
            # generate the G_IMPLEMENT_INTERFACE_DYNAMIC clauses for
            # the parents of this interface excluding GLib.Object
            for parent in self.valaintf_parents:
                if parent == 'GLib.Object':
                    pass  # nothing special for GLib.Objects
                else:
                    # current namespace is NOT used here!
                    parts = parent.rsplit('.', 1)
                    
                    
                    self.auto_c_lines.append('        G_IMPLEMENT_INTERFACE_DYNAMIC(' +
                                        un_camel_upper(parts[0]) + '_TYPE_' + 
                                        un_camel_upper(parts[1]) + ',')
                    self.auto_c_lines.append('                ' + 
                                        un_camel_lower(parts[0]) + '__' + 
                                        un_camel_lower(parts[1]) + '__iface_init)')

            # now generate the G_IMPLEMENT_INTERFACE_DYNAMIC for the current class
            self.auto_c_lines.append('        G_IMPLEMENT_INTERFACE_DYNAMIC(' +
                                upper_case_cprefix +
                                '_TYPE_' + un_camel_upper(self.valaintf) + ',')
            self.auto_c_lines.append('                ' + lower_case_cprefix +
                                '__' + un_camel_lower(self.valaintf) +
                                '__iface_init)')
                    
        elif phase == 'peas_register_types_phase':
            # generate the peas_object_module_register_extension_type clauses for
            # the parents of this interface excluding GLib.Object
            for parent in self.valaintf_parents:
                if parent == 'GLib.Object':
                    pass  # nothing special for GLib.Objects
                else:
                    # current namespace is NOT used here!
                    parts = parent.rsplit('.', 1)
                    self.auto_c_lines.append('  peas_object_module_register_extension_type(module,')
                    self.auto_c_lines.append('        ' + un_camel_upper(parts[0]) +
                                '_TYPE_' + un_camel_upper(parts[1]) + ',')
                    self.auto_c_lines.append('        ' + upper_case_cprefix +
                                '_C_EXTENSION_TYPE);')

            # now generate the peas_object_module_register_extension_type for
            # the current class
            self.auto_c_lines.append('  peas_object_module_register_extension_type(module,')
            self.auto_c_lines.append('        ' + upper_case_cprefix +
                                '_TYPE_' + un_camel_upper(self.valaintf) + ',')
            self.auto_c_lines.append('        ' + upper_case_cprefix +
                                '_C_EXTENSION_TYPE);')
            
        elif phase == 'c_iface_init_phase':
            self.auto_c_lines.append('static void')
            self.auto_c_lines.append(lower_case_cprefix +
                                '__' + un_camel_lower(self.valaintf) +
                                '__iface_init(' + cprefix +
                                self.valaintf + 'Iface *iface)')
            self.auto_c_lines.append('{')
             
            for decl in self.decls:
                m = re.match(r'.*( .+)\(.*', decl)
                if m :
                    f = m.group(1).strip()
                    self.auto_c_lines.append('  iface->' + f + ' = ' +
                                        lower_case_cprefix + '__' +
                                        un_camel_lower(self.valaintf) +
                                        '__' + f + ';')
            self.auto_c_lines.append('}')
            self.auto_c_lines.append('')
            
        return

    def process_interface(self, phase):
        self.interface_autogen_c_lines(phase)
        self.interface_autogen_h_lines(phase)

    def autogen_current_class_or_interface(self, phase):
        if len(self.decls):
            if self.namespace_process_flag:
                self.process_namespace(phase)
                self.namespace_process_flag = False
                            
            # process previous class before starting another                        
            if self.valatype is 'class':
                self.process_class(phase)
            else:
                self.process_interface(phase)

        
    def parse_vapi(self, phase):
        self.namespaces = []
        self.namespace = '' # namespace
        self.namespace_process_flag = True
        self.valaclass = '' # vala class
        self.valaintf  = '' # vala interface
        self.decls     = [] # declarations
        self.cprefix = ''
        self.lower_case_cprefix = ''
    
        for line in self.vapi_lines:
            line = line.strip() # strip white spaces
            line = re.sub(r'/\*.*\*/', r'', line)       # strip comments

            if '[CCode' in line:
                ccodes = self.parse_ccode(line)
                if ccodes.has_key('cprefix'):
                    self.cprefix =  ccodes['cprefix']
                if ccodes.has_key('lower_case_cprefix'):
                    self.lower_case_cprefix = ccodes['lower_case_cprefix']

            line = re.sub(r'\[CCode.*\]', r'', line)  # strip CCode

            # ignore the empty, delegate, and '}' lines
            if not line or line is '}' or ' delegate ' in line:
                continue

            m = re.match(r'namespace (.*){', line)
            if m:
                # start of the name space
                temp = m.group(1).strip()
                self.namespaces.append(temp)

            else:
                if re.match(r'public +class ([^ ]*).*', line):
                    m = re.match(r'public +class ([^ ]*).*', line)
                    klass = m.group(1).strip()

                    self.autogen_current_class_or_interface(phase)
                    # start processing a new class
                    self.valatype = 'class'
                    self.decls = []
                    self.valaclass = klass

                elif re.match(r'public +interface ([^ ]*).*', line):
                    m = re.match(r'public +interface ([^ ]*).*', line)
                    interface = m.group(1).strip()

                    # find out if this interface is inherited from other interfaces
                    parents = []
                    m = re.match(r'public +interface .*:(.*){', line)
                    if m:
                        parents = strip_list(m.group(1).split(','))

                    self.autogen_current_class_or_interface(phase)

                    # start processing a new interface
                    # initialize the variables for new interface
                    self.valatype = 'interface'
                    self.decls = []
                    self.valaintf = interface
                    self.valaintf_parents = parents
                else :
                    self.decls.append(line)

        self.autogen_current_class_or_interface(phase)
        
        if phase == 'g_define_dynamic_type_phase':
            self.auto_c_lines.append('        )')
            self.auto_c_lines.append('')
            
        elif phase == 'peas_register_types_phase':
            self.auto_c_lines.append('}')
            self.auto_c_lines.append('')
            self.auto_h_lines.append('G_END_DECLS')
            self.auto_h_lines.append('')

    def write_c_plugin(self, fd):
        """Write the plugin information to the file descriptor.
        """
        fd.write('#define VAPI_TO_C_AUTOGEN\n')
        fd.write('#ifdef VAPI_TO_C_AUTOGEN\n\n')
        fd.write("/* Don't modify the code below, it is autogenerated */\n\n")
        for l in self.auto_c_lines:
            fd.write(l + '\n')
            
        fd.write('#endif //VAPI_TO_C_AUTOGEN\n')

    def write_h_plugin(self, fd):
        """Write the plugin information to the file descriptor.
        """
        fd.write('#define VAPI_TO_C_AUTOGEN\n')
        fd.write('#ifdef VAPI_TO_C_AUTOGEN\n\n')
        fd.write("/* Don't modify the code below, it is autogenerated */\n\n")
        for l in self.auto_h_lines:
            fd.write(l + '\n')
            
        fd.write('#endif //VAPI_TO_C_AUTOGEN\n')
        

    def gen_h_plugin(self, hfile_name):
        """ Generate the h plugin.

        if hfile_name:
          -- is not specified the plugin is dumped to standard output
          -- is specified, but doesn't exist the plugin is dumped to the file
          -- is specified and exists, the content between VAPI_TO_C_AUTOGEN
             is overwritten.
        """

        if hfile_name and os.path.isfile(hfile_name):
            t = tempfile.NamedTemporaryFile(mode="r+")
            f = open(hfile_name, 'r+')
            autogen = False
            autogen_done = False
            for l in f:
                if '#define VAPI_TO_C_AUTOGEN' in l:
                    self.write_h_plugin(t)
                    autogen = True
                    autogen_done = True
                else:
                    if autogen:
                        if "#endif //VAPI_TO_C_AUTOGEN" in l:
                            autogen = False
                    else:
                        t.write(l)

            if not autogen_done:
                # the code will reach here if the original file doesn't 
                # have #define VAPI_TO_C_AUTOGEN block. Add it to the end.
                t.write('\n')
                self.write_h_plugin(t)

            t.seek(0)
            f.seek(0)
            for l in t:
                f.write(l)
            f.truncate()
            f.close()            
            t.close()
        else:
            if hfile_name:
                sys.stdout = open(hfile_name, 'w')
            self.write_h_plugin(sys.stdout)

    def gen_c_plugin(self, cfile_name):
        """ Generate the c plugin.

        if cfile_name:
          -- is not specified the plugin is dumped to standard output
          -- is specified, but doesn't exist the plugin is dumped to the file
          -- is specified and exists, the content between VAPI_TO_C_AUTOGEN
             is overwritten.
        
        """
        if cfile_name and os.path.isfile(cfile_name):
            t = tempfile.NamedTemporaryFile(mode="r+")
            f = open(cfile_name, 'r+')
            autogen = False
            autogen_done = False
            for l in f:
                if '#define VAPI_TO_C_AUTOGEN' in l:
                    self.write_c_plugin(t)
                    autogen = True
                    autogen_done = True
                else:
                    if autogen:
                        if "#endif //VAPI_TO_C_AUTOGEN" in l:
                            autogen = False
                    else:
                        t.write(l)

            if not autogen_done:
                # the code will reach here if the original file doesn't 
                # have #define VAPI_TO_C_AUTOGEN block. Add it to the end.
                t.write('\n')
                self.write_c_plugin(t)

            t.seek(0)
            f.seek(0)
            for l in t:
                f.write(l)
            f.truncate()
            f.close()            
            t.close()
        else:
            if cfile_name:
                sys.stdout = open(cfile_name, 'w')
            self.write_c_plugin(sys.stdout)

    def read_file(self, vapi_file):
        f = open(vapi_file, 'r')
        for line in f:
            self.vapi_lines.append(line)
        
if __name__ == '__main__':
    # Parse the command line options
    desc = ('Generate the plugin extension code from VAPI. '
            'The script takes the vapi file as the first positional argument. '
            'If the c file is specified with --c-file option, it modifies the '
            'contents of file in place. All the autogenerated code will' 
            'be placed under #define VAPI_TO_C_AUTOGEN. '
            'If the "#define VAPI_TO_C_AUTOGEN" already present in the file '
            'the code and under that will be updated. If the file specified '
            'with --c-file option doesn\'t already exist, a new file will be '
            'created in the current directory. '
            'If the --c-file option is not provided the generated code '
            'will be output to the stdout. '
            'The --h-file option works similar to the --c-file, but generates a '
            'header file to include. [NOTE: this program assumes very strict '
            'format for VAPI files, i.e., doesn\'t use a full fledged grammar parser]')
        
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('vapi_file',
                        metavar='vapi-file',
                        help='input vapi filename')
    parser.add_argument('-c', '--c-file', help='output c filename')
    parser.add_argument('-x', '--h-file', help='output header filename')
    parser.add_argument('-g', '--gen-prototype',
                        action='store_true', help='generate function prototypes')
    parser.add_argument('-p', '--plugin-prefix',
                        help='specify a prefix to use for the plugin for autogenerated names')
    args = parser.parse_args()

    phases = ['c_iface_init_phase',
              'g_define_dynamic_type_phase',
              'peas_register_types_phase']

    if args.gen_prototype:
        print '--gen-prototype is not implemented yet.'
        print 'Please run without this option.'
        sys.exit(1)
        
    vapic = VapiC(args.gen_prototype)
    vapic.read_file(args.vapi_file)
    
    for phase in phases:
        vapic.parse_vapi(phase)

    vapic.gen_c_plugin(args.c_file)
    vapic.gen_h_plugin(args.h_file)

